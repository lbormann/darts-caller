{
  mappings: "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",
  sources: [
  "<anon>",
  "lib/global.ts",
  "lib/util.ts",
  "lib/dataconnection/BufferedConnection/binaryPackChunker.ts",
  "node_modules/peerjs-js-binarypack/dist/binarypack.mjs",
  "node_modules/peerjs-js-binarypack/lib/binarypack.ts",
  "node_modules/peerjs-js-binarypack/lib/bufferbuilder.ts",
  "lib/supports.ts",
  "node_modules/webrtc-adapter/src/js/adapter_core.js",
  "node_modules/webrtc-adapter/src/js/adapter_factory.js",
  "node_modules/webrtc-adapter/src/js/utils.js",
  "node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js",
  "node_modules/webrtc-adapter/src/js/chrome/getusermedia.js",
  "node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js",
  "node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js",
  "node_modules/webrtc-adapter/src/js/firefox/getusermedia.js",
  "node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js",
  "node_modules/webrtc-adapter/src/js/safari/safari_shim.js",
  "node_modules/webrtc-adapter/src/js/common_shim.js",
  "node_modules/sdp/sdp.js",
  "lib/utils/validateId.ts",
  "lib/utils/randomToken.ts",
  "lib/peer.ts",
  "lib/logger.ts",
  "lib/socket.ts",
  "node_modules/eventemitter3/index.js",
  "lib/enums.ts",
  "package.json",
  "lib/mediaconnection.ts",
  "lib/negotiator.ts",
  "lib/baseconnection.ts",
  "lib/peerError.ts",
  "lib/api.ts",
  "lib/dataconnection/BufferedConnection/BinaryPack.ts",
  "lib/dataconnection/BufferedConnection/BufferedConnection.ts",
  "lib/dataconnection/DataConnection.ts",
  "lib/dataconnection/BufferedConnection/Raw.ts",
  "lib/dataconnection/BufferedConnection/Json.ts"
  ],
  sourcesContent: [
  "(() => {
  
  function $parcel$export(e, n, v, s) {
    Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
  }
  
  function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
  }
  class $337647a69164cf0a$export$f1c5f4c9cb95390b {
      constructor(){
          this.chunkedMTU = 16300 // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.
          ;
          // Binary stuff
          this._dataCount = 1;
          this.chunk = (blob)=>{
              const chunks = [];
              const size = blob.byteLength;
              const total = Math.ceil(size / this.chunkedMTU);
              let index = 0;
              let start = 0;
              while(start < size){
                  const end = Math.min(size, start + this.chunkedMTU);
                  const b = blob.slice(start, end);
                  const chunk = {
                      __peerData: this._dataCount,
                      n: index,
                      data: b,
                      total: total
                  };
                  chunks.push(chunk);
                  start = end;
                  index++;
              }
              this._dataCount++;
              return chunks;
          };
      }
  }
  function $337647a69164cf0a$export$52c89ebcdc4f53f2(bufs) {
      let size = 0;
      for (const buf of bufs)size += buf.byteLength;
      const result = new Uint8Array(size);
      let offset = 0;
      for (const buf of bufs){
          result.set(buf, offset);
          offset += buf.byteLength;
      }
      return result;
  }
  
  
  class $41cdfe0a3ede2608$var$$e8379818650e2442$export$93654d4f2d6cd524 {
      append_buffer(data) {
          this.flush();
          this._parts.push(data);
      }
      append(data) {
          this._pieces.push(data);
      }
      flush() {
          if (this._pieces.length > 0) {
              const buf = new Uint8Array(this._pieces);
              this._parts.push(buf);
              this._pieces = [];
          }
      }
      toArrayBuffer() {
          const buffer = [];
          for (const part of this._parts)buffer.push(part);
          return $41cdfe0a3ede2608$var$$e8379818650e2442$var$concatArrayBuffers(buffer).buffer;
      }
      constructor(){
          this.encoder = new TextEncoder();
          this._pieces = [];
          this._parts = [];
      }
  }
  function $41cdfe0a3ede2608$var$$e8379818650e2442$var$concatArrayBuffers(bufs) {
      let size = 0;
      for (const buf of bufs)size += buf.byteLength;
      const result = new Uint8Array(size);
      let offset = 0;
      for (const buf of bufs){
          const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
          result.set(view, offset);
          offset += buf.byteLength;
      }
      return result;
  }
  function $41cdfe0a3ede2608$export$417857010dc9287f(data) {
      const unpacker = new $41cdfe0a3ede2608$var$$0cfd7828ad59115f$var$Unpacker(data);
      return unpacker.unpack();
  }
  function $41cdfe0a3ede2608$export$2a703dbb0cb35339(data) {
      const packer = new $41cdfe0a3ede2608$export$b9ec4b114aa40074();
      const res = packer.pack(data);
      if (res instanceof Promise) return res.then(()=>packer.getBuffer());
      return packer.getBuffer();
  }
  class $41cdfe0a3ede2608$var$$0cfd7828ad59115f$var$Unpacker {
      unpack() {
          const type = this.unpack_uint8();
          if (type < 0x80) return type;
          else if ((type ^ 0xe0) < 0x20) return (type ^ 0xe0) - 0x20;
          let size;
          if ((size = type ^ 0xa0) <= 0x0f) return this.unpack_raw(size);
          else if ((size = type ^ 0xb0) <= 0x0f) return this.unpack_string(size);
          else if ((size = type ^ 0x90) <= 0x0f) return this.unpack_array(size);
          else if ((size = type ^ 0x80) <= 0x0f) return this.unpack_map(size);
          switch(type){
              case 0xc0:
                  return null;
              case 0xc1:
                  return undefined;
              case 0xc2:
                  return false;
              case 0xc3:
                  return true;
              case 0xca:
                  return this.unpack_float();
              case 0xcb:
                  return this.unpack_double();
              case 0xcc:
                  return this.unpack_uint8();
              case 0xcd:
                  return this.unpack_uint16();
              case 0xce:
                  return this.unpack_uint32();
              case 0xcf:
                  return this.unpack_uint64();
              case 0xd0:
                  return this.unpack_int8();
              case 0xd1:
                  return this.unpack_int16();
              case 0xd2:
                  return this.unpack_int32();
              case 0xd3:
                  return this.unpack_int64();
              case 0xd4:
                  return undefined;
              case 0xd5:
                  return undefined;
              case 0xd6:
                  return undefined;
              case 0xd7:
                  return undefined;
              case 0xd8:
                  size = this.unpack_uint16();
                  return this.unpack_string(size);
              case 0xd9:
                  size = this.unpack_uint32();
                  return this.unpack_string(size);
              case 0xda:
                  size = this.unpack_uint16();
                  return this.unpack_raw(size);
              case 0xdb:
                  size = this.unpack_uint32();
                  return this.unpack_raw(size);
              case 0xdc:
                  size = this.unpack_uint16();
                  return this.unpack_array(size);
              case 0xdd:
                  size = this.unpack_uint32();
                  return this.unpack_array(size);
              case 0xde:
                  size = this.unpack_uint16();
                  return this.unpack_map(size);
              case 0xdf:
                  size = this.unpack_uint32();
                  return this.unpack_map(size);
          }
      }
      unpack_uint8() {
          const byte = this.dataView[this.index] & 0xff;
          this.index++;
          return byte;
      }
      unpack_uint16() {
          const bytes = this.read(2);
          const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);
          this.index += 2;
          return uint16;
      }
      unpack_uint32() {
          const bytes = this.read(4);
          const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
          this.index += 4;
          return uint32;
      }
      unpack_uint64() {
          const bytes = this.read(8);
          const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
          this.index += 8;
          return uint64;
      }
      unpack_int8() {
          const uint8 = this.unpack_uint8();
          return uint8 < 0x80 ? uint8 : uint8 - 256;
      }
      unpack_int16() {
          const uint16 = this.unpack_uint16();
          return uint16 < 0x8000 ? uint16 : uint16 - 65536;
      }
      unpack_int32() {
          const uint32 = this.unpack_uint32();
          return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;
      }
      unpack_int64() {
          const uint64 = this.unpack_uint64();
          return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;
      }
      unpack_raw(size) {
          if (this.length < this.index + size) throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`);
          const buf = this.dataBuffer.slice(this.index, this.index + size);
          this.index += size;
          return buf;
      }
      unpack_string(size) {
          const bytes = this.read(size);
          let i = 0;
          let str = "";
          let c;
          let code;
          while(i < size){
              c = bytes[i];
              // The length of a UTF-8 sequence is specified in the first byte:
              // 0xxxxxxx means length 1,
              // 110xxxxx means length 2,
              // 1110xxxx means length 3,
              // 11110xxx means length 4.
              // 10xxxxxx is for non-initial bytes.
              if (c < 0xa0) {
                  // One-byte sequence: bits 0xxxxxxx
                  code = c;
                  i++;
              } else if ((c ^ 0xc0) < 0x20) {
                  // Two-byte sequence: bits 110xxxxx 10xxxxxx
                  code = (c & 0x1f) << 6 | bytes[i + 1] & 0x3f;
                  i += 2;
              } else if ((c ^ 0xe0) < 0x10) {
                  // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx
                  code = (c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f;
                  i += 3;
              } else {
                  // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                  code = (c & 0x07) << 18 | (bytes[i + 1] & 0x3f) << 12 | (bytes[i + 2] & 0x3f) << 6 | bytes[i + 3] & 0x3f;
                  i += 4;
              }
              str += String.fromCodePoint(code);
          }
          this.index += size;
          return str;
      }
      unpack_array(size) {
          const objects = new Array(size);
          for(let i = 0; i < size; i++)objects[i] = this.unpack();
          return objects;
      }
      unpack_map(size) {
          const map = {};
          for(let i = 0; i < size; i++){
              const key = this.unpack();
              map[key] = this.unpack();
          }
          return map;
      }
      unpack_float() {
          const uint32 = this.unpack_uint32();
          const sign = uint32 >> 31;
          const exp = (uint32 >> 23 & 0xff) - 127;
          const fraction = uint32 & 0x7fffff | 0x800000;
          return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);
      }
      unpack_double() {
          const h32 = this.unpack_uint32();
          const l32 = this.unpack_uint32();
          const sign = h32 >> 31;
          const exp = (h32 >> 20 & 0x7ff) - 1023;
          const hfrac = h32 & 0xfffff | 0x100000;
          const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);
          return (sign === 0 ? 1 : -1) * frac;
      }
      read(length) {
          const j = this.index;
          if (j + length <= this.length) return this.dataView.subarray(j, j + length);
          else throw new Error("BinaryPackFailure: read index out of range");
      }
      constructor(data){
          this.index = 0;
          this.dataBuffer = data;
          this.dataView = new Uint8Array(this.dataBuffer);
          this.length = this.dataBuffer.byteLength;
      }
  }
  class $41cdfe0a3ede2608$export$b9ec4b114aa40074 {
      getBuffer() {
          return this._bufferBuilder.toArrayBuffer();
      }
      pack(value) {
          if (typeof value === "string") this.pack_string(value);
          else if (typeof value === "number") {
              if (Math.floor(value) === value) this.pack_integer(value);
              else this.pack_double(value);
          } else if (typeof value === "boolean") {
              if (value === true) this._bufferBuilder.append(0xc3);
              else if (value === false) this._bufferBuilder.append(0xc2);
          } else if (value === undefined) this._bufferBuilder.append(0xc0);
          else if (typeof value === "object") {
              if (value === null) this._bufferBuilder.append(0xc0);
              else {
                  const constructor = value.constructor;
                  if (value instanceof Array) {
                      const res = this.pack_array(value);
                      if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());
                  } else if (value instanceof ArrayBuffer) this.pack_bin(new Uint8Array(value));
                  else if ("BYTES_PER_ELEMENT" in value) {
                      const v = value;
                      this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
                  } else if (value instanceof Date) this.pack_string(value.toString());
                  else if (value instanceof Blob) return value.arrayBuffer().then((buffer)=>{
                      this.pack_bin(new Uint8Array(buffer));
                      this._bufferBuilder.flush();
                  });
                  else if (constructor == Object || constructor.toString().startsWith("class")) {
                      const res = this.pack_object(value);
                      if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());
                  } else throw new Error(`Type "${constructor.toString()}" not yet supported`);
              }
          } else throw new Error(`Type "${typeof value}" not yet supported`);
          this._bufferBuilder.flush();
      }
      pack_bin(blob) {
          const length = blob.length;
          if (length <= 0x0f) this.pack_uint8(0xa0 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xda);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdb);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          this._bufferBuilder.append_buffer(blob);
      }
      pack_string(str) {
          const encoded = this._textEncoder.encode(str);
          const length = encoded.length;
          if (length <= 0x0f) this.pack_uint8(0xb0 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xd8);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xd9);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          this._bufferBuilder.append_buffer(encoded);
      }
      pack_array(ary) {
          const length = ary.length;
          if (length <= 0x0f) this.pack_uint8(0x90 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xdc);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdd);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          const packNext = (index)=>{
              if (index < length) {
                  const res = this.pack(ary[index]);
                  if (res instanceof Promise) return res.then(()=>packNext(index + 1));
                  return packNext(index + 1);
              }
          };
          return packNext(0);
      }
      pack_integer(num) {
          if (num >= -32 && num <= 0x7f) this._bufferBuilder.append(num & 0xff);
          else if (num >= 0x00 && num <= 0xff) {
              this._bufferBuilder.append(0xcc);
              this.pack_uint8(num);
          } else if (num >= -128 && num <= 0x7f) {
              this._bufferBuilder.append(0xd0);
              this.pack_int8(num);
          } else if (num >= 0x0000 && num <= 0xffff) {
              this._bufferBuilder.append(0xcd);
              this.pack_uint16(num);
          } else if (num >= -32768 && num <= 0x7fff) {
              this._bufferBuilder.append(0xd1);
              this.pack_int16(num);
          } else if (num >= 0x00000000 && num <= 0xffffffff) {
              this._bufferBuilder.append(0xce);
              this.pack_uint32(num);
          } else if (num >= -2147483648 && num <= 0x7fffffff) {
              this._bufferBuilder.append(0xd2);
              this.pack_int32(num);
          } else if (num >= -9223372036854776000 && num <= 0x7fffffffffffffff) {
              this._bufferBuilder.append(0xd3);
              this.pack_int64(num);
          } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {
              this._bufferBuilder.append(0xcf);
              this.pack_uint64(num);
          } else throw new Error("Invalid integer");
      }
      pack_double(num) {
          let sign = 0;
          if (num < 0) {
              sign = 1;
              num = -num;
          }
          const exp = Math.floor(Math.log(num) / Math.LN2);
          const frac0 = num / 2 ** exp - 1;
          const frac1 = Math.floor(frac0 * 2 ** 52);
          const b32 = 2 ** 32;
          const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 0x0fffff;
          const l32 = frac1 % b32;
          this._bufferBuilder.append(0xcb);
          this.pack_int32(h32);
          this.pack_int32(l32);
      }
      pack_object(obj) {
          const keys = Object.keys(obj);
          const length = keys.length;
          if (length <= 0x0f) this.pack_uint8(0x80 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xde);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdf);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          const packNext = (index)=>{
              if (index < keys.length) {
                  const prop = keys[index];
                  // eslint-disable-next-line no-prototype-builtins
                  if (obj.hasOwnProperty(prop)) {
                      this.pack(prop);
                      const res = this.pack(obj[prop]);
                      if (res instanceof Promise) return res.then(()=>packNext(index + 1));
                  }
                  return packNext(index + 1);
              }
          };
          return packNext(0);
      }
      pack_uint8(num) {
          this._bufferBuilder.append(num);
      }
      pack_uint16(num) {
          this._bufferBuilder.append(num >> 8);
          this._bufferBuilder.append(num & 0xff);
      }
      pack_uint32(num) {
          const n = num & 0xffffffff;
          this._bufferBuilder.append((n & 0xff000000) >>> 24);
          this._bufferBuilder.append((n & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((n & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(n & 0x000000ff);
      }
      pack_uint64(num) {
          const high = num / 2 ** 32;
          const low = num % 2 ** 32;
          this._bufferBuilder.append((high & 0xff000000) >>> 24);
          this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(high & 0x000000ff);
          this._bufferBuilder.append((low & 0xff000000) >>> 24);
          this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(low & 0x000000ff);
      }
      pack_int8(num) {
          this._bufferBuilder.append(num & 0xff);
      }
      pack_int16(num) {
          this._bufferBuilder.append((num & 0xff00) >> 8);
          this._bufferBuilder.append(num & 0xff);
      }
      pack_int32(num) {
          this._bufferBuilder.append(num >>> 24 & 0xff);
          this._bufferBuilder.append((num & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((num & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(num & 0x000000ff);
      }
      pack_int64(num) {
          const high = Math.floor(num / 2 ** 32);
          const low = num % 2 ** 32;
          this._bufferBuilder.append((high & 0xff000000) >>> 24);
          this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(high & 0x000000ff);
          this._bufferBuilder.append((low & 0xff000000) >>> 24);
          this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(low & 0x000000ff);
      }
      constructor(){
          this._bufferBuilder = new $41cdfe0a3ede2608$var$$e8379818650e2442$export$93654d4f2d6cd524();
          this._textEncoder = new TextEncoder();
      }
  }
  
  
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ "use strict";
  let $11d9b3e4fc7791e1$var$logDisabled_ = true;
  let $11d9b3e4fc7791e1$var$deprecationWarnings_ = true;
  function $11d9b3e4fc7791e1$export$e3c02be309be1f23(uastring, expr, pos) {
      const match = uastring.match(expr);
      return match && match.length >= pos && parseInt(match[pos], 10);
  }
  function $11d9b3e4fc7791e1$export$1f48841962b828b1(window1, eventNameToWrap, wrapper) {
      if (!window1.RTCPeerConnection) return;
      const proto = window1.RTCPeerConnection.prototype;
      const nativeAddEventListener = proto.addEventListener;
      proto.addEventListener = function(nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap) return nativeAddEventListener.apply(this, arguments);
          const wrappedCallback = (e)=>{
              const modifiedEvent = wrapper(e);
              if (modifiedEvent) {
                  if (cb.handleEvent) cb.handleEvent(modifiedEvent);
                  else cb(modifiedEvent);
              }
          };
          this._eventMap = this._eventMap || {};
          if (!this._eventMap[eventNameToWrap]) this._eventMap[eventNameToWrap] = new Map();
          this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
          return nativeAddEventListener.apply(this, [
              nativeEventName,
              wrappedCallback
          ]);
      };
      const nativeRemoveEventListener = proto.removeEventListener;
      proto.removeEventListener = function(nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) return nativeRemoveEventListener.apply(this, arguments);
          if (!this._eventMap[eventNameToWrap].has(cb)) return nativeRemoveEventListener.apply(this, arguments);
          const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
          this._eventMap[eventNameToWrap].delete(cb);
          if (this._eventMap[eventNameToWrap].size === 0) delete this._eventMap[eventNameToWrap];
          if (Object.keys(this._eventMap).length === 0) delete this._eventMap;
          return nativeRemoveEventListener.apply(this, [
              nativeEventName,
              unwrappedCb
          ]);
      };
      Object.defineProperty(proto, "on" + eventNameToWrap, {
          get () {
              return this["_on" + eventNameToWrap];
          },
          set (cb) {
              if (this["_on" + eventNameToWrap]) {
                  this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
                  delete this["_on" + eventNameToWrap];
              }
              if (cb) this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
          },
          enumerable: true,
          configurable: true
      });
  }
  function $11d9b3e4fc7791e1$export$afbfee8cc06fd3e4(bool) {
      if (typeof bool !== "boolean") return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
      $11d9b3e4fc7791e1$var$logDisabled_ = bool;
      return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
  }
  function $11d9b3e4fc7791e1$export$51516be4b019e41e(bool) {
      if (typeof bool !== "boolean") return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
      $11d9b3e4fc7791e1$var$deprecationWarnings_ = !bool;
      return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
  }
  function $11d9b3e4fc7791e1$export$bef1f36f5486a6a3() {
      if (typeof window === "object") {
          if ($11d9b3e4fc7791e1$var$logDisabled_) return;
          if (typeof console !== "undefined" && typeof console.log === "function") console.log.apply(console, arguments);
      }
  }
  function $11d9b3e4fc7791e1$export$cdd73fc4100a6ef4(oldMethod, newMethod) {
      if (!$11d9b3e4fc7791e1$var$deprecationWarnings_) return;
      console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
  }
  function $11d9b3e4fc7791e1$export$2d31490a0c05f094(window1) {
      // Returned result object.
      const result = {
          browser: null,
          version: null
      };
      // Fail early if it's not a browser
      if (typeof window1 === "undefined" || !window1.navigator || !window1.navigator.userAgent) {
          result.browser = "Not a browser.";
          return result;
      }
      const { navigator: navigator } = window1;
      if (navigator.mozGetUserMedia) {
          result.browser = "firefox";
          result.version = $11d9b3e4fc7791e1$export$e3c02be309be1f23(navigator.userAgent, /Firefox\/(\d+)\./, 1);
      } else if (navigator.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {
          // Chrome, Chromium, Webview, Opera.
          // Version matches Chrome/WebRTC version.
          // Chrome 74 removed webkitGetUserMedia on http as well so we need the
          // more complicated fallback to webkitRTCPeerConnection.
          result.browser = "chrome";
          result.version = $11d9b3e4fc7791e1$export$e3c02be309be1f23(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
      } else if (window1.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
          result.browser = "safari";
          result.version = $11d9b3e4fc7791e1$export$e3c02be309be1f23(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
          result.supportsUnifiedPlan = window1.RTCRtpTransceiver && "currentDirection" in window1.RTCRtpTransceiver.prototype;
      } else {
          result.browser = "Not a supported browser.";
          return result;
      }
      return result;
  }
  /**
   * Checks if something is an object.
   *
   * @param {*} val The something you want to check.
   * @return true if val is an object, false otherwise.
   */ function $11d9b3e4fc7791e1$var$isObject(val) {
      return Object.prototype.toString.call(val) === "[object Object]";
  }
  function $11d9b3e4fc7791e1$export$15384eac40dc88c8(data) {
      if (!$11d9b3e4fc7791e1$var$isObject(data)) return data;
      return Object.keys(data).reduce(function(accumulator, key) {
          const isObj = $11d9b3e4fc7791e1$var$isObject(data[key]);
          const value = isObj ? $11d9b3e4fc7791e1$export$15384eac40dc88c8(data[key]) : data[key];
          const isEmptyObject = isObj && !Object.keys(value).length;
          if (value === undefined || isEmptyObject) return accumulator;
          return Object.assign(accumulator, {
              [key]: value
          });
      }, {});
  }
  function $11d9b3e4fc7791e1$export$571b373e75babb58(stats, base, resultSet) {
      if (!base || resultSet.has(base.id)) return;
      resultSet.set(base.id, base);
      Object.keys(base).forEach((name)=>{
          if (name.endsWith("Id")) $11d9b3e4fc7791e1$export$571b373e75babb58(stats, stats.get(base[name]), resultSet);
          else if (name.endsWith("Ids")) base[name].forEach((id)=>{
              $11d9b3e4fc7791e1$export$571b373e75babb58(stats, stats.get(id), resultSet);
          });
      });
  }
  function $11d9b3e4fc7791e1$export$93439ffc3f787d51(result, track, outbound) {
      const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
      const filteredResult = new Map();
      if (track === null) return filteredResult;
      const trackStats = [];
      result.forEach((value)=>{
          if (value.type === "track" && value.trackIdentifier === track.id) trackStats.push(value);
      });
      trackStats.forEach((trackStat)=>{
          result.forEach((stats)=>{
              if (stats.type === streamStatsType && stats.trackId === trackStat.id) $11d9b3e4fc7791e1$export$571b373e75babb58(result, stats, filteredResult);
          });
      });
      return filteredResult;
  }
  
  
  var $041f4f4318baab2c$exports = {};
  
  $parcel$export($041f4f4318baab2c$exports, "shimMediaStream", () => $041f4f4318baab2c$export$33ee24e7a300bcd1);
  $parcel$export($041f4f4318baab2c$exports, "shimOnTrack", () => $041f4f4318baab2c$export$f358708f68ab068);
  $parcel$export($041f4f4318baab2c$exports, "shimGetSendersWithDtmf", () => $041f4f4318baab2c$export$a41a030a2842f5d6);
  $parcel$export($041f4f4318baab2c$exports, "shimGetStats", () => $041f4f4318baab2c$export$90608323826f0b17);
  $parcel$export($041f4f4318baab2c$exports, "shimSenderReceiverGetStats", () => $041f4f4318baab2c$export$f2f0f2338114eb4b);
  $parcel$export($041f4f4318baab2c$exports, "shimAddTrackRemoveTrackWithNative", () => $041f4f4318baab2c$export$30e3cdd46f8d5100);
  $parcel$export($041f4f4318baab2c$exports, "shimAddTrackRemoveTrack", () => $041f4f4318baab2c$export$9588259fcf4ebc91);
  $parcel$export($041f4f4318baab2c$exports, "shimPeerConnection", () => $041f4f4318baab2c$export$852a08dda9a55ea7);
  $parcel$export($041f4f4318baab2c$exports, "fixNegotiationNeeded", () => $041f4f4318baab2c$export$341293bbeaae37cb);
  $parcel$export($041f4f4318baab2c$exports, "shimGetUserMedia", () => $b54ff3b82f3d51d6$export$1ed4910f4d37dc5e);
  $parcel$export($041f4f4318baab2c$exports, "shimGetDisplayMedia", () => $4cbb13d690da2bd9$export$97270b87351d9c04);
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ 
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ 
  "use strict";
  const $b54ff3b82f3d51d6$var$logging = $11d9b3e4fc7791e1$export$bef1f36f5486a6a3;
  function $b54ff3b82f3d51d6$export$1ed4910f4d37dc5e(window, browserDetails) {
      const navigator = window && window.navigator;
      if (!navigator.mediaDevices) return;
      const constraintsToChrome_ = function(c) {
          if (typeof c !== "object" || c.mandatory || c.optional) return c;
          const cc = {};
          Object.keys(c).forEach((key)=>{
              if (key === "require" || key === "advanced" || key === "mediaSource") return;
              const r = typeof c[key] === "object" ? c[key] : {
                  ideal: c[key]
              };
              if (r.exact !== undefined && typeof r.exact === "number") r.min = r.max = r.exact;
              const oldname_ = function(prefix, name) {
                  if (prefix) return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                  return name === "deviceId" ? "sourceId" : name;
              };
              if (r.ideal !== undefined) {
                  cc.optional = cc.optional || [];
                  let oc = {};
                  if (typeof r.ideal === "number") {
                      oc[oldname_("min", key)] = r.ideal;
                      cc.optional.push(oc);
                      oc = {};
                      oc[oldname_("max", key)] = r.ideal;
                      cc.optional.push(oc);
                  } else {
                      oc[oldname_("", key)] = r.ideal;
                      cc.optional.push(oc);
                  }
              }
              if (r.exact !== undefined && typeof r.exact !== "number") {
                  cc.mandatory = cc.mandatory || {};
                  cc.mandatory[oldname_("", key)] = r.exact;
              } else [
                  "min",
                  "max"
              ].forEach((mix)=>{
                  if (r[mix] !== undefined) {
                      cc.mandatory = cc.mandatory || {};
                      cc.mandatory[oldname_(mix, key)] = r[mix];
                  }
              });
          });
          if (c.advanced) cc.optional = (cc.optional || []).concat(c.advanced);
          return cc;
      };
      const shimConstraints_ = function(constraints, func) {
          if (browserDetails.version >= 61) return func(constraints);
          constraints = JSON.parse(JSON.stringify(constraints));
          if (constraints && typeof constraints.audio === "object") {
              const remap = function(obj, a, b) {
                  if (a in obj && !(b in obj)) {
                      obj[b] = obj[a];
                      delete obj[a];
                  }
              };
              constraints = JSON.parse(JSON.stringify(constraints));
              remap(constraints.audio, "autoGainControl", "googAutoGainControl");
              remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
              constraints.audio = constraintsToChrome_(constraints.audio);
          }
          if (constraints && typeof constraints.video === "object") {
              // Shim facingMode for mobile & surface pro.
              let face = constraints.video.facingMode;
              face = face && (typeof face === "object" ? face : {
                  ideal: face
              });
              const getSupportedFacingModeLies = browserDetails.version < 66;
              if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
                  delete constraints.video.facingMode;
                  let matches;
                  if (face.exact === "environment" || face.ideal === "environment") matches = [
                      "back",
                      "rear"
                  ];
                  else if (face.exact === "user" || face.ideal === "user") matches = [
                      "front"
                  ];
                  if (matches) // Look for matches in label, or use last cam for back (typical).
                  return navigator.mediaDevices.enumerateDevices().then((devices)=>{
                      devices = devices.filter((d)=>d.kind === "videoinput");
                      let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));
                      if (!dev && devices.length && matches.includes("back")) dev = devices[devices.length - 1]; // more likely the back cam
                      if (dev) constraints.video.deviceId = face.exact ? {
                          exact: dev.deviceId
                      } : {
                          ideal: dev.deviceId
                      };
                      constraints.video = constraintsToChrome_(constraints.video);
                      $b54ff3b82f3d51d6$var$logging("chrome: " + JSON.stringify(constraints));
                      return func(constraints);
                  });
              }
              constraints.video = constraintsToChrome_(constraints.video);
          }
          $b54ff3b82f3d51d6$var$logging("chrome: " + JSON.stringify(constraints));
          return func(constraints);
      };
      const shimError_ = function(e) {
          if (browserDetails.version >= 64) return e;
          return {
              name: ({
                  PermissionDeniedError: "NotAllowedError",
                  PermissionDismissedError: "NotAllowedError",
                  InvalidStateError: "NotAllowedError",
                  DevicesNotFoundError: "NotFoundError",
                  ConstraintNotSatisfiedError: "OverconstrainedError",
                  TrackStartError: "NotReadableError",
                  MediaDeviceFailedDueToShutdown: "NotAllowedError",
                  MediaDeviceKillSwitchOn: "NotAllowedError",
                  TabCaptureError: "AbortError",
                  ScreenCaptureError: "AbortError",
                  DeviceCaptureError: "AbortError"
              })[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString () {
                  return this.name + (this.message && ": ") + this.message;
              }
          };
      };
      const getUserMedia_ = function(constraints, onSuccess, onError) {
          shimConstraints_(constraints, (c)=>{
              navigator.webkitGetUserMedia(c, onSuccess, (e)=>{
                  if (onError) onError(shimError_(e));
              });
          });
      };
      navigator.getUserMedia = getUserMedia_.bind(navigator);
      // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
      // function which returns a Promise, it does not accept spec-style
      // constraints.
      if (navigator.mediaDevices.getUserMedia) {
          const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function(cs) {
              return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{
                      if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                          stream.getTracks().forEach((track)=>{
                              track.stop();
                          });
                          throw new DOMException("", "NotFoundError");
                      }
                      return stream;
                  }, (e)=>Promise.reject(shimError_(e))));
          };
      }
  }
  
  
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ "use strict";
  function $4cbb13d690da2bd9$export$97270b87351d9c04(window, getSourceId) {
      if (window.navigator.mediaDevices && "getDisplayMedia" in window.navigator.mediaDevices) return;
      if (!window.navigator.mediaDevices) return;
      // getSourceId is a function that returns a promise resolving with
      // the sourceId of the screen/window/tab to be shared.
      if (typeof getSourceId !== "function") {
          console.error("shimGetDisplayMedia: getSourceId argument is not a function");
          return;
      }
      window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          return getSourceId(constraints).then((sourceId)=>{
              const widthSpecified = constraints.video && constraints.video.width;
              const heightSpecified = constraints.video && constraints.video.height;
              const frameRateSpecified = constraints.video && constraints.video.frameRate;
              constraints.video = {
                  mandatory: {
                      chromeMediaSource: "desktop",
                      chromeMediaSourceId: sourceId,
                      maxFrameRate: frameRateSpecified || 3
                  }
              };
              if (widthSpecified) constraints.video.mandatory.maxWidth = widthSpecified;
              if (heightSpecified) constraints.video.mandatory.maxHeight = heightSpecified;
              return window.navigator.mediaDevices.getUserMedia(constraints);
          });
      };
  }
  
  
  "use strict";
  function $041f4f4318baab2c$export$33ee24e7a300bcd1(window) {
      window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }
  function $041f4f4318baab2c$export$f358708f68ab068(window) {
      if (typeof window === "object" && window.RTCPeerConnection && !("ontrack" in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
              get () {
                  return this._ontrack;
              },
              set (f) {
                  if (this._ontrack) this.removeEventListener("track", this._ontrack);
                  this.addEventListener("track", this._ontrack = f);
              },
              enumerable: true,
              configurable: true
          });
          const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              if (!this._ontrackpoly) {
                  this._ontrackpoly = (e)=>{
                      // onaddstream does not fire when a track is added to an existing
                      // stream. But stream.onaddtrack is implemented so we use that.
                      e.stream.addEventListener("addtrack", (te)=>{
                          let receiver;
                          if (window.RTCPeerConnection.prototype.getReceivers) receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);
                          else receiver = {
                              track: te.track
                          };
                          const event = new Event("track");
                          event.track = te.track;
                          event.receiver = receiver;
                          event.transceiver = {
                              receiver: receiver
                          };
                          event.streams = [
                              e.stream
                          ];
                          this.dispatchEvent(event);
                      });
                      e.stream.getTracks().forEach((track)=>{
                          let receiver;
                          if (window.RTCPeerConnection.prototype.getReceivers) receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);
                          else receiver = {
                              track: track
                          };
                          const event = new Event("track");
                          event.track = track;
                          event.receiver = receiver;
                          event.transceiver = {
                              receiver: receiver
                          };
                          event.streams = [
                              e.stream
                          ];
                          this.dispatchEvent(event);
                      });
                  };
                  this.addEventListener("addstream", this._ontrackpoly);
              }
              return origSetRemoteDescription.apply(this, arguments);
          };
      } else // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "track", (e)=>{
          if (!e.transceiver) Object.defineProperty(e, "transceiver", {
              value: {
                  receiver: e.receiver
              }
          });
          return e;
      });
  }
  function $041f4f4318baab2c$export$a41a030a2842f5d6(window) {
      // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
      if (typeof window === "object" && window.RTCPeerConnection && !("getSenders" in window.RTCPeerConnection.prototype) && "createDTMFSender" in window.RTCPeerConnection.prototype) {
          const shimSenderWithDtmf = function(pc, track) {
              return {
                  track: track,
                  get dtmf () {
                      if (this._dtmf === undefined) {
                          if (track.kind === "audio") this._dtmf = pc.createDTMFSender(track);
                          else this._dtmf = null;
                      }
                      return this._dtmf;
                  },
                  _pc: pc
              };
          };
          // augment addTrack when getSenders is not available.
          if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                  this._senders = this._senders || [];
                  return this._senders.slice(); // return a copy of the internal state.
              };
              const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
              window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
                  let sender = origAddTrack.apply(this, arguments);
                  if (!sender) {
                      sender = shimSenderWithDtmf(this, track);
                      this._senders.push(sender);
                  }
                  return sender;
              };
              const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
              window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
                  origRemoveTrack.apply(this, arguments);
                  const idx = this._senders.indexOf(sender);
                  if (idx !== -1) this._senders.splice(idx, 1);
              };
          }
          const origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              this._senders = this._senders || [];
              origAddStream.apply(this, [
                  stream
              ]);
              stream.getTracks().forEach((track)=>{
                  this._senders.push(shimSenderWithDtmf(this, track));
              });
          };
          const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              this._senders = this._senders || [];
              origRemoveStream.apply(this, [
                  stream
              ]);
              stream.getTracks().forEach((track)=>{
                  const sender = this._senders.find((s)=>s.track === track);
                  if (sender) this._senders.splice(this._senders.indexOf(sender), 1);
              });
          };
      } else if (typeof window === "object" && window.RTCPeerConnection && "getSenders" in window.RTCPeerConnection.prototype && "createDTMFSender" in window.RTCPeerConnection.prototype && window.RTCRtpSender && !("dtmf" in window.RTCRtpSender.prototype)) {
          const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const senders = origGetSenders.apply(this, []);
              senders.forEach((sender)=>sender._pc = this);
              return senders;
          };
          Object.defineProperty(window.RTCRtpSender.prototype, "dtmf", {
              get () {
                  if (this._dtmf === undefined) {
                      if (this.track.kind === "audio") this._dtmf = this._pc.createDTMFSender(this.track);
                      else this._dtmf = null;
                  }
                  return this._dtmf;
              }
          });
      }
  }
  function $041f4f4318baab2c$export$90608323826f0b17(window) {
      if (!window.RTCPeerConnection) return;
      const origGetStats = window.RTCPeerConnection.prototype.getStats;
      window.RTCPeerConnection.prototype.getStats = function getStats() {
          const [selector, onSucc, onErr] = arguments;
          // If selector is a function then we are in the old style stats so just
          // pass back the original getStats format to avoid breaking old users.
          if (arguments.length > 0 && typeof selector === "function") return origGetStats.apply(this, arguments);
          // When spec-style getStats is supported, return those when called with
          // either no arguments or the selector argument is null.
          if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) return origGetStats.apply(this, []);
          const fixChromeStats_ = function(response) {
              const standardReport = {};
              const reports = response.result();
              reports.forEach((report)=>{
                  const standardStats = {
                      id: report.id,
                      timestamp: report.timestamp,
                      type: {
                          localcandidate: "local-candidate",
                          remotecandidate: "remote-candidate"
                      }[report.type] || report.type
                  };
                  report.names().forEach((name)=>{
                      standardStats[name] = report.stat(name);
                  });
                  standardReport[standardStats.id] = standardStats;
              });
              return standardReport;
          };
          // shim getStats with maplike support
          const makeMapStats = function(stats) {
              return new Map(Object.keys(stats).map((key)=>[
                      key,
                      stats[key]
                  ]));
          };
          if (arguments.length >= 2) {
              const successCallbackWrapper_ = function(response) {
                  onSucc(makeMapStats(fixChromeStats_(response)));
              };
              return origGetStats.apply(this, [
                  successCallbackWrapper_,
                  selector
              ]);
          }
          // promise-support
          return new Promise((resolve, reject)=>{
              origGetStats.apply(this, [
                  function(response) {
                      resolve(makeMapStats(fixChromeStats_(response)));
                  },
                  reject
              ]);
          }).then(onSucc, onErr);
      };
  }
  function $041f4f4318baab2c$export$f2f0f2338114eb4b(window) {
      if (!(typeof window === "object" && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) return;
      // shim sender stats.
      if (!("getStats" in window.RTCRtpSender.prototype)) {
          const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          if (origGetSenders) window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const senders = origGetSenders.apply(this, []);
              senders.forEach((sender)=>sender._pc = this);
              return senders;
          };
          const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          if (origAddTrack) window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              const sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
          };
          window.RTCRtpSender.prototype.getStats = function getStats() {
              const sender = this;
              return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */ $11d9b3e4fc7791e1$export$93439ffc3f787d51(result, sender.track, true));
          };
      }
      // shim receiver stats.
      if (!("getStats" in window.RTCRtpReceiver.prototype)) {
          const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
          if (origGetReceivers) window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              const receivers = origGetReceivers.apply(this, []);
              receivers.forEach((receiver)=>receiver._pc = this);
              return receivers;
          };
          $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "track", (e)=>{
              e.receiver._pc = e.srcElement;
              return e;
          });
          window.RTCRtpReceiver.prototype.getStats = function getStats() {
              const receiver = this;
              return this._pc.getStats().then((result)=>$11d9b3e4fc7791e1$export$93439ffc3f787d51(result, receiver.track, false));
          };
      }
      if (!("getStats" in window.RTCRtpSender.prototype && "getStats" in window.RTCRtpReceiver.prototype)) return;
      // shim RTCPeerConnection.getStats(track).
      const origGetStats = window.RTCPeerConnection.prototype.getStats;
      window.RTCPeerConnection.prototype.getStats = function getStats() {
          if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
              const track = arguments[0];
              let sender;
              let receiver;
              let err;
              this.getSenders().forEach((s)=>{
                  if (s.track === track) {
                      if (sender) err = true;
                      else sender = s;
                  }
              });
              this.getReceivers().forEach((r)=>{
                  if (r.track === track) {
                      if (receiver) err = true;
                      else receiver = r;
                  }
                  return r.track === track;
              });
              if (err || sender && receiver) return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
              else if (sender) return sender.getStats();
              else if (receiver) return receiver.getStats();
              return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return origGetStats.apply(this, arguments);
      };
  }
  function $041f4f4318baab2c$export$30e3cdd46f8d5100(window) {
      // shim addTrack/removeTrack with native variants in order to make
      // the interactions with legacy getLocalStreams behave as in other browsers.
      // Keeps a mapping stream.id => [stream, rtpsenders...]
      window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);
      };
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          if (!stream) return origAddTrack.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const sender = origAddTrack.apply(this, arguments);
          if (!this._shimmedLocalStreams[stream.id]) this._shimmedLocalStreams[stream.id] = [
              stream,
              sender
          ];
          else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) this._shimmedLocalStreams[stream.id].push(sender);
          return sender;
      };
      const origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          stream.getTracks().forEach((track)=>{
              const alreadyExists = this.getSenders().find((s)=>s.track === track);
              if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const existingSenders = this.getSenders();
          origAddStream.apply(this, arguments);
          const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);
          this._shimmedLocalStreams[stream.id] = [
              stream
          ].concat(newSenders);
      };
      const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          delete this._shimmedLocalStreams[stream.id];
          return origRemoveStream.apply(this, arguments);
      };
      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          if (sender) Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{
              const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
              if (idx !== -1) this._shimmedLocalStreams[streamId].splice(idx, 1);
              if (this._shimmedLocalStreams[streamId].length === 1) delete this._shimmedLocalStreams[streamId];
          });
          return origRemoveTrack.apply(this, arguments);
      };
  }
  function $041f4f4318baab2c$export$9588259fcf4ebc91(window, browserDetails) {
      if (!window.RTCPeerConnection) return;
      // shim addTrack and removeTrack.
      if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) return $041f4f4318baab2c$export$30e3cdd46f8d5100(window);
      // also shim pc.getLocalStreams when addTrack is shimmed
      // to return the original streams.
      const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
      window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          const nativeStreams = origGetLocalStreams.apply(this);
          this._reverseStreams = this._reverseStreams || {};
          return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);
      };
      const origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};
          stream.getTracks().forEach((track)=>{
              const alreadyExists = this.getSenders().find((s)=>s.track === track);
              if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          // Add identity mapping for consistency with addTrack.
          // Unless this is being used with a stream from addTrack.
          if (!this._reverseStreams[stream.id]) {
              const newStream = new window.MediaStream(stream.getTracks());
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              stream = newStream;
          }
          origAddStream.apply(this, [
              stream
          ]);
      };
      const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};
          origRemoveStream.apply(this, [
              this._streams[stream.id] || stream
          ]);
          delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
          delete this._streams[stream.id];
      };
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const streams = [].slice.call(arguments, 1);
          if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) // this is not fully correct but all we can manage without
          // [[associated MediaStreams]] internal slot.
          throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const alreadyExists = this.getSenders().find((s)=>s.track === track);
          if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};
          const oldStream = this._streams[stream.id];
          if (oldStream) {
              // this is using odd Chrome behaviour, use with caution:
              // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
              // Note: we rely on the high-level addTrack/dtmf shim to
              // create the sender with a dtmf sender.
              oldStream.addTrack(track);
              // Trigger ONN async.
              Promise.resolve().then(()=>{
                  this.dispatchEvent(new Event("negotiationneeded"));
              });
          } else {
              const newStream = new window.MediaStream([
                  track
              ]);
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              this.addStream(newStream);
          }
          return this.getSenders().find((s)=>s.track === track);
      };
      // replace the internal stream id with the external one and
      // vice versa.
      function replaceInternalStreamId(pc, description) {
          let sdp = description.sdp;
          Object.keys(pc._reverseStreams || []).forEach((internalId)=>{
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, "g"), externalStream.id);
          });
          return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
          });
      }
      function replaceExternalStreamId(pc, description) {
          let sdp = description.sdp;
          Object.keys(pc._reverseStreams || []).forEach((internalId)=>{
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, "g"), internalStream.id);
          });
          return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
          });
      }
      [
          "createOffer",
          "createAnswer"
      ].forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {
              [method] () {
                  const args = arguments;
                  const isLegacyCall = arguments.length && typeof arguments[0] === "function";
                  if (isLegacyCall) return nativeMethod.apply(this, [
                      (description)=>{
                          const desc = replaceInternalStreamId(this, description);
                          args[0].apply(null, [
                              desc
                          ]);
                      },
                      (err)=>{
                          if (args[1]) args[1].apply(null, err);
                      },
                      arguments[2]
                  ]);
                  return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));
              }
          };
          window.RTCPeerConnection.prototype[method] = methodObj[method];
      });
      const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
      window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
          if (!arguments.length || !arguments[0].type) return origSetLocalDescription.apply(this, arguments);
          arguments[0] = replaceExternalStreamId(this, arguments[0]);
          return origSetLocalDescription.apply(this, arguments);
      };
      // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier
      const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, "localDescription");
      Object.defineProperty(window.RTCPeerConnection.prototype, "localDescription", {
          get () {
              const description = origLocalDescription.get.apply(this);
              if (description.type === "") return description;
              return replaceInternalStreamId(this, description);
          }
      });
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          // We can not yet check for sender instanceof RTCRtpSender
          // since we shim RTPSender. So we check if sender._pc is set.
          if (!sender._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          const isLocal = sender._pc === this;
          if (!isLocal) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          // Search for the native stream the senders track belongs to.
          this._streams = this._streams || {};
          let stream;
          Object.keys(this._streams).forEach((streamid)=>{
              const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);
              if (hasTrack) stream = this._streams[streamid];
          });
          if (stream) {
              if (stream.getTracks().length === 1) // if this is the last track of the stream, remove the stream. This
              // takes care of any shimmed _senders.
              this.removeStream(this._reverseStreams[stream.id]);
              else // relying on the same odd chrome behaviour as above.
              stream.removeTrack(sender.track);
              this.dispatchEvent(new Event("negotiationneeded"));
          }
      };
  }
  function $041f4f4318baab2c$export$852a08dda9a55ea7(window, browserDetails) {
      if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
      if (!window.RTCPeerConnection) return;
      // shim implicit creation of RTCSessionDescription/RTCIceCandidate
      if (browserDetails.version < 53) [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate"
      ].forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {
              [method] () {
                  arguments[0] = new (method === "addIceCandidate" ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                  return nativeMethod.apply(this, arguments);
              }
          };
          window.RTCPeerConnection.prototype[method] = methodObj[method];
      });
  }
  function $041f4f4318baab2c$export$341293bbeaae37cb(window, browserDetails) {
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "negotiationneeded", (e)=>{
          const pc = e.target;
          if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
              if (pc.signalingState !== "stable") return;
          }
          return e;
      });
  }
  
  
  var $5ba25c21eb1c0af8$exports = {};
  
  $parcel$export($5ba25c21eb1c0af8$exports, "shimOnTrack", () => $5ba25c21eb1c0af8$export$f358708f68ab068);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimPeerConnection", () => $5ba25c21eb1c0af8$export$852a08dda9a55ea7);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimSenderGetStats", () => $5ba25c21eb1c0af8$export$f0525502095c04ef);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimReceiverGetStats", () => $5ba25c21eb1c0af8$export$83d69126527b1171);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimRemoveStream", () => $5ba25c21eb1c0af8$export$825e523ef749bd8c);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimRTCDataChannel", () => $5ba25c21eb1c0af8$export$ff9cb3bc8990e8f7);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimAddTransceiver", () => $5ba25c21eb1c0af8$export$70c77533b6e9908d);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimGetParameters", () => $5ba25c21eb1c0af8$export$66238223c298fbaa);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimCreateOffer", () => $5ba25c21eb1c0af8$export$51beccf0e777b843);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimCreateAnswer", () => $5ba25c21eb1c0af8$export$df0b46e7cef08150);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimGetUserMedia", () => $138811b977baa945$export$1ed4910f4d37dc5e);
  $parcel$export($5ba25c21eb1c0af8$exports, "shimGetDisplayMedia", () => $d08a6680f3298ef0$export$97270b87351d9c04);
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ 
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ 
  "use strict";
  function $138811b977baa945$export$1ed4910f4d37dc5e(window, browserDetails) {
      const navigator = window && window.navigator;
      const MediaStreamTrack = window && window.MediaStreamTrack;
      navigator.getUserMedia = function(constraints, onSuccess, onError) {
          // Replace Firefox 44+'s deprecation warning with unprefixed version.
          $11d9b3e4fc7791e1$export$cdd73fc4100a6ef4("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
          navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
      };
      if (!(browserDetails.version > 55 && "autoGainControl" in navigator.mediaDevices.getSupportedConstraints())) {
          const remap = function(obj, a, b) {
              if (a in obj && !(b in obj)) {
                  obj[b] = obj[a];
                  delete obj[a];
              }
          };
          const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function(c) {
              if (typeof c === "object" && typeof c.audio === "object") {
                  c = JSON.parse(JSON.stringify(c));
                  remap(c.audio, "autoGainControl", "mozAutoGainControl");
                  remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
              }
              return nativeGetUserMedia(c);
          };
          if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
              const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
              MediaStreamTrack.prototype.getSettings = function() {
                  const obj = nativeGetSettings.apply(this, arguments);
                  remap(obj, "mozAutoGainControl", "autoGainControl");
                  remap(obj, "mozNoiseSuppression", "noiseSuppression");
                  return obj;
              };
          }
          if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
              const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
              MediaStreamTrack.prototype.applyConstraints = function(c) {
                  if (this.kind === "audio" && typeof c === "object") {
                      c = JSON.parse(JSON.stringify(c));
                      remap(c, "autoGainControl", "mozAutoGainControl");
                      remap(c, "noiseSuppression", "mozNoiseSuppression");
                  }
                  return nativeApplyConstraints.apply(this, [
                      c
                  ]);
              };
          }
      }
  }
  
  
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ "use strict";
  function $d08a6680f3298ef0$export$97270b87351d9c04(window, preferredMediaSource) {
      if (window.navigator.mediaDevices && "getDisplayMedia" in window.navigator.mediaDevices) return;
      if (!window.navigator.mediaDevices) return;
      window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          if (!(constraints && constraints.video)) {
              const err = new DOMException("getDisplayMedia without video constraints is undefined");
              err.name = "NotFoundError";
              // from https://heycam.github.io/webidl/#idl-DOMException-error-names
              err.code = 8;
              return Promise.reject(err);
          }
          if (constraints.video === true) constraints.video = {
              mediaSource: preferredMediaSource
          };
          else constraints.video.mediaSource = preferredMediaSource;
          return window.navigator.mediaDevices.getUserMedia(constraints);
      };
  }
  
  
  "use strict";
  function $5ba25c21eb1c0af8$export$f358708f68ab068(window) {
      if (typeof window === "object" && window.RTCTrackEvent && "receiver" in window.RTCTrackEvent.prototype && !("transceiver" in window.RTCTrackEvent.prototype)) Object.defineProperty(window.RTCTrackEvent.prototype, "transceiver", {
          get () {
              return {
                  receiver: this.receiver
              };
          }
      });
  }
  function $5ba25c21eb1c0af8$export$852a08dda9a55ea7(window, browserDetails) {
      if (typeof window !== "object" || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) return; // probably media.peerconnection.enabled=false in about:config
      if (!window.RTCPeerConnection && window.mozRTCPeerConnection) // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
      if (browserDetails.version < 53) // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
      [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate"
      ].forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {
              [method] () {
                  arguments[0] = new (method === "addIceCandidate" ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                  return nativeMethod.apply(this, arguments);
              }
          };
          window.RTCPeerConnection.prototype[method] = methodObj[method];
      });
      const modernStatsTypes = {
          inboundrtp: "inbound-rtp",
          outboundrtp: "outbound-rtp",
          candidatepair: "candidate-pair",
          localcandidate: "local-candidate",
          remotecandidate: "remote-candidate"
      };
      const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
      window.RTCPeerConnection.prototype.getStats = function getStats() {
          const [selector, onSucc, onErr] = arguments;
          return nativeGetStats.apply(this, [
              selector || null
          ]).then((stats)=>{
              if (browserDetails.version < 53 && !onSucc) // Shim only promise getStats with spec-hyphens in type names
              // Leave callback version alone; misc old uses of forEach before Map
              try {
                  stats.forEach((stat)=>{
                      stat.type = modernStatsTypes[stat.type] || stat.type;
                  });
              } catch (e) {
                  if (e.name !== "TypeError") throw e;
                  // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                  stats.forEach((stat, i)=>{
                      stats.set(i, Object.assign({}, stat, {
                          type: modernStatsTypes[stat.type] || stat.type
                      }));
                  });
              }
              return stats;
          }).then(onSucc, onErr);
      };
  }
  function $5ba25c21eb1c0af8$export$f0525502095c04ef(window) {
      if (!(typeof window === "object" && window.RTCPeerConnection && window.RTCRtpSender)) return;
      if (window.RTCRtpSender && "getStats" in window.RTCRtpSender.prototype) return;
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender)=>sender._pc = this);
          return senders;
      };
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) window.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
      };
      window.RTCRtpSender.prototype.getStats = function getStats() {
          return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
      };
  }
  function $5ba25c21eb1c0af8$export$83d69126527b1171(window) {
      if (!(typeof window === "object" && window.RTCPeerConnection && window.RTCRtpSender)) return;
      if (window.RTCRtpSender && "getStats" in window.RTCRtpReceiver.prototype) return;
      const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver)=>receiver._pc = this);
          return receivers;
      };
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "track", (e)=>{
          e.receiver._pc = e.srcElement;
          return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function getStats() {
          return this._pc.getStats(this.track);
      };
  }
  function $5ba25c21eb1c0af8$export$825e523ef749bd8c(window) {
      if (!window.RTCPeerConnection || "removeStream" in window.RTCPeerConnection.prototype) return;
      window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          $11d9b3e4fc7791e1$export$cdd73fc4100a6ef4("removeStream", "removeTrack");
          this.getSenders().forEach((sender)=>{
              if (sender.track && stream.getTracks().includes(sender.track)) this.removeTrack(sender);
          });
      };
  }
  function $5ba25c21eb1c0af8$export$ff9cb3bc8990e8f7(window) {
      // rename DataChannel to RTCDataChannel (native fix in FF60):
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
      if (window.DataChannel && !window.RTCDataChannel) window.RTCDataChannel = window.DataChannel;
  }
  function $5ba25c21eb1c0af8$export$70c77533b6e9908d(window) {
      // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
      // Firefox ignores the init sendEncodings options passed to addTransceiver
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
      if (!(typeof window === "object" && window.RTCPeerConnection)) return;
      const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
      if (origAddTransceiver) window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
          this.setParametersPromises = [];
          // WebIDL input coercion and validation
          let sendEncodings = arguments[1] && arguments[1].sendEncodings;
          if (sendEncodings === undefined) sendEncodings = [];
          sendEncodings = [
              ...sendEncodings
          ];
          const shouldPerformCheck = sendEncodings.length > 0;
          if (shouldPerformCheck) // If sendEncodings params are provided, validate grammar
          sendEncodings.forEach((encodingParam)=>{
              if ("rid" in encodingParam) {
                  const ridRegex = /^[a-z0-9]{0,16}$/i;
                  if (!ridRegex.test(encodingParam.rid)) throw new TypeError("Invalid RID value provided.");
              }
              if ("scaleResolutionDownBy" in encodingParam) {
                  if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
              }
              if ("maxFramerate" in encodingParam) {
                  if (!(parseFloat(encodingParam.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
              }
          });
          const transceiver = origAddTransceiver.apply(this, arguments);
          if (shouldPerformCheck) {
              // Check if the init options were applied. If not we do this in an
              // asynchronous way and save the promise reference in a global object.
              // This is an ugly hack, but at the same time is way more robust than
              // checking the sender parameters before and after the createOffer
              // Also note that after the createoffer we are not 100% sure that
              // the params were asynchronously applied so we might miss the
              // opportunity to recreate offer.
              const { sender: sender } = transceiver;
              const params = sender.getParameters();
              if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
              params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
                  params.encodings = sendEncodings;
                  sender.sendEncodings = sendEncodings;
                  this.setParametersPromises.push(sender.setParameters(params).then(()=>{
                      delete sender.sendEncodings;
                  }).catch(()=>{
                      delete sender.sendEncodings;
                  }));
              }
          }
          return transceiver;
      };
  }
  function $5ba25c21eb1c0af8$export$66238223c298fbaa(window) {
      if (!(typeof window === "object" && window.RTCRtpSender)) return;
      const origGetParameters = window.RTCRtpSender.prototype.getParameters;
      if (origGetParameters) window.RTCRtpSender.prototype.getParameters = function getParameters() {
          const params = origGetParameters.apply(this, arguments);
          if (!("encodings" in params)) params.encodings = [].concat(this.sendEncodings || [
              {}
          ]);
          return params;
      };
  }
  function $5ba25c21eb1c0af8$export$51beccf0e777b843(window) {
      // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
      // Firefox ignores the init sendEncodings options passed to addTransceiver
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
      if (!(typeof window === "object" && window.RTCPeerConnection)) return;
      const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
      window.RTCPeerConnection.prototype.createOffer = function createOffer() {
          if (this.setParametersPromises && this.setParametersPromises.length) return Promise.all(this.setParametersPromises).then(()=>{
              return origCreateOffer.apply(this, arguments);
          }).finally(()=>{
              this.setParametersPromises = [];
          });
          return origCreateOffer.apply(this, arguments);
      };
  }
  function $5ba25c21eb1c0af8$export$df0b46e7cef08150(window) {
      // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
      // Firefox ignores the init sendEncodings options passed to addTransceiver
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
      if (!(typeof window === "object" && window.RTCPeerConnection)) return;
      const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
      window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
          if (this.setParametersPromises && this.setParametersPromises.length) return Promise.all(this.setParametersPromises).then(()=>{
              return origCreateAnswer.apply(this, arguments);
          }).finally(()=>{
              this.setParametersPromises = [];
          });
          return origCreateAnswer.apply(this, arguments);
      };
  }
  
  
  var $93a503258ac80079$exports = {};
  
  $parcel$export($93a503258ac80079$exports, "shimLocalStreamsAPI", () => $93a503258ac80079$export$8df41282f4fdcea2);
  $parcel$export($93a503258ac80079$exports, "shimRemoteStreamsAPI", () => $93a503258ac80079$export$762aa4cbb4f2f857);
  $parcel$export($93a503258ac80079$exports, "shimCallbacksAPI", () => $93a503258ac80079$export$da31df245debdd3);
  $parcel$export($93a503258ac80079$exports, "shimGetUserMedia", () => $93a503258ac80079$export$1ed4910f4d37dc5e);
  $parcel$export($93a503258ac80079$exports, "shimConstraints", () => $93a503258ac80079$export$494a01ac68ba81ac);
  $parcel$export($93a503258ac80079$exports, "shimRTCIceServerUrls", () => $93a503258ac80079$export$671a8b47b41b6f41);
  $parcel$export($93a503258ac80079$exports, "shimTrackEventTransceiver", () => $93a503258ac80079$export$85d53da088cb1b14);
  $parcel$export($93a503258ac80079$exports, "shimCreateOfferLegacy", () => $93a503258ac80079$export$d444266503fdd2d4);
  $parcel$export($93a503258ac80079$exports, "shimAudioContext", () => $93a503258ac80079$export$857cd739a7b795d2);
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ 
  "use strict";
  function $93a503258ac80079$export$8df41282f4fdcea2(window) {
      if (typeof window !== "object" || !window.RTCPeerConnection) return;
      if (!("getLocalStreams" in window.RTCPeerConnection.prototype)) window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          if (!this._localStreams) this._localStreams = [];
          return this._localStreams;
      };
      if (!("addStream" in window.RTCPeerConnection.prototype)) {
          const _addTrack = window.RTCPeerConnection.prototype.addTrack;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              if (!this._localStreams) this._localStreams = [];
              if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
              // Try to emulate Chrome's behaviour of adding in audio-video order.
              // Safari orders by track id.
              stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));
              stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));
          };
          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
              if (streams) streams.forEach((stream)=>{
                  if (!this._localStreams) this._localStreams = [
                      stream
                  ];
                  else if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
              });
              return _addTrack.apply(this, arguments);
          };
      }
      if (!("removeStream" in window.RTCPeerConnection.prototype)) window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          if (!this._localStreams) this._localStreams = [];
          const index = this._localStreams.indexOf(stream);
          if (index === -1) return;
          this._localStreams.splice(index, 1);
          const tracks = stream.getTracks();
          this.getSenders().forEach((sender)=>{
              if (tracks.includes(sender.track)) this.removeTrack(sender);
          });
      };
  }
  function $93a503258ac80079$export$762aa4cbb4f2f857(window) {
      if (typeof window !== "object" || !window.RTCPeerConnection) return;
      if (!("getRemoteStreams" in window.RTCPeerConnection.prototype)) window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
          return this._remoteStreams ? this._remoteStreams : [];
      };
      if (!("onaddstream" in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, "onaddstream", {
              get () {
                  return this._onaddstream;
              },
              set (f) {
                  if (this._onaddstream) {
                      this.removeEventListener("addstream", this._onaddstream);
                      this.removeEventListener("track", this._onaddstreampoly);
                  }
                  this.addEventListener("addstream", this._onaddstream = f);
                  this.addEventListener("track", this._onaddstreampoly = (e)=>{
                      e.streams.forEach((stream)=>{
                          if (!this._remoteStreams) this._remoteStreams = [];
                          if (this._remoteStreams.includes(stream)) return;
                          this._remoteStreams.push(stream);
                          const event = new Event("addstream");
                          event.stream = stream;
                          this.dispatchEvent(event);
                      });
                  });
              }
          });
          const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              const pc = this;
              if (!this._onaddstreampoly) this.addEventListener("track", this._onaddstreampoly = function(e) {
                  e.streams.forEach((stream)=>{
                      if (!pc._remoteStreams) pc._remoteStreams = [];
                      if (pc._remoteStreams.indexOf(stream) >= 0) return;
                      pc._remoteStreams.push(stream);
                      const event = new Event("addstream");
                      event.stream = stream;
                      pc.dispatchEvent(event);
                  });
              });
              return origSetRemoteDescription.apply(pc, arguments);
          };
      }
  }
  function $93a503258ac80079$export$da31df245debdd3(window) {
      if (typeof window !== "object" || !window.RTCPeerConnection) return;
      const prototype = window.RTCPeerConnection.prototype;
      const origCreateOffer = prototype.createOffer;
      const origCreateAnswer = prototype.createAnswer;
      const setLocalDescription = prototype.setLocalDescription;
      const setRemoteDescription = prototype.setRemoteDescription;
      const addIceCandidate = prototype.addIceCandidate;
      prototype.createOffer = function createOffer(successCallback, failureCallback) {
          const options = arguments.length >= 2 ? arguments[2] : arguments[0];
          const promise = origCreateOffer.apply(this, [
              options
          ]);
          if (!failureCallback) return promise;
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
      };
      prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
          const options = arguments.length >= 2 ? arguments[2] : arguments[0];
          const promise = origCreateAnswer.apply(this, [
              options
          ]);
          if (!failureCallback) return promise;
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
      };
      let withCallback = function(description, successCallback, failureCallback) {
          const promise = setLocalDescription.apply(this, [
              description
          ]);
          if (!failureCallback) return promise;
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
      };
      prototype.setLocalDescription = withCallback;
      withCallback = function(description, successCallback, failureCallback) {
          const promise = setRemoteDescription.apply(this, [
              description
          ]);
          if (!failureCallback) return promise;
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
      };
      prototype.setRemoteDescription = withCallback;
      withCallback = function(candidate, successCallback, failureCallback) {
          const promise = addIceCandidate.apply(this, [
              candidate
          ]);
          if (!failureCallback) return promise;
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
      };
      prototype.addIceCandidate = withCallback;
  }
  function $93a503258ac80079$export$1ed4910f4d37dc5e(window) {
      const navigator = window && window.navigator;
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          // shim not needed in Safari 12.1
          const mediaDevices = navigator.mediaDevices;
          const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
          navigator.mediaDevices.getUserMedia = (constraints)=>{
              return _getUserMedia($93a503258ac80079$export$494a01ac68ba81ac(constraints));
          };
      }
      if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) navigator.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }).bind(navigator);
  }
  function $93a503258ac80079$export$494a01ac68ba81ac(constraints) {
      if (constraints && constraints.video !== undefined) return Object.assign({}, constraints, {
          video: $11d9b3e4fc7791e1$export$15384eac40dc88c8(constraints.video)
      });
      return constraints;
  }
  function $93a503258ac80079$export$671a8b47b41b6f41(window) {
      if (!window.RTCPeerConnection) return;
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      const OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
          if (pcConfig && pcConfig.iceServers) {
              const newIceServers = [];
              for(let i = 0; i < pcConfig.iceServers.length; i++){
                  let server = pcConfig.iceServers[i];
                  if (server.urls === undefined && server.url) {
                      $11d9b3e4fc7791e1$export$cdd73fc4100a6ef4("RTCIceServer.url", "RTCIceServer.urls");
                      server = JSON.parse(JSON.stringify(server));
                      server.urls = server.url;
                      delete server.url;
                      newIceServers.push(server);
                  } else newIceServers.push(pcConfig.iceServers[i]);
              }
              pcConfig.iceServers = newIceServers;
          }
          return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if ("generateCertificate" in OrigPeerConnection) Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
          get () {
              return OrigPeerConnection.generateCertificate;
          }
      });
  }
  function $93a503258ac80079$export$85d53da088cb1b14(window) {
      // Add event.transceiver member over deprecated event.receiver
      if (typeof window === "object" && window.RTCTrackEvent && "receiver" in window.RTCTrackEvent.prototype && !("transceiver" in window.RTCTrackEvent.prototype)) Object.defineProperty(window.RTCTrackEvent.prototype, "transceiver", {
          get () {
              return {
                  receiver: this.receiver
              };
          }
      });
  }
  function $93a503258ac80079$export$d444266503fdd2d4(window) {
      const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
      window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
          if (offerOptions) {
              if (typeof offerOptions.offerToReceiveAudio !== "undefined") // support bit values
              offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
              const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === "audio");
              if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                  if (audioTransceiver.direction === "sendrecv") {
                      if (audioTransceiver.setDirection) audioTransceiver.setDirection("sendonly");
                      else audioTransceiver.direction = "sendonly";
                  } else if (audioTransceiver.direction === "recvonly") {
                      if (audioTransceiver.setDirection) audioTransceiver.setDirection("inactive");
                      else audioTransceiver.direction = "inactive";
                  }
              } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) this.addTransceiver("audio", {
                  direction: "recvonly"
              });
              if (typeof offerOptions.offerToReceiveVideo !== "undefined") // support bit values
              offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
              const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === "video");
              if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                  if (videoTransceiver.direction === "sendrecv") {
                      if (videoTransceiver.setDirection) videoTransceiver.setDirection("sendonly");
                      else videoTransceiver.direction = "sendonly";
                  } else if (videoTransceiver.direction === "recvonly") {
                      if (videoTransceiver.setDirection) videoTransceiver.setDirection("inactive");
                      else videoTransceiver.direction = "inactive";
                  }
              } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) this.addTransceiver("video", {
                  direction: "recvonly"
              });
          }
          return origCreateOffer.apply(this, arguments);
      };
  }
  function $93a503258ac80079$export$857cd739a7b795d2(window) {
      if (typeof window !== "object" || window.AudioContext) return;
      window.AudioContext = window.webkitAudioContext;
  }
  
  
  var $f8e30544afcd11f0$exports = {};
  
  $parcel$export($f8e30544afcd11f0$exports, "shimRTCIceCandidate", () => $f8e30544afcd11f0$export$cf133661e444ccfe);
  $parcel$export($f8e30544afcd11f0$exports, "shimRTCIceCandidateRelayProtocol", () => $f8e30544afcd11f0$export$fdafb8d8280e29b5);
  $parcel$export($f8e30544afcd11f0$exports, "shimMaxMessageSize", () => $f8e30544afcd11f0$export$a99147c78a56edc4);
  $parcel$export($f8e30544afcd11f0$exports, "shimSendThrowTypeError", () => $f8e30544afcd11f0$export$d461c8d5c5db5da7);
  $parcel$export($f8e30544afcd11f0$exports, "shimConnectionState", () => $f8e30544afcd11f0$export$63bb816cc75460);
  $parcel$export($f8e30544afcd11f0$exports, "removeExtmapAllowMixed", () => $f8e30544afcd11f0$export$a57d114344295149);
  $parcel$export($f8e30544afcd11f0$exports, "shimAddIceCandidateNullOrEmpty", () => $f8e30544afcd11f0$export$51d5e40b48c771c7);
  $parcel$export($f8e30544afcd11f0$exports, "shimParameterlessSetLocalDescription", () => $f8e30544afcd11f0$export$7170d04e59f9d553);
  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */ /* eslint-env node */ var $30b3171bddcf6271$exports = {};
  /* eslint-env node */ "use strict";
  // SDP helpers.
  const $30b3171bddcf6271$var$SDPUtils = {};
  // Generate an alphanumeric identifier for cname or mids.
  // TODO: use UUIDs instead? https://gist.github.com/jed/982883
  $30b3171bddcf6271$var$SDPUtils.generateIdentifier = function() {
      return Math.random().toString(36).substring(2, 12);
  };
  // The RTCP CNAME used by all peerconnections from the same JS.
  $30b3171bddcf6271$var$SDPUtils.localCName = $30b3171bddcf6271$var$SDPUtils.generateIdentifier();
  // Splits SDP into lines, dealing with both CRLF and LF.
  $30b3171bddcf6271$var$SDPUtils.splitLines = function(blob) {
      return blob.trim().split("\n").map((line)=>line.trim());
  };
  // Splits SDP into sessionpart and mediasections. Ensures CRLF.
  $30b3171bddcf6271$var$SDPUtils.splitSections = function(blob) {
      const parts = blob.split("\nm=");
      return parts.map((part, index)=>(index > 0 ? "m=" + part : part).trim() + "\r\n");
  };
  // Returns the session description.
  $30b3171bddcf6271$var$SDPUtils.getDescription = function(blob) {
      const sections = $30b3171bddcf6271$var$SDPUtils.splitSections(blob);
      return sections && sections[0];
  };
  // Returns the individual media sections.
  $30b3171bddcf6271$var$SDPUtils.getMediaSections = function(blob) {
      const sections = $30b3171bddcf6271$var$SDPUtils.splitSections(blob);
      sections.shift();
      return sections;
  };
  // Returns lines that start with a certain prefix.
  $30b3171bddcf6271$var$SDPUtils.matchPrefix = function(blob, prefix) {
      return $30b3171bddcf6271$var$SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);
  };
  // Parses an ICE candidate line. Sample input:
  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
  // rport 55996"
  // Input can be prefixed with a=.
  $30b3171bddcf6271$var$SDPUtils.parseCandidate = function(line) {
      let parts;
      // Parse both variants.
      if (line.indexOf("a=candidate:") === 0) parts = line.substring(12).split(" ");
      else parts = line.substring(10).split(" ");
      const candidate = {
          foundation: parts[0],
          component: {
              1: "rtp",
              2: "rtcp"
          }[parts[1]] || parts[1],
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
      };
      for(let i = 8; i < parts.length; i += 2)switch(parts[i]){
          case "raddr":
              candidate.relatedAddress = parts[i + 1];
              break;
          case "rport":
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
          case "tcptype":
              candidate.tcpType = parts[i + 1];
              break;
          case "ufrag":
              candidate.ufrag = parts[i + 1]; // for backward compatibility.
              candidate.usernameFragment = parts[i + 1];
              break;
          default:
              if (candidate[parts[i]] === undefined) candidate[parts[i]] = parts[i + 1];
              break;
      }
      return candidate;
  };
  // Translates a candidate object into SDP candidate attribute.
  // This does not include the a= prefix!
  $30b3171bddcf6271$var$SDPUtils.writeCandidate = function(candidate) {
      const sdp = [];
      sdp.push(candidate.foundation);
      const component = candidate.component;
      if (component === "rtp") sdp.push(1);
      else if (component === "rtcp") sdp.push(2);
      else sdp.push(component);
      sdp.push(candidate.protocol.toUpperCase());
      sdp.push(candidate.priority);
      sdp.push(candidate.address || candidate.ip);
      sdp.push(candidate.port);
      const type = candidate.type;
      sdp.push("typ");
      sdp.push(type);
      if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
          sdp.push("raddr");
          sdp.push(candidate.relatedAddress);
          sdp.push("rport");
          sdp.push(candidate.relatedPort);
      }
      if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
          sdp.push("tcptype");
          sdp.push(candidate.tcpType);
      }
      if (candidate.usernameFragment || candidate.ufrag) {
          sdp.push("ufrag");
          sdp.push(candidate.usernameFragment || candidate.ufrag);
      }
      return "candidate:" + sdp.join(" ");
  };
  // Parses an ice-options line, returns an array of option tags.
  // Sample input:
  // a=ice-options:foo bar
  $30b3171bddcf6271$var$SDPUtils.parseIceOptions = function(line) {
      return line.substring(14).split(" ");
  };
  // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
  // a=rtpmap:111 opus/48000/2
  $30b3171bddcf6271$var$SDPUtils.parseRtpMap = function(line) {
      let parts = line.substring(9).split(" ");
      const parsed = {
          payloadType: parseInt(parts.shift(), 10)
      };
      parts = parts[0].split("/");
      parsed.name = parts[0];
      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
      // legacy alias, got renamed back to channels in ORTC.
      parsed.numChannels = parsed.channels;
      return parsed;
  };
  // Generates a rtpmap line from RTCRtpCodecCapability or
  // RTCRtpCodecParameters.
  $30b3171bddcf6271$var$SDPUtils.writeRtpMap = function(codec) {
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== undefined) pt = codec.preferredPayloadType;
      const channels = codec.channels || codec.numChannels || 1;
      return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
  };
  // Parses a extmap line (headerextension from RFC 5285). Sample input:
  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
  $30b3171bddcf6271$var$SDPUtils.parseExtmap = function(line) {
      const parts = line.substring(9).split(" ");
      return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
          uri: parts[1],
          attributes: parts.slice(2).join(" ")
      };
  };
  // Generates an extmap line from RTCRtpHeaderExtensionParameters or
  // RTCRtpHeaderExtension.
  $30b3171bddcf6271$var$SDPUtils.writeExtmap = function(headerExtension) {
      return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
  };
  // Parses a fmtp line, returns dictionary. Sample input:
  // a=fmtp:96 vbr=on;cng=on
  // Also deals with vbr=on; cng=on
  $30b3171bddcf6271$var$SDPUtils.parseFmtp = function(line) {
      const parsed = {};
      let kv;
      const parts = line.substring(line.indexOf(" ") + 1).split(";");
      for(let j = 0; j < parts.length; j++){
          kv = parts[j].trim().split("=");
          parsed[kv[0].trim()] = kv[1];
      }
      return parsed;
  };
  // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
  $30b3171bddcf6271$var$SDPUtils.writeFmtp = function(codec) {
      let line = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== undefined) pt = codec.preferredPayloadType;
      if (codec.parameters && Object.keys(codec.parameters).length) {
          const params = [];
          Object.keys(codec.parameters).forEach((param)=>{
              if (codec.parameters[param] !== undefined) params.push(param + "=" + codec.parameters[param]);
              else params.push(param);
          });
          line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
      }
      return line;
  };
  // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
  // a=rtcp-fb:98 nack rpsi
  $30b3171bddcf6271$var$SDPUtils.parseRtcpFb = function(line) {
      const parts = line.substring(line.indexOf(" ") + 1).split(" ");
      return {
          type: parts.shift(),
          parameter: parts.join(" ")
      };
  };
  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
  $30b3171bddcf6271$var$SDPUtils.writeRtcpFb = function(codec) {
      let lines = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== undefined) pt = codec.preferredPayloadType;
      if (codec.rtcpFeedback && codec.rtcpFeedback.length) // FIXME: special handling for trr-int?
      codec.rtcpFeedback.forEach((fb)=>{
          lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
      });
      return lines;
  };
  // Parses a RFC 5576 ssrc media attribute. Sample input:
  // a=ssrc:3735928559 cname:something
  $30b3171bddcf6271$var$SDPUtils.parseSsrcMedia = function(line) {
      const sp = line.indexOf(" ");
      const parts = {
          ssrc: parseInt(line.substring(7, sp), 10)
      };
      const colon = line.indexOf(":", sp);
      if (colon > -1) {
          parts.attribute = line.substring(sp + 1, colon);
          parts.value = line.substring(colon + 1);
      } else parts.attribute = line.substring(sp + 1);
      return parts;
  };
  // Parse a ssrc-group line (see RFC 5576). Sample input:
  // a=ssrc-group:semantics 12 34
  $30b3171bddcf6271$var$SDPUtils.parseSsrcGroup = function(line) {
      const parts = line.substring(13).split(" ");
      return {
          semantics: parts.shift(),
          ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))
      };
  };
  // Extracts the MID (RFC 5888) from a media section.
  // Returns the MID or undefined if no mid line was found.
  $30b3171bddcf6271$var$SDPUtils.getMid = function(mediaSection) {
      const mid = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=mid:")[0];
      if (mid) return mid.substring(6);
  };
  // Parses a fingerprint line for DTLS-SRTP.
  $30b3171bddcf6271$var$SDPUtils.parseFingerprint = function(line) {
      const parts = line.substring(14).split(" ");
      return {
          algorithm: parts[0].toLowerCase(),
          value: parts[1].toUpperCase()
      };
  };
  // Extracts DTLS parameters from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the fingerprint line as input. See also getIceParameters.
  $30b3171bddcf6271$var$SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
      const lines = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
      // Note: a=setup line is ignored since we use the 'auto' role in Edge.
      return {
          role: "auto",
          fingerprints: lines.map($30b3171bddcf6271$var$SDPUtils.parseFingerprint)
      };
  };
  // Serializes DTLS parameters to SDP.
  $30b3171bddcf6271$var$SDPUtils.writeDtlsParameters = function(params, setupType) {
      let sdp = "a=setup:" + setupType + "\r\n";
      params.fingerprints.forEach((fp)=>{
          sdp += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
      });
      return sdp;
  };
  // Parses a=crypto lines into
  //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
  $30b3171bddcf6271$var$SDPUtils.parseCryptoLine = function(line) {
      const parts = line.substring(9).split(" ");
      return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
      };
  };
  $30b3171bddcf6271$var$SDPUtils.writeCryptoLine = function(parameters) {
      return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? $30b3171bddcf6271$var$SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
  };
  // Parses the crypto key parameters into
  //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
  $30b3171bddcf6271$var$SDPUtils.parseCryptoKeyParams = function(keyParams) {
      if (keyParams.indexOf("inline:") !== 0) return null;
      const parts = keyParams.substring(7).split("|");
      return {
          keyMethod: "inline",
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(":")[0] : undefined,
          mkiLength: parts[2] ? parts[2].split(":")[1] : undefined
      };
  };
  $30b3171bddcf6271$var$SDPUtils.writeCryptoKeyParams = function(keyParams) {
      return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
  };
  // Extracts all SDES parameters.
  $30b3171bddcf6271$var$SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
      const lines = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection + sessionpart, "a=crypto:");
      return lines.map($30b3171bddcf6271$var$SDPUtils.parseCryptoLine);
  };
  // Parses ICE information from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the ice-ufrag and ice-pwd lines as input.
  $30b3171bddcf6271$var$SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
      const ufrag = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
      const pwd = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
      if (!(ufrag && pwd)) return null;
      return {
          usernameFragment: ufrag.substring(12),
          password: pwd.substring(10)
      };
  };
  // Serializes ICE parameters to SDP.
  $30b3171bddcf6271$var$SDPUtils.writeIceParameters = function(params) {
      let sdp = "a=ice-ufrag:" + params.usernameFragment + "\r\n" + "a=ice-pwd:" + params.password + "\r\n";
      if (params.iceLite) sdp += "a=ice-lite\r\n";
      return sdp;
  };
  // Parses the SDP media section and returns RTCRtpParameters.
  $30b3171bddcf6271$var$SDPUtils.parseRtpParameters = function(mediaSection) {
      const description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
      };
      const lines = $30b3171bddcf6271$var$SDPUtils.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      description.profile = mline[2];
      for(let i = 3; i < mline.length; i++){
          const pt = mline[i];
          const rtpmapline = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
          if (rtpmapline) {
              const codec = $30b3171bddcf6271$var$SDPUtils.parseRtpMap(rtpmapline);
              const fmtps = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
              // Only the first a=fmtp:<pt> is considered.
              codec.parameters = fmtps.length ? $30b3171bddcf6271$var$SDPUtils.parseFmtp(fmtps[0]) : {};
              codec.rtcpFeedback = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map($30b3171bddcf6271$var$SDPUtils.parseRtcpFb);
              description.codecs.push(codec);
              // parse FEC mechanisms from rtpmap lines.
              switch(codec.name.toUpperCase()){
                  case "RED":
                  case "ULPFEC":
                      description.fecMechanisms.push(codec.name.toUpperCase());
                      break;
                  default:
                      break;
              }
          }
      }
      $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=extmap:").forEach((line)=>{
          description.headerExtensions.push($30b3171bddcf6271$var$SDPUtils.parseExtmap(line));
      });
      const wildcardRtcpFb = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=rtcp-fb:* ").map($30b3171bddcf6271$var$SDPUtils.parseRtcpFb);
      description.codecs.forEach((codec)=>{
          wildcardRtcpFb.forEach((fb)=>{
              const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{
                  return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
              });
              if (!duplicate) codec.rtcpFeedback.push(fb);
          });
      });
      // FIXME: parse rtcp.
      return description;
  };
  // Generates parts of the SDP media section describing the capabilities /
  // parameters.
  $30b3171bddcf6271$var$SDPUtils.writeRtpDescription = function(kind, caps) {
      let sdp = "";
      // Build the mline.
      sdp += "m=" + kind + " ";
      sdp += caps.codecs.length > 0 ? "9" : "0"; // reject if no codecs.
      sdp += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
      sdp += caps.codecs.map((codec)=>{
          if (codec.preferredPayloadType !== undefined) return codec.preferredPayloadType;
          return codec.payloadType;
      }).join(" ") + "\r\n";
      sdp += "c=IN IP4 0.0.0.0\r\n";
      sdp += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
      caps.codecs.forEach((codec)=>{
          sdp += $30b3171bddcf6271$var$SDPUtils.writeRtpMap(codec);
          sdp += $30b3171bddcf6271$var$SDPUtils.writeFmtp(codec);
          sdp += $30b3171bddcf6271$var$SDPUtils.writeRtcpFb(codec);
      });
      let maxptime = 0;
      caps.codecs.forEach((codec)=>{
          if (codec.maxptime > maxptime) maxptime = codec.maxptime;
      });
      if (maxptime > 0) sdp += "a=maxptime:" + maxptime + "\r\n";
      if (caps.headerExtensions) caps.headerExtensions.forEach((extension)=>{
          sdp += $30b3171bddcf6271$var$SDPUtils.writeExtmap(extension);
      });
      // FIXME: write fecMechanisms.
      return sdp;
  };
  // Parses the SDP media section and returns an array of
  // RTCRtpEncodingParameters.
  $30b3171bddcf6271$var$SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
      const encodingParameters = [];
      const description = $30b3171bddcf6271$var$SDPUtils.parseRtpParameters(mediaSection);
      const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
      const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
      // filter a=ssrc:... cname:, ignore PlanB-msid
      const ssrcs = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>$30b3171bddcf6271$var$SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === "cname");
      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
      let secondarySsrc;
      const flows = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line)=>{
          const parts = line.substring(17).split(" ");
          return parts.map((part)=>parseInt(part, 10));
      });
      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) secondarySsrc = flows[0][1];
      description.codecs.forEach((codec)=>{
          if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
              let encParam = {
                  ssrc: primarySsrc,
                  codecPayloadType: parseInt(codec.parameters.apt, 10)
              };
              if (primarySsrc && secondarySsrc) encParam.rtx = {
                  ssrc: secondarySsrc
              };
              encodingParameters.push(encParam);
              if (hasRed) {
                  encParam = JSON.parse(JSON.stringify(encParam));
                  encParam.fec = {
                      ssrc: primarySsrc,
                      mechanism: hasUlpfec ? "red+ulpfec" : "red"
                  };
                  encodingParameters.push(encParam);
              }
          }
      });
      if (encodingParameters.length === 0 && primarySsrc) encodingParameters.push({
          ssrc: primarySsrc
      });
      // we support both b=AS and b=TIAS but interpret AS as TIAS.
      let bandwidth = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "b=");
      if (bandwidth.length) {
          if (bandwidth[0].indexOf("b=TIAS:") === 0) bandwidth = parseInt(bandwidth[0].substring(7), 10);
          else if (bandwidth[0].indexOf("b=AS:") === 0) // use formula from JSEP to convert b=AS to TIAS value.
          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 950 - 16000;
          else bandwidth = undefined;
          encodingParameters.forEach((params)=>{
              params.maxBitrate = bandwidth;
          });
      }
      return encodingParameters;
  };
  // parses http://draft.ortc.org/#rtcrtcpparameters*
  $30b3171bddcf6271$var$SDPUtils.parseRtcpParameters = function(mediaSection) {
      const rtcpParameters = {};
      // Gets the first SSRC. Note that with RTX there might be multiple
      // SSRCs.
      const remoteSsrc = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>$30b3171bddcf6271$var$SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === "cname")[0];
      if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
      }
      // Edge uses the compound attribute instead of reducedSize
      // compound is !reducedSize
      const rsize = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=rtcp-rsize");
      rtcpParameters.reducedSize = rsize.length > 0;
      rtcpParameters.compound = rsize.length === 0;
      // parses the rtcp-mux attrbute.
      // Note that Edge does not support unmuxed RTCP.
      const mux = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=rtcp-mux");
      rtcpParameters.mux = mux.length > 0;
      return rtcpParameters;
  };
  $30b3171bddcf6271$var$SDPUtils.writeRtcpParameters = function(rtcpParameters) {
      let sdp = "";
      if (rtcpParameters.reducedSize) sdp += "a=rtcp-rsize\r\n";
      if (rtcpParameters.mux) sdp += "a=rtcp-mux\r\n";
      if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) sdp += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
      return sdp;
  };
  // parses either a=msid: or a=ssrc:... msid lines and returns
  // the id of the MediaStream and MediaStreamTrack.
  $30b3171bddcf6271$var$SDPUtils.parseMsid = function(mediaSection) {
      let parts;
      const spec = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=msid:");
      if (spec.length === 1) {
          parts = spec[0].substring(7).split(" ");
          return {
              stream: parts[0],
              track: parts[1]
          };
      }
      const planB = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=ssrc:").map((line)=>$30b3171bddcf6271$var$SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === "msid");
      if (planB.length > 0) {
          parts = planB[0].value.split(" ");
          return {
              stream: parts[0],
              track: parts[1]
          };
      }
  };
  // SCTP
  // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
  // to draft-ietf-mmusic-sctp-sdp-05
  $30b3171bddcf6271$var$SDPUtils.parseSctpDescription = function(mediaSection) {
      const mline = $30b3171bddcf6271$var$SDPUtils.parseMLine(mediaSection);
      const maxSizeLine = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=max-message-size:");
      let maxMessageSize;
      if (maxSizeLine.length > 0) maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
      if (isNaN(maxMessageSize)) maxMessageSize = 65536;
      const sctpPort = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=sctp-port:");
      if (sctpPort.length > 0) return {
          port: parseInt(sctpPort[0].substring(12), 10),
          protocol: mline.fmt,
          maxMessageSize: maxMessageSize
      };
      const sctpMapLines = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "a=sctpmap:");
      if (sctpMapLines.length > 0) {
          const parts = sctpMapLines[0].substring(10).split(" ");
          return {
              port: parseInt(parts[0], 10),
              protocol: parts[1],
              maxMessageSize: maxMessageSize
          };
      }
  };
  // SCTP
  // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
  // support by now receiving in this format, unless we originally parsed
  // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
  // protocol of DTLS/SCTP -- without UDP/ or TCP/)
  $30b3171bddcf6271$var$SDPUtils.writeSctpDescription = function(media, sctp) {
      let output = [];
      if (media.protocol !== "DTLS/SCTP") output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctp-port:" + sctp.port + "\r\n"
      ];
      else output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
      ];
      if (sctp.maxMessageSize !== undefined) output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
      return output.join("");
  };
  // Generate a session ID for SDP.
  // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
  // recommends using a cryptographically random +ve 64-bit value
  // but right now this should be acceptable and within the right range
  $30b3171bddcf6271$var$SDPUtils.generateSessionId = function() {
      return Math.random().toString().substr(2, 22);
  };
  // Write boiler plate for start of SDP
  // sessId argument is optional - if not supplied it will
  // be generated randomly
  // sessVersion is optional and defaults to 2
  // sessUser is optional and defaults to 'thisisadapterortc'
  $30b3171bddcf6271$var$SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
      let sessionId;
      const version = sessVer !== undefined ? sessVer : 2;
      if (sessId) sessionId = sessId;
      else sessionId = $30b3171bddcf6271$var$SDPUtils.generateSessionId();
      const user = sessUser || "thisisadapterortc";
      // FIXME: sess-id should be an NTP timestamp.
      return "v=0\r\no=" + user + " " + sessionId + " " + version + " IN IP4 127.0.0.1\r\n" + "s=-\r\n" + "t=0 0\r\n";
  };
  // Gets the direction from the mediaSection or the sessionpart.
  $30b3171bddcf6271$var$SDPUtils.getDirection = function(mediaSection, sessionpart) {
      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
      const lines = $30b3171bddcf6271$var$SDPUtils.splitLines(mediaSection);
      for(let i = 0; i < lines.length; i++)switch(lines[i]){
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
              return lines[i].substring(2);
          default:
      }
      if (sessionpart) return $30b3171bddcf6271$var$SDPUtils.getDirection(sessionpart);
      return "sendrecv";
  };
  $30b3171bddcf6271$var$SDPUtils.getKind = function(mediaSection) {
      const lines = $30b3171bddcf6271$var$SDPUtils.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      return mline[0].substring(2);
  };
  $30b3171bddcf6271$var$SDPUtils.isRejected = function(mediaSection) {
      return mediaSection.split(" ", 2)[1] === "0";
  };
  $30b3171bddcf6271$var$SDPUtils.parseMLine = function(mediaSection) {
      const lines = $30b3171bddcf6271$var$SDPUtils.splitLines(mediaSection);
      const parts = lines[0].substring(2).split(" ");
      return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(" ")
      };
  };
  $30b3171bddcf6271$var$SDPUtils.parseOLine = function(mediaSection) {
      const line = $30b3171bddcf6271$var$SDPUtils.matchPrefix(mediaSection, "o=")[0];
      const parts = line.substring(2).split(" ");
      return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
      };
  };
  // a very naive interpretation of a valid SDP.
  $30b3171bddcf6271$var$SDPUtils.isValidSDP = function(blob) {
      if (typeof blob !== "string" || blob.length === 0) return false;
      const lines = $30b3171bddcf6271$var$SDPUtils.splitLines(blob);
      for(let i = 0; i < lines.length; i++){
          if (lines[i].length < 2 || lines[i].charAt(1) !== "=") return false;
      // TODO: check the modifier a bit more.
      }
      return true;
  };
  $30b3171bddcf6271$exports = $30b3171bddcf6271$var$SDPUtils;
  
  
  
  "use strict";
  function $f8e30544afcd11f0$export$cf133661e444ccfe(window) {
      // foundation is arbitrarily chosen as an indicator for full support for
      // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
      if (!window.RTCIceCandidate || window.RTCIceCandidate && "foundation" in window.RTCIceCandidate.prototype) return;
      const NativeRTCIceCandidate = window.RTCIceCandidate;
      window.RTCIceCandidate = function RTCIceCandidate(args) {
          // Remove the a= which shouldn't be part of the candidate string.
          if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substring(2);
          }
          if (args.candidate && args.candidate.length) {
              // Augment the native candidate with the parsed fields.
              const nativeCandidate = new NativeRTCIceCandidate(args);
              const parsedCandidate = (0, (/*@__PURE__*/$parcel$interopDefault($30b3171bddcf6271$exports))).parseCandidate(args.candidate);
              for(const key in parsedCandidate)if (!(key in nativeCandidate)) Object.defineProperty(nativeCandidate, key, {
                  value: parsedCandidate[key]
              });
              // Override serializer to not serialize the extra attributes.
              nativeCandidate.toJSON = function toJSON() {
                  return {
                      candidate: nativeCandidate.candidate,
                      sdpMid: nativeCandidate.sdpMid,
                      sdpMLineIndex: nativeCandidate.sdpMLineIndex,
                      usernameFragment: nativeCandidate.usernameFragment
                  };
              };
              return nativeCandidate;
          }
          return new NativeRTCIceCandidate(args);
      };
      window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
      // Hook up the augmented candidate in onicecandidate and
      // addEventListener('icecandidate', ...)
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "icecandidate", (e)=>{
          if (e.candidate) Object.defineProperty(e, "candidate", {
              value: new window.RTCIceCandidate(e.candidate),
              writable: "false"
          });
          return e;
      });
  }
  function $f8e30544afcd11f0$export$fdafb8d8280e29b5(window) {
      if (!window.RTCIceCandidate || window.RTCIceCandidate && "relayProtocol" in window.RTCIceCandidate.prototype) return;
      // Hook up the augmented candidate in onicecandidate and
      // addEventListener('icecandidate', ...)
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "icecandidate", (e)=>{
          if (e.candidate) {
              const parsedCandidate = (0, (/*@__PURE__*/$parcel$interopDefault($30b3171bddcf6271$exports))).parseCandidate(e.candidate.candidate);
              if (parsedCandidate.type === "relay") // This is a libwebrtc-specific mapping of local type preference
              // to relayProtocol.
              e.candidate.relayProtocol = ({
                  0: "tls",
                  1: "tcp",
                  2: "udp"
              })[parsedCandidate.priority >> 24];
          }
          return e;
      });
  }
  function $f8e30544afcd11f0$export$a99147c78a56edc4(window, browserDetails) {
      if (!window.RTCPeerConnection) return;
      if (!("sctp" in window.RTCPeerConnection.prototype)) Object.defineProperty(window.RTCPeerConnection.prototype, "sctp", {
          get () {
              return typeof this._sctp === "undefined" ? null : this._sctp;
          }
      });
      const sctpInDescription = function(description) {
          if (!description || !description.sdp) return false;
          const sections = (0, (/*@__PURE__*/$parcel$interopDefault($30b3171bddcf6271$exports))).splitSections(description.sdp);
          sections.shift();
          return sections.some((mediaSection)=>{
              const mLine = (0, (/*@__PURE__*/$parcel$interopDefault($30b3171bddcf6271$exports))).parseMLine(mediaSection);
              return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
          });
      };
      const getRemoteFirefoxVersion = function(description) {
          // TODO: Is there a better solution for detecting Firefox?
          const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (match === null || match.length < 2) return -1;
          const version = parseInt(match[1], 10);
          // Test for NaN (yes, this is ugly)
          return version !== version ? -1 : version;
      };
      const getCanSendMaxMessageSize = function(remoteIsFirefox) {
          // Every implementation we know can send at least 64 KiB.
          // Note: Although Chrome is technically able to send up to 256 KiB, the
          //       data does not reach the other peer reliably.
          //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
          let canSendMaxMessageSize = 65536;
          if (browserDetails.browser === "firefox") {
              if (browserDetails.version < 57) {
                  if (remoteIsFirefox === -1) // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                  else // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
              } else if (browserDetails.version < 60) // Currently, all FF >= 57 will reset the remote maximum message size
              // to the default value when a data channel is created at a later
              // stage. :(
              // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
              canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
              else // FF >= 60 supports sending ~2 GiB
              canSendMaxMessageSize = 2147483637;
          }
          return canSendMaxMessageSize;
      };
      const getMaxMessageSize = function(description, remoteIsFirefox) {
          // Note: 65536 bytes is the default value from the SDP spec. Also,
          //       every implementation we know supports receiving 65536 bytes.
          let maxMessageSize = 65536;
          // FF 57 has a slightly incorrect default remote max message size, so
          // we need to adjust it here to avoid a failure when sending.
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
          if (browserDetails.browser === "firefox" && browserDetails.version === 57) maxMessageSize = 65535;
          const match = (0, (/*@__PURE__*/$parcel$interopDefault($30b3171bddcf6271$exports))).matchPrefix(description.sdp, "a=max-message-size:");
          if (match.length > 0) maxMessageSize = parseInt(match[0].substring(19), 10);
          else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) // If the maximum message size is not present in the remote SDP and
          // both local and remote are Firefox, the remote peer can receive
          // ~2 GiB.
          maxMessageSize = 2147483637;
          return maxMessageSize;
      };
      const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
          this._sctp = null;
          // Chrome decided to not expose .sctp in plan-b mode.
          // As usual, adapter.js has to do an 'ugly worakaround'
          // to cover up the mess.
          if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
              const { sdpSemantics: sdpSemantics } = this.getConfiguration();
              if (sdpSemantics === "plan-b") Object.defineProperty(this, "sctp", {
                  get () {
                      return typeof this._sctp === "undefined" ? null : this._sctp;
                  },
                  enumerable: true,
                  configurable: true
              });
          }
          if (sctpInDescription(arguments[0])) {
              // Check if the remote is FF.
              const isFirefox = getRemoteFirefoxVersion(arguments[0]);
              // Get the maximum message size the local peer is capable of sending
              const canSendMMS = getCanSendMaxMessageSize(isFirefox);
              // Get the maximum message size of the remote peer.
              const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
              // Determine final maximum message size
              let maxMessageSize;
              if (canSendMMS === 0 && remoteMMS === 0) maxMessageSize = Number.POSITIVE_INFINITY;
              else if (canSendMMS === 0 || remoteMMS === 0) maxMessageSize = Math.max(canSendMMS, remoteMMS);
              else maxMessageSize = Math.min(canSendMMS, remoteMMS);
              // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
              // attribute.
              const sctp = {};
              Object.defineProperty(sctp, "maxMessageSize", {
                  get () {
                      return maxMessageSize;
                  }
              });
              this._sctp = sctp;
          }
          return origSetRemoteDescription.apply(this, arguments);
      };
  }
  function $f8e30544afcd11f0$export$d461c8d5c5db5da7(window) {
      if (!(window.RTCPeerConnection && "createDataChannel" in window.RTCPeerConnection.prototype)) return;
      // Note: Although Firefox >= 57 has a native implementation, the maximum
      //       message size can be reset for all data channels at a later stage.
      //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
      function wrapDcSend(dc, pc) {
          const origDataChannelSend = dc.send;
          dc.send = function send() {
              const data = arguments[0];
              const length = data.length || data.size || data.byteLength;
              if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
              return origDataChannelSend.apply(dc, arguments);
          };
      }
      const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
      window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
          const dataChannel = origCreateDataChannel.apply(this, arguments);
          wrapDcSend(dataChannel, this);
          return dataChannel;
      };
      $11d9b3e4fc7791e1$export$1f48841962b828b1(window, "datachannel", (e)=>{
          wrapDcSend(e.channel, e.target);
          return e;
      });
  }
  function $f8e30544afcd11f0$export$63bb816cc75460(window) {
      if (!window.RTCPeerConnection || "connectionState" in window.RTCPeerConnection.prototype) return;
      const proto = window.RTCPeerConnection.prototype;
      Object.defineProperty(proto, "connectionState", {
          get () {
              return ({
                  completed: "connected",
                  checking: "connecting"
              })[this.iceConnectionState] || this.iceConnectionState;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(proto, "onconnectionstatechange", {
          get () {
              return this._onconnectionstatechange || null;
          },
          set (cb) {
              if (this._onconnectionstatechange) {
                  this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
                  delete this._onconnectionstatechange;
              }
              if (cb) this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
          },
          enumerable: true,
          configurable: true
      });
      [
          "setLocalDescription",
          "setRemoteDescription"
      ].forEach((method)=>{
          const origMethod = proto[method];
          proto[method] = function() {
              if (!this._connectionstatechangepoly) {
                  this._connectionstatechangepoly = (e)=>{
                      const pc = e.target;
                      if (pc._lastConnectionState !== pc.connectionState) {
                          pc._lastConnectionState = pc.connectionState;
                          const newEvent = new Event("connectionstatechange", e);
                          pc.dispatchEvent(newEvent);
                      }
                      return e;
                  };
                  this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
              }
              return origMethod.apply(this, arguments);
          };
      });
  }
  function $f8e30544afcd11f0$export$a57d114344295149(window, browserDetails) {
      /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window.RTCPeerConnection) return;
      if (browserDetails.browser === "chrome" && browserDetails.version >= 71) return;
      if (browserDetails.browser === "safari" && browserDetails.version >= 605) return;
      const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
          if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
              const sdp = desc.sdp.split("\n").filter((line)=>{
                  return line.trim() !== "a=extmap-allow-mixed";
              }).join("\n");
              // Safari enforces read-only-ness of RTCSessionDescription fields.
              if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) arguments[0] = new window.RTCSessionDescription({
                  type: desc.type,
                  sdp: sdp
              });
              else desc.sdp = sdp;
          }
          return nativeSRD.apply(this, arguments);
      };
  }
  function $f8e30544afcd11f0$export$51d5e40b48c771c7(window, browserDetails) {
      // Support for addIceCandidate(null or undefined)
      // as well as addIceCandidate({candidate: "", ...})
      // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
      // Note: must be called before other polyfills which change the signature.
      if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) return;
      const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
      if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) return;
      window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
          if (!arguments[0]) {
              if (arguments[1]) arguments[1].apply(null);
              return Promise.resolve();
          }
          // Firefox 68+ emits and processes {candidate: "", ...}, ignore
          // in older versions.
          // Native support for ignoring exists for Chrome M77+.
          // Safari ignores as well, exact version unknown but works in the same
          // version that also ignores addIceCandidate(null).
          if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") return Promise.resolve();
          return nativeAddIceCandidate.apply(this, arguments);
      };
  }
  function $f8e30544afcd11f0$export$7170d04e59f9d553(window, browserDetails) {
      if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) return;
      const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
      if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) return;
      window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
          let desc = arguments[0] || {};
          if (typeof desc !== "object" || desc.type && desc.sdp) return nativeSetLocalDescription.apply(this, arguments);
          // The remaining steps should technically happen when SLD comes off the
          // RTCPeerConnection's operations chain (not ahead of going on it), but
          // this is too difficult to shim. Instead, this shim only covers the
          // common case where the operations chain is empty. This is imperfect, but
          // should cover many cases. Rationale: Even if we can't reduce the glare
          // window to zero on imperfect implementations, there's value in tapping
          // into the perfect negotiation pattern that several browsers support.
          desc = {
              type: desc.type,
              sdp: desc.sdp
          };
          if (!desc.type) switch(this.signalingState){
              case "stable":
              case "have-local-offer":
              case "have-remote-pranswer":
                  desc.type = "offer";
                  break;
              default:
                  desc.type = "answer";
                  break;
          }
          if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") return nativeSetLocalDescription.apply(this, [
              desc
          ]);
          const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
          return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [
                  d
              ]));
      };
  }
  
  
  
  function $53a477c62a90b792$export$e77bf46c04ac7d12({ window: window } = {}, options = {
      shimChrome: true,
      shimFirefox: true,
      shimSafari: true
  }) {
      // Utils.
      const logging = $11d9b3e4fc7791e1$export$bef1f36f5486a6a3;
      const browserDetails = $11d9b3e4fc7791e1$export$2d31490a0c05f094(window);
      const adapter = {
          browserDetails: browserDetails,
          commonShim: $f8e30544afcd11f0$exports,
          extractVersion: $11d9b3e4fc7791e1$export$e3c02be309be1f23,
          disableLog: $11d9b3e4fc7791e1$export$afbfee8cc06fd3e4,
          disableWarnings: $11d9b3e4fc7791e1$export$51516be4b019e41e,
          sdp: // Expose sdp as a convenience. For production apps include directly.
          $30b3171bddcf6271$exports
      };
      // Shim browser if found.
      switch(browserDetails.browser){
          case "chrome":
              if (!$041f4f4318baab2c$exports || !$041f4f4318baab2c$exports.shimPeerConnection || !options.shimChrome) {
                  logging("Chrome shim is not included in this adapter release.");
                  return adapter;
              }
              if (browserDetails.version === null) {
                  logging("Chrome shim can not determine version, not shimming.");
                  return adapter;
              }
              logging("adapter.js shimming chrome.");
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = $041f4f4318baab2c$exports;
              // Must be called before shimPeerConnection.
              $f8e30544afcd11f0$export$51d5e40b48c771c7(window, browserDetails);
              $f8e30544afcd11f0$export$7170d04e59f9d553(window, browserDetails);
              $041f4f4318baab2c$exports.shimGetUserMedia(window, browserDetails);
              $041f4f4318baab2c$exports.shimMediaStream(window, browserDetails);
              $041f4f4318baab2c$exports.shimPeerConnection(window, browserDetails);
              $041f4f4318baab2c$exports.shimOnTrack(window, browserDetails);
              $041f4f4318baab2c$exports.shimAddTrackRemoveTrack(window, browserDetails);
              $041f4f4318baab2c$exports.shimGetSendersWithDtmf(window, browserDetails);
              $041f4f4318baab2c$exports.shimGetStats(window, browserDetails);
              $041f4f4318baab2c$exports.shimSenderReceiverGetStats(window, browserDetails);
              $041f4f4318baab2c$exports.fixNegotiationNeeded(window, browserDetails);
              $f8e30544afcd11f0$export$cf133661e444ccfe(window, browserDetails);
              $f8e30544afcd11f0$export$fdafb8d8280e29b5(window, browserDetails);
              $f8e30544afcd11f0$export$63bb816cc75460(window, browserDetails);
              $f8e30544afcd11f0$export$a99147c78a56edc4(window, browserDetails);
              $f8e30544afcd11f0$export$d461c8d5c5db5da7(window, browserDetails);
              $f8e30544afcd11f0$export$a57d114344295149(window, browserDetails);
              break;
          case "firefox":
              if (!$5ba25c21eb1c0af8$exports || !$5ba25c21eb1c0af8$exports.shimPeerConnection || !options.shimFirefox) {
                  logging("Firefox shim is not included in this adapter release.");
                  return adapter;
              }
              logging("adapter.js shimming firefox.");
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = $5ba25c21eb1c0af8$exports;
              // Must be called before shimPeerConnection.
              $f8e30544afcd11f0$export$51d5e40b48c771c7(window, browserDetails);
              $f8e30544afcd11f0$export$7170d04e59f9d553(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimGetUserMedia(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimPeerConnection(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimOnTrack(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimRemoveStream(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimSenderGetStats(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimReceiverGetStats(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimRTCDataChannel(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimAddTransceiver(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimGetParameters(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimCreateOffer(window, browserDetails);
              $5ba25c21eb1c0af8$exports.shimCreateAnswer(window, browserDetails);
              $f8e30544afcd11f0$export$cf133661e444ccfe(window, browserDetails);
              $f8e30544afcd11f0$export$63bb816cc75460(window, browserDetails);
              $f8e30544afcd11f0$export$a99147c78a56edc4(window, browserDetails);
              $f8e30544afcd11f0$export$d461c8d5c5db5da7(window, browserDetails);
              break;
          case "safari":
              if (!$93a503258ac80079$exports || !options.shimSafari) {
                  logging("Safari shim is not included in this adapter release.");
                  return adapter;
              }
              logging("adapter.js shimming safari.");
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = $93a503258ac80079$exports;
              // Must be called before shimCallbackAPI.
              $f8e30544afcd11f0$export$51d5e40b48c771c7(window, browserDetails);
              $f8e30544afcd11f0$export$7170d04e59f9d553(window, browserDetails);
              $93a503258ac80079$exports.shimRTCIceServerUrls(window, browserDetails);
              $93a503258ac80079$exports.shimCreateOfferLegacy(window, browserDetails);
              $93a503258ac80079$exports.shimCallbacksAPI(window, browserDetails);
              $93a503258ac80079$exports.shimLocalStreamsAPI(window, browserDetails);
              $93a503258ac80079$exports.shimRemoteStreamsAPI(window, browserDetails);
              $93a503258ac80079$exports.shimTrackEventTransceiver(window, browserDetails);
              $93a503258ac80079$exports.shimGetUserMedia(window, browserDetails);
              $93a503258ac80079$exports.shimAudioContext(window, browserDetails);
              $f8e30544afcd11f0$export$cf133661e444ccfe(window, browserDetails);
              $f8e30544afcd11f0$export$fdafb8d8280e29b5(window, browserDetails);
              $f8e30544afcd11f0$export$a99147c78a56edc4(window, browserDetails);
              $f8e30544afcd11f0$export$d461c8d5c5db5da7(window, browserDetails);
              $f8e30544afcd11f0$export$a57d114344295149(window, browserDetails);
              break;
          default:
              logging("Unsupported browser!");
              break;
      }
      return adapter;
  }
  
  
  "use strict";
  const $cd55ff0e0516c779$var$adapter = (0, $53a477c62a90b792$export$e77bf46c04ac7d12)({
      window: typeof window === "undefined" ? undefined : window
  });
  var $cd55ff0e0516c779$export$2e2bcd8739ae039 = $cd55ff0e0516c779$var$adapter;
  
  
  const $f719426f9499296d$var$webRTCAdapter = //@ts-ignore
  (0, $cd55ff0e0516c779$export$2e2bcd8739ae039).default || (0, $cd55ff0e0516c779$export$2e2bcd8739ae039);
  const $f719426f9499296d$export$25be9502477c137d = new class {
      isWebRTCSupported() {
          return typeof RTCPeerConnection !== "undefined";
      }
      isBrowserSupported() {
          const browser = this.getBrowser();
          const version = this.getVersion();
          const validBrowser = this.supportedBrowsers.includes(browser);
          if (!validBrowser) return false;
          if (browser === "chrome") return version >= this.minChromeVersion;
          if (browser === "firefox") return version >= this.minFirefoxVersion;
          if (browser === "safari") return !this.isIOS && version >= this.minSafariVersion;
          return false;
      }
      getBrowser() {
          return $f719426f9499296d$var$webRTCAdapter.browserDetails.browser;
      }
      getVersion() {
          return $f719426f9499296d$var$webRTCAdapter.browserDetails.version || 0;
      }
      isUnifiedPlanSupported() {
          const browser = this.getBrowser();
          const version = $f719426f9499296d$var$webRTCAdapter.browserDetails.version || 0;
          if (browser === "chrome" && version < this.minChromeVersion) return false;
          if (browser === "firefox" && version >= this.minFirefoxVersion) return true;
          if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return false;
          let tempPc;
          let supported = false;
          try {
              tempPc = new RTCPeerConnection();
              tempPc.addTransceiver("audio");
              supported = true;
          } catch (e) {} finally{
              if (tempPc) tempPc.close();
          }
          return supported;
      }
      toString() {
          return `Supports:
      browser:${this.getBrowser()}
      version:${this.getVersion()}
      isIOS:${this.isIOS}
      isWebRTCSupported:${this.isWebRTCSupported()}
      isBrowserSupported:${this.isBrowserSupported()}
      isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;
      }
      constructor(){
          this.isIOS = [
              "iPad",
              "iPhone",
              "iPod"
          ].includes(navigator.platform);
          this.supportedBrowsers = [
              "firefox",
              "chrome",
              "safari"
          ];
          this.minFirefoxVersion = 59;
          this.minChromeVersion = 72;
          this.minSafariVersion = 605;
      }
  }();
  
  
  const $fdc87120bf726113$export$f35f128fd59ea256 = (id)=>{
      // Allow empty ids
      return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);
  };
  
  
  const $eb24a05d5e66c1f6$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);
  
  
  const $0c88dccd73f5641e$var$DEFAULT_CONFIG = {
      iceServers: [
          {
              urls: "stun:stun.l.google.com:19302"
          },
          {
              urls: [
                  "turn:eu-0.turn.peerjs.com:3478",
                  "turn:us-0.turn.peerjs.com:3478"
              ],
              username: "peerjs",
              credential: "peerjsp"
          }
      ],
      sdpSemantics: "unified-plan"
  };
  class $0c88dccd73f5641e$export$f8f26dd395d7e1bd extends (0, $337647a69164cf0a$export$f1c5f4c9cb95390b) {
      noop() {}
      blobToArrayBuffer(blob, cb) {
          const fr = new FileReader();
          fr.onload = function(evt) {
              if (evt.target) cb(evt.target.result);
          };
          fr.readAsArrayBuffer(blob);
          return fr;
      }
      binaryStringToArrayBuffer(binary) {
          const byteArray = new Uint8Array(binary.length);
          for(let i = 0; i < binary.length; i++)byteArray[i] = binary.charCodeAt(i) & 0xff;
          return byteArray.buffer;
      }
      isSecure() {
          return location.protocol === "https:";
      }
      constructor(...args){
          super(...args);
          this.CLOUD_HOST = "0.peerjs.com";
          this.CLOUD_PORT = 443;
          // Browsers that need chunking:
          this.chunkedBrowsers = {
              Chrome: 1,
              chrome: 1
          };
          // Returns browser-agnostic default config
          this.defaultConfig = $0c88dccd73f5641e$var$DEFAULT_CONFIG;
          this.browser = (0, $f719426f9499296d$export$25be9502477c137d).getBrowser();
          this.browserVersion = (0, $f719426f9499296d$export$25be9502477c137d).getVersion();
          this.pack = $41cdfe0a3ede2608$export$2a703dbb0cb35339;
          this.unpack = $41cdfe0a3ede2608$export$417857010dc9287f;
          /**
     * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.
     *
     * :::caution
     * Only the properties documented here are guaranteed to be present on `util.supports`
     * :::
     */ this.supports = function() {
              const supported = {
                  browser: (0, $f719426f9499296d$export$25be9502477c137d).isBrowserSupported(),
                  webRTC: (0, $f719426f9499296d$export$25be9502477c137d).isWebRTCSupported(),
                  audioVideo: false,
                  data: false,
                  binaryBlob: false,
                  reliable: false
              };
              if (!supported.webRTC) return supported;
              let pc;
              try {
                  pc = new RTCPeerConnection($0c88dccd73f5641e$var$DEFAULT_CONFIG);
                  supported.audioVideo = true;
                  let dc;
                  try {
                      dc = pc.createDataChannel("_PEERJSTEST", {
                          ordered: true
                      });
                      supported.data = true;
                      supported.reliable = !!dc.ordered;
                      // Binary test
                      try {
                          dc.binaryType = "blob";
                          supported.binaryBlob = !(0, $f719426f9499296d$export$25be9502477c137d).isIOS;
                      } catch (e) {}
                  } catch (e) {} finally{
                      if (dc) dc.close();
                  }
              } catch (e) {} finally{
                  if (pc) pc.close();
              }
              return supported;
          }();
          // Ensure alphanumeric ids
          this.validateId = (0, $fdc87120bf726113$export$f35f128fd59ea256);
          this.randomToken = (0, $eb24a05d5e66c1f6$export$4e61f672936bec77);
      }
  }
  const $0c88dccd73f5641e$export$7debb50ef11d5e0b = new $0c88dccd73f5641e$export$f8f26dd395d7e1bd();
  
  
  
  const $6adb9b697958aa01$var$LOG_PREFIX = "PeerJS: ";
  var $6adb9b697958aa01$export$243e62d78d3b544d;
  (function(LogLevel) {
      /**
     * Prints no logs.
     */ LogLevel[LogLevel["Disabled"] = 0] = "Disabled";
      /**
     * Prints only errors.
     */ LogLevel[LogLevel["Errors"] = 1] = "Errors";
      /**
     * Prints errors and warnings.
     */ LogLevel[LogLevel["Warnings"] = 2] = "Warnings";
      /**
     * Prints all logs.
     */ LogLevel[LogLevel["All"] = 3] = "All";
  })($6adb9b697958aa01$export$243e62d78d3b544d || ($6adb9b697958aa01$export$243e62d78d3b544d = {}));
  class $6adb9b697958aa01$var$Logger {
      get logLevel() {
          return this._logLevel;
      }
      set logLevel(logLevel) {
          this._logLevel = logLevel;
      }
      log(...args) {
          if (this._logLevel >= 3) this._print(3, ...args);
      }
      warn(...args) {
          if (this._logLevel >= 2) this._print(2, ...args);
      }
      error(...args) {
          if (this._logLevel >= 1) this._print(1, ...args);
      }
      setLogFunction(fn) {
          this._print = fn;
      }
      _print(logLevel, ...rest) {
          const copy = [
              $6adb9b697958aa01$var$LOG_PREFIX,
              ...rest
          ];
          for(const i in copy)if (copy[i] instanceof Error) copy[i] = "(" + copy[i].name + ") " + copy[i].message;
          if (logLevel >= 3) console.log(...copy);
          else if (logLevel >= 2) console.warn("WARNING", ...copy);
          else if (logLevel >= 1) console.error("ERROR", ...copy);
      }
      constructor(){
          this._logLevel = 0;
      }
  }
  var $6adb9b697958aa01$export$2e2bcd8739ae039 = new $6adb9b697958aa01$var$Logger();
  
  
  var $6af28e6583ade012$exports = {};
  "use strict";
  var $6af28e6583ade012$var$has = Object.prototype.hasOwnProperty, $6af28e6583ade012$var$prefix = "~";
  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */ function $6af28e6583ade012$var$Events() {}
  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
      $6af28e6583ade012$var$Events.prototype = Object.create(null);
      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new $6af28e6583ade012$var$Events().__proto__) $6af28e6583ade012$var$prefix = false;
  }
  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */ function $6af28e6583ade012$var$EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
  }
  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */ function $6af28e6583ade012$var$addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") throw new TypeError("The listener must be a function");
      var listener = new $6af28e6583ade012$var$EE(fn, context || emitter, once), evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [
          emitter._events[evt],
          listener
      ];
      return emitter;
  }
  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */ function $6af28e6583ade012$var$clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new $6af28e6583ade012$var$Events();
      else delete emitter._events[evt];
  }
  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */ function $6af28e6583ade012$var$EventEmitter() {
      this._events = new $6af28e6583ade012$var$Events();
      this._eventsCount = 0;
  }
  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for(name in events = this._events)if ($6af28e6583ade012$var$has.call(events, name)) names.push($6af28e6583ade012$var$prefix ? name.slice(1) : name);
      if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
      return names;
  };
  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.listeners = function listeners(event) {
      var evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [
          handlers.fn
      ];
      for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
      return ee;
  };
  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
  };
  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
          switch(len){
              case 1:
                  return listeners.fn.call(listeners.context), true;
              case 2:
                  return listeners.fn.call(listeners.context, a1), true;
              case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
          listeners.fn.apply(listeners.context, args);
      } else {
          var length = listeners.length, j;
          for(i = 0; i < length; i++){
              if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
              switch(len){
                  case 1:
                      listeners[i].fn.call(listeners[i].context);
                      break;
                  case 2:
                      listeners[i].fn.call(listeners[i].context, a1);
                      break;
                  case 3:
                      listeners[i].fn.call(listeners[i].context, a1, a2);
                      break;
                  case 4:
                      listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                      break;
                  default:
                      if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                      listeners[i].fn.apply(listeners[i].context, args);
              }
          }
      }
      return true;
  };
  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.on = function on(event, fn, context) {
      return $6af28e6583ade012$var$addListener(this, event, fn, context, false);
  };
  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.once = function once(event, fn, context) {
      return $6af28e6583ade012$var$addListener(this, event, fn, context, true);
  };
  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
          $6af28e6583ade012$var$clearEvent(this, evt);
          return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $6af28e6583ade012$var$clearEvent(this, evt);
      } else {
          for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
          //
          // Reset the array, or remove it completely if we have no more listeners.
          //
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else $6af28e6583ade012$var$clearEvent(this, evt);
      }
      return this;
  };
  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */ $6af28e6583ade012$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
          evt = $6af28e6583ade012$var$prefix ? $6af28e6583ade012$var$prefix + event : event;
          if (this._events[evt]) $6af28e6583ade012$var$clearEvent(this, evt);
      } else {
          this._events = new $6af28e6583ade012$var$Events();
          this._eventsCount = 0;
      }
      return this;
  };
  //
  // Alias methods names because people roll like that.
  //
  $6af28e6583ade012$var$EventEmitter.prototype.off = $6af28e6583ade012$var$EventEmitter.prototype.removeListener;
  $6af28e6583ade012$var$EventEmitter.prototype.addListener = $6af28e6583ade012$var$EventEmitter.prototype.on;
  //
  // Expose the prefix.
  //
  $6af28e6583ade012$var$EventEmitter.prefixed = $6af28e6583ade012$var$prefix;
  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  $6af28e6583ade012$var$EventEmitter.EventEmitter = $6af28e6583ade012$var$EventEmitter;
  $6af28e6583ade012$exports = $6af28e6583ade012$var$EventEmitter;
  
  
  
  var $200acda04d260725$export$3157d57b4135e3bc;
  (function(ConnectionType) {
      ConnectionType["Data"] = "data";
      ConnectionType["Media"] = "media";
  })($200acda04d260725$export$3157d57b4135e3bc || ($200acda04d260725$export$3157d57b4135e3bc = {}));
  var $200acda04d260725$export$9547aaa2e39030ff;
  (function(PeerErrorType) {
      /**
     * The client's browser does not support some or all WebRTC features that you are trying to use.
     */ PeerErrorType["BrowserIncompatible"] = "browser-incompatible";
      /**
     * You've already disconnected this peer from the server and can no longer make any new connections on it.
     */ PeerErrorType["Disconnected"] = "disconnected";
      /**
     * The ID passed into the Peer constructor contains illegal characters.
     */ PeerErrorType["InvalidID"] = "invalid-id";
      /**
     * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).
     */ PeerErrorType["InvalidKey"] = "invalid-key";
      /**
     * Lost or cannot establish a connection to the signalling server.
     */ PeerErrorType["Network"] = "network";
      /**
     * The peer you're trying to connect to does not exist.
     */ PeerErrorType["PeerUnavailable"] = "peer-unavailable";
      /**
     * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.
     */ PeerErrorType["SslUnavailable"] = "ssl-unavailable";
      /**
     * Unable to reach the server.
     */ PeerErrorType["ServerError"] = "server-error";
      /**
     * An error from the underlying socket.
     */ PeerErrorType["SocketError"] = "socket-error";
      /**
     * The underlying socket closed unexpectedly.
     */ PeerErrorType["SocketClosed"] = "socket-closed";
      /**
     * The ID passed into the Peer constructor is already taken.
     *
     * :::caution
     * This error is not fatal if your peer has open peer-to-peer connections.
     * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,
     * but its old ID has now been taken.
     * :::
     */ PeerErrorType["UnavailableID"] = "unavailable-id";
      /**
     * Native WebRTC errors.
     */ PeerErrorType["WebRTC"] = "webrtc";
  })($200acda04d260725$export$9547aaa2e39030ff || ($200acda04d260725$export$9547aaa2e39030ff = {}));
  var $200acda04d260725$export$7974935686149686;
  (function(BaseConnectionErrorType) {
      BaseConnectionErrorType["NegotiationFailed"] = "negotiation-failed";
      BaseConnectionErrorType["ConnectionClosed"] = "connection-closed";
  })($200acda04d260725$export$7974935686149686 || ($200acda04d260725$export$7974935686149686 = {}));
  var $200acda04d260725$export$49ae800c114df41d;
  (function(DataConnectionErrorType) {
      DataConnectionErrorType["NotOpenYet"] = "not-open-yet";
      DataConnectionErrorType["MessageToBig"] = "message-too-big";
  })($200acda04d260725$export$49ae800c114df41d || ($200acda04d260725$export$49ae800c114df41d = {}));
  var $200acda04d260725$export$89f507cf986a947;
  (function(SerializationType) {
      SerializationType["Binary"] = "binary";
      SerializationType["BinaryUTF8"] = "binary-utf8";
      SerializationType["JSON"] = "json";
      SerializationType["None"] = "raw";
  })($200acda04d260725$export$89f507cf986a947 || ($200acda04d260725$export$89f507cf986a947 = {}));
  var $200acda04d260725$export$3b5c4a4b6354f023;
  (function(SocketEventType) {
      SocketEventType["Message"] = "message";
      SocketEventType["Disconnected"] = "disconnected";
      SocketEventType["Error"] = "error";
      SocketEventType["Close"] = "close";
  })($200acda04d260725$export$3b5c4a4b6354f023 || ($200acda04d260725$export$3b5c4a4b6354f023 = {}));
  var $200acda04d260725$export$adb4a1754da6f10d;
  (function(ServerMessageType) {
      ServerMessageType["Heartbeat"] = "HEARTBEAT";
      ServerMessageType["Candidate"] = "CANDIDATE";
      ServerMessageType["Offer"] = "OFFER";
      ServerMessageType["Answer"] = "ANSWER";
      ServerMessageType["Open"] = "OPEN";
      ServerMessageType["Error"] = "ERROR";
      ServerMessageType["IdTaken"] = "ID-TAKEN";
      ServerMessageType["InvalidKey"] = "INVALID-KEY";
      ServerMessageType["Leave"] = "LEAVE";
      ServerMessageType["Expire"] = "EXPIRE";
  })($200acda04d260725$export$adb4a1754da6f10d || ($200acda04d260725$export$adb4a1754da6f10d = {}));
  
  
  var $ccd644f7486bf635$exports = {};
  $ccd644f7486bf635$exports = JSON.parse('{"name":"peerjs","version":"1.5.2","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xfcckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","browser-minified-cbor":"dist/serializer.cbor.mjs","browser-minified-msgpack":"dist/serializer.msgpack.mjs","types":"dist/types.d.ts","engines":{"node":">= 14"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-minified-cbor":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/Cbor.ts"},"browser-minified-msgpack":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/MsgPack.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"jest","test:watch":"jest --watch","coverage":"jest --coverage --collectCoverageFrom=\\"./lib/**\\"","format":"prettier --write .","format:check":"prettier --check .","semantic-release":"semantic-release","e2e":"wdio run e2e/wdio.local.conf.ts","e2e:bstack":"wdio run e2e/wdio.bstack.conf.ts"},"devDependencies":{"@parcel/config-default":"^2.9.3","@parcel/packager-ts":"^2.9.3","@parcel/transformer-typescript-tsc":"^2.9.3","@parcel/transformer-typescript-types":"^2.9.3","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@swc/core":"^1.3.27","@swc/jest":"^0.2.24","@types/jasmine":"^4.3.4","@wdio/browserstack-service":"^8.11.2","@wdio/cli":"^8.11.2","@wdio/globals":"^8.11.2","@wdio/jasmine-framework":"^8.11.2","@wdio/local-runner":"^8.11.2","@wdio/spec-reporter":"^8.11.2","@wdio/types":"^8.10.4","http-server":"^14.1.1","jest":"^29.3.1","jest-environment-jsdom":"^29.3.1","mock-socket":"^9.0.0","parcel":"^2.9.3","prettier":"^3.0.0","semantic-release":"^21.0.0","ts-node":"^10.9.1","typescript":"^5.0.0","wdio-geckodriver-service":"^5.0.1"},"dependencies":{"@msgpack/msgpack":"^2.8.0","cbor-x":"1.5.4","eventemitter3":"^4.0.7","peerjs-js-binarypack":"^2.1.0","webrtc-adapter":"^8.0.0"},"alias":{"process":false,"buffer":false}}');
  
  
  class $9dca0f9415f15a97$export$4798917dbf149b79 extends (0, $6af28e6583ade012$exports.EventEmitter) {
      start(id, token) {
          this._id = id;
          const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;
          if (!!this._socket || !this._disconnected) return;
          this._socket = new WebSocket(wsUrl + "&version=" + (0, $ccd644f7486bf635$exports.version));
          this._disconnected = false;
          this._socket.onmessage = (event)=>{
              let data;
              try {
                  data = JSON.parse(event.data);
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Server message received:", data);
              } catch (e) {
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Invalid server message", event.data);
                  return;
              }
              this.emit((0, $200acda04d260725$export$3b5c4a4b6354f023).Message, data);
          };
          this._socket.onclose = (event)=>{
              if (this._disconnected) return;
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Socket closed.", event);
              this._cleanup();
              this._disconnected = true;
              this.emit((0, $200acda04d260725$export$3b5c4a4b6354f023).Disconnected);
          };
          // Take care of the queue of connections if necessary and make sure Peer knows
          // socket is open.
          this._socket.onopen = ()=>{
              if (this._disconnected) return;
              this._sendQueuedMessages();
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Socket open");
              this._scheduleHeartbeat();
          };
      }
      _scheduleHeartbeat() {
          this._wsPingTimer = setTimeout(()=>{
              this._sendHeartbeat();
          }, this.pingInterval);
      }
      _sendHeartbeat() {
          if (!this._wsOpen()) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Cannot send heartbeat, because socket closed`);
              return;
          }
          const message = JSON.stringify({
              type: (0, $200acda04d260725$export$adb4a1754da6f10d).Heartbeat
          });
          this._socket.send(message);
          this._scheduleHeartbeat();
      }
      /** Is the websocket currently open? */ _wsOpen() {
          return !!this._socket && this._socket.readyState === 1;
      }
      /** Send queued messages. */ _sendQueuedMessages() {
          //Create copy of queue and clear it,
          //because send method push the message back to queue if smth will go wrong
          const copiedQueue = [
              ...this._messagesQueue
          ];
          this._messagesQueue = [];
          for (const message of copiedQueue)this.send(message);
      }
      /** Exposed send for DC & Peer. */ send(data) {
          if (this._disconnected) return;
          // If we didn't get an ID yet, we can't yet send anything so we should queue
          // up these messages.
          if (!this._id) {
              this._messagesQueue.push(data);
              return;
          }
          if (!data.type) {
              this.emit((0, $200acda04d260725$export$3b5c4a4b6354f023).Error, "Invalid message");
              return;
          }
          if (!this._wsOpen()) return;
          const message = JSON.stringify(data);
          this._socket.send(message);
      }
      close() {
          if (this._disconnected) return;
          this._cleanup();
          this._disconnected = true;
      }
      _cleanup() {
          if (this._socket) {
              this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;
              this._socket.close();
              this._socket = undefined;
          }
          clearTimeout(this._wsPingTimer);
      }
      constructor(secure, host, port, path, key, pingInterval = 5000){
          super();
          this.pingInterval = pingInterval;
          this._disconnected = true;
          this._messagesQueue = [];
          const wsProtocol = secure ? "wss://" : "ws://";
          this._baseUrl = wsProtocol + host + ":" + port + path + "peerjs?key=" + key;
      }
  }
  
  
  
  
  
  
  class $09f4090c200a4747$export$89e6bb5ad64bf4a {
      /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {
          const peerConnection = this._startPeerConnection();
          // Set the connection's PC.
          this.connection.peerConnection = peerConnection;
          if (this.connection.type === (0, $200acda04d260725$export$3157d57b4135e3bc).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);
          // What do we need to do now?
          if (options.originator) {
              const dataConnection = this.connection;
              const config = {
                  ordered: !!options.reliable
              };
              const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);
              dataConnection._initializeDataChannel(dataChannel);
              this._makeOffer();
          } else this.handleSDP("OFFER", options.sdp);
      }
      /** Start a PC. */ _startPeerConnection() {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Creating RTCPeerConnection.");
          const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);
          this._setupListeners(peerConnection);
          return peerConnection;
      }
      /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {
          const peerId = this.connection.peer;
          const connectionId = this.connection.connectionId;
          const connectionType = this.connection.type;
          const provider = this.connection.provider;
          // ICE CANDIDATES.
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Listening for ICE candidates.");
          peerConnection.onicecandidate = (evt)=>{
              if (!evt.candidate || !evt.candidate.candidate) return;
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Received ICE candidates for ${peerId}:`, evt.candidate);
              provider.socket.send({
                  type: (0, $200acda04d260725$export$adb4a1754da6f10d).Candidate,
                  payload: {
                      candidate: evt.candidate,
                      type: connectionType,
                      connectionId: connectionId
                  },
                  dst: peerId
              });
          };
          peerConnection.oniceconnectionstatechange = ()=>{
              switch(peerConnection.iceConnectionState){
                  case "failed":
                      (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("iceConnectionState is failed, closing connections to " + peerId);
                      this.connection.emitError((0, $200acda04d260725$export$7974935686149686).NegotiationFailed, "Negotiation of connection to " + peerId + " failed.");
                      this.connection.close();
                      break;
                  case "closed":
                      (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("iceConnectionState is closed, closing connections to " + peerId);
                      this.connection.emitError((0, $200acda04d260725$export$7974935686149686).ConnectionClosed, "Connection to " + peerId + " closed.");
                      this.connection.close();
                      break;
                  case "disconnected":
                      (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("iceConnectionState changed to disconnected on the connection with " + peerId);
                      break;
                  case "completed":
                      peerConnection.onicecandidate = ()=>{};
                      break;
              }
              this.connection.emit("iceStateChanged", peerConnection.iceConnectionState);
          };
          // DATACONNECTION.
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Listening for data channel");
          // Fired between offer and answer, so options should already be saved
          // in the options hash.
          peerConnection.ondatachannel = (evt)=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Received data channel");
              const dataChannel = evt.channel;
              const connection = provider.getConnection(peerId, connectionId);
              connection._initializeDataChannel(dataChannel);
          };
          // MEDIACONNECTION.
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Listening for remote stream");
          peerConnection.ontrack = (evt)=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Received remote stream");
              const stream = evt.streams[0];
              const connection = provider.getConnection(peerId, connectionId);
              if (connection.type === (0, $200acda04d260725$export$3157d57b4135e3bc).Media) {
                  const mediaConnection = connection;
                  this._addStreamToMediaConnection(stream, mediaConnection);
              }
          };
      }
      cleanup() {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Cleaning up PeerConnection to " + this.connection.peer);
          const peerConnection = this.connection.peerConnection;
          if (!peerConnection) return;
          this.connection.peerConnection = null;
          //unsubscribe from all PeerConnection's events
          peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};
          const peerConnectionNotClosed = peerConnection.signalingState !== "closed";
          let dataChannelNotClosed = false;
          const dataChannel = this.connection.dataChannel;
          if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== "closed";
          if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();
      }
      async _makeOffer() {
          const peerConnection = this.connection.peerConnection;
          const provider = this.connection.provider;
          try {
              const offer = await peerConnection.createOffer(this.connection.options.constraints);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Created offer.");
              if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;
              try {
                  await peerConnection.setLocalDescription(offer);
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Set localDescription:", offer, `for:${this.connection.peer}`);
                  let payload = {
                      sdp: offer,
                      type: this.connection.type,
                      connectionId: this.connection.connectionId,
                      metadata: this.connection.metadata
                  };
                  if (this.connection.type === (0, $200acda04d260725$export$3157d57b4135e3bc).Data) {
                      const dataConnection = this.connection;
                      payload = {
                          ...payload,
                          label: dataConnection.label,
                          reliable: dataConnection.reliable,
                          serialization: dataConnection.serialization
                      };
                  }
                  provider.socket.send({
                      type: (0, $200acda04d260725$export$adb4a1754da6f10d).Offer,
                      payload: payload,
                      dst: this.connection.peer
                  });
              } catch (err) {
                  // TODO: investigate why _makeOffer is being called from the answer
                  if (err != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer") {
                      provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err);
                      (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to setLocalDescription, ", err);
                  }
              }
          } catch (err_1) {
              provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err_1);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to createOffer, ", err_1);
          }
      }
      async _makeAnswer() {
          const peerConnection = this.connection.peerConnection;
          const provider = this.connection.provider;
          try {
              const answer = await peerConnection.createAnswer();
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Created answer.");
              if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;
              try {
                  await peerConnection.setLocalDescription(answer);
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);
                  provider.socket.send({
                      type: (0, $200acda04d260725$export$adb4a1754da6f10d).Answer,
                      payload: {
                          sdp: answer,
                          type: this.connection.type,
                          connectionId: this.connection.connectionId
                      },
                      dst: this.connection.peer
                  });
              } catch (err) {
                  provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err);
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to setLocalDescription, ", err);
              }
          } catch (err_1) {
              provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err_1);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to create answer, ", err_1);
          }
      }
      /** Handle an SDP. */ async handleSDP(type, sdp) {
          sdp = new RTCSessionDescription(sdp);
          const peerConnection = this.connection.peerConnection;
          const provider = this.connection.provider;
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Setting remote description", sdp);
          const self = this;
          try {
              await peerConnection.setRemoteDescription(sdp);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);
              if (type === "OFFER") await self._makeAnswer();
          } catch (err) {
              provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to setRemoteDescription, ", err);
          }
      }
      /** Handle a candidate. */ async handleCandidate(ice) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`handleCandidate:`, ice);
          try {
              await this.connection.peerConnection.addIceCandidate(ice);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);
          } catch (err) {
              this.connection.provider.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).WebRTC, err);
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Failed to handleCandidate, ", err);
          }
      }
      _addTracksToConnection(stream, peerConnection) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`add tracks from stream ${stream.id} to peer connection`);
          if (!peerConnection.addTrack) return (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);
          stream.getTracks().forEach((track)=>{
              peerConnection.addTrack(track, stream);
          });
      }
      _addStreamToMediaConnection(stream, mediaConnection) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);
          mediaConnection.addStream(stream);
      }
      constructor(connection){
          this.connection = connection;
      }
  }
  
  
  
  
  
  class $a084ca3b0aa8dd08$export$6a678e589c8a4542 extends (0, $6af28e6583ade012$exports.EventEmitter) {
      /**
     * Emits a typed error message.
     *
     * @internal
     */ emitError(type, err) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("Error:", err);
          // @ts-ignore
          this.emit("error", new $a084ca3b0aa8dd08$export$98871882f492de82(`${type}`, err));
      }
  }
  class $a084ca3b0aa8dd08$export$98871882f492de82 extends Error {
      /**
     * @internal
     */ constructor(type, err){
          if (typeof err === "string") super(err);
          else {
              super();
              Object.assign(this, err);
          }
          this.type = type;
      }
  }
  
  
  class $e7e1c6f19b5349be$export$23a2a68283c24d80 extends (0, $a084ca3b0aa8dd08$export$6a678e589c8a4542) {
      /**
     * Whether the media connection is active (e.g. your call has been answered).
     * You can check this if you want to set a maximum wait time for a one-sided call.
     */ get open() {
          return this._open;
      }
      constructor(/**
       * The ID of the peer on the other end of this connection.
       */ peer, provider, options){
          super();
          this.peer = peer;
          this.provider = provider;
          this.options = options;
          this._open = false;
          this.metadata = options.metadata;
      }
  }
  
  
  class $b568d66a5799a705$export$4a84e95a2324ac29 extends (0, $e7e1c6f19b5349be$export$23a2a68283c24d80) {
      /**
     * For media connections, this is always 'media'.
     */ get type() {
          return (0, $200acda04d260725$export$3157d57b4135e3bc).Media;
      }
      get localStream() {
          return this._localStream;
      }
      get remoteStream() {
          return this._remoteStream;
      }
      /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {
          this.dataChannel = dc;
          this.dataChannel.onopen = ()=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);
              this.emit("willCloseOnRemote");
          };
          this.dataChannel.onclose = ()=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);
              this.close();
          };
      }
      addStream(remoteStream) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log("Receiving stream", remoteStream);
          this._remoteStream = remoteStream;
          super.emit("stream", remoteStream); // Should we call this `open`?
      }
      /**
     * @internal
     */ handleMessage(message) {
          const type = message.type;
          const payload = message.payload;
          switch(message.type){
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Answer:
                  // Forward to negotiator
                  this._negotiator.handleSDP(type, payload.sdp);
                  this._open = true;
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Candidate:
                  this._negotiator.handleCandidate(payload.candidate);
                  break;
              default:
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn(`Unrecognized message type:${type} from peer:${this.peer}`);
                  break;
          }
      }
      /**
       * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call
       * `answer` on the media connection provided by the callback to accept the call
       * and optionally send your own media stream.
  
       *
       * @param stream A WebRTC media stream.
       * @param options
       * @returns
       */ answer(stream, options = {}) {
          if (this._localStream) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
              return;
          }
          this._localStream = stream;
          if (options && options.sdpTransform) this.options.sdpTransform = options.sdpTransform;
          this._negotiator.startConnection({
              ...this.options._payload,
              _stream: stream
          });
          // Retrieve lost messages stored because PeerConnection not set up.
          const messages = this.provider._getMessages(this.connectionId);
          for (const message of messages)this.handleMessage(message);
          this._open = true;
      }
      /**
     * Exposed functionality for users.
     */ /**
     * Closes the media connection.
     */ close() {
          if (this._negotiator) {
              this._negotiator.cleanup();
              this._negotiator = null;
          }
          this._localStream = null;
          this._remoteStream = null;
          if (this.provider) {
              this.provider._removeConnection(this);
              this.provider = null;
          }
          if (this.options && this.options._stream) this.options._stream = null;
          if (!this.open) return;
          this._open = false;
          super.emit("close");
      }
      constructor(peerId, provider, options){
          super(peerId, provider, options);
          this._localStream = this.options._stream;
          this.connectionId = this.options.connectionId || $b568d66a5799a705$export$4a84e95a2324ac29.ID_PREFIX + (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).randomToken();
          this._negotiator = new (0, $09f4090c200a4747$export$89e6bb5ad64bf4a)(this);
          if (this._localStream) this._negotiator.startConnection({
              _stream: this._localStream,
              originator: true
          });
      }
  }
  $b568d66a5799a705$export$4a84e95a2324ac29.ID_PREFIX = "mc_";
  
  
  
  
  
  
  class $916c68e858bb49ef$export$2c4e825dc9120f87 {
      _buildRequest(method) {
          const protocol = this._options.secure ? "https" : "http";
          const { host: host, port: port, path: path, key: key } = this._options;
          const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);
          // TODO: Why timestamp, why random?
          url.searchParams.set("ts", `${Date.now()}${Math.random()}`);
          url.searchParams.set("version", (0, $ccd644f7486bf635$exports.version));
          return fetch(url.href, {
              referrerPolicy: this._options.referrerPolicy
          });
      }
      /** Get a unique ID from the server via XHR and initialize with it. */ async retrieveId() {
          try {
              const response = await this._buildRequest("id");
              if (response.status !== 200) throw new Error(`Error. Status:${response.status}`);
              return response.text();
          } catch (error) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("Error retrieving ID", error);
              let pathError = "";
              if (this._options.path === "/" && this._options.host !== (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_HOST) pathError = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.";
              throw new Error("Could not get an ID from the server." + pathError);
          }
      }
      /** @deprecated */ async listAllPeers() {
          try {
              const response = await this._buildRequest("peers");
              if (response.status !== 200) {
                  if (response.status === 401) {
                      let helpfulError = "";
                      if (this._options.host === (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_HOST) helpfulError = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.";
                      else helpfulError = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.";
                      throw new Error("It doesn't look like you have permission to list peers IDs. " + helpfulError);
                  }
                  throw new Error(`Error. Status:${response.status}`);
              }
              return response.json();
          } catch (error) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("Error retrieving list peers", error);
              throw new Error("Could not get list peers from the server." + error);
          }
      }
      constructor(_options){
          this._options = _options;
      }
  }
  
  
  
  
  
  
  
  
  
  
  class $4f9d208d5e349370$export$d365f7ad9d7df9c9 extends (0, $e7e1c6f19b5349be$export$23a2a68283c24d80) {
      get type() {
          return (0, $200acda04d260725$export$3157d57b4135e3bc).Data;
      }
      /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {
          this.dataChannel = dc;
          this.dataChannel.onopen = ()=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);
              this._open = true;
              this.emit("open");
          };
          this.dataChannel.onmessage = (e)=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc onmessage:`, e.data);
          // this._handleDataMessage(e);
          };
          this.dataChannel.onclose = ()=>{
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);
              this.close();
          };
      }
      /**
     * Exposed functionality for users.
     */ /** Allows user to close connection. */ close(options) {
          if (options?.flush) {
              this.send({
                  __peerData: {
                      type: "close"
                  }
              });
              return;
          }
          if (this._negotiator) {
              this._negotiator.cleanup();
              this._negotiator = null;
          }
          if (this.provider) {
              this.provider._removeConnection(this);
              this.provider = null;
          }
          if (this.dataChannel) {
              this.dataChannel.onopen = null;
              this.dataChannel.onmessage = null;
              this.dataChannel.onclose = null;
              this.dataChannel = null;
          }
          if (!this.open) return;
          this._open = false;
          super.emit("close");
      }
      /** Allows user to send data. */ send(data, chunked = false) {
          if (!this.open) {
              this.emitError((0, $200acda04d260725$export$49ae800c114df41d).NotOpenYet, "Connection is not open. You should listen for the `open` event before sending messages.");
              return;
          }
          return this._send(data, chunked);
      }
      async handleMessage(message) {
          const payload = message.payload;
          switch(message.type){
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Answer:
                  await this._negotiator.handleSDP(message.type, payload.sdp);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Candidate:
                  await this._negotiator.handleCandidate(payload.candidate);
                  break;
              default:
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn("Unrecognized message type:", message.type, "from peer:", this.peer);
                  break;
          }
      }
      constructor(peerId, provider, options){
          super(peerId, provider, options);
          this.connectionId = this.options.connectionId || $4f9d208d5e349370$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $eb24a05d5e66c1f6$export$4e61f672936bec77)();
          this.label = this.options.label || this.connectionId;
          this.reliable = !!this.options.reliable;
          this._negotiator = new (0, $09f4090c200a4747$export$89e6bb5ad64bf4a)(this);
          this._negotiator.startConnection(this.options._payload || {
              originator: true,
              reliable: this.reliable
          });
      }
  }
  $4f9d208d5e349370$export$d365f7ad9d7df9c9.ID_PREFIX = "dc_";
  $4f9d208d5e349370$export$d365f7ad9d7df9c9.MAX_BUFFERED_AMOUNT = 8388608;
  
  
  class $5a8a3892973da73a$export$ff7c9d4c11d94e8b extends (0, $4f9d208d5e349370$export$d365f7ad9d7df9c9) {
      get bufferSize() {
          return this._bufferSize;
      }
      _initializeDataChannel(dc) {
          super._initializeDataChannel(dc);
          this.dataChannel.binaryType = "arraybuffer";
          this.dataChannel.addEventListener("message", (e)=>this._handleDataMessage(e));
      }
      _bufferedSend(msg) {
          if (this._buffering || !this._trySend(msg)) {
              this._buffer.push(msg);
              this._bufferSize = this._buffer.length;
          }
      }
      // Returns true if the send succeeds.
      _trySend(msg) {
          if (!this.open) return false;
          if (this.dataChannel.bufferedAmount > (0, $4f9d208d5e349370$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT) {
              this._buffering = true;
              setTimeout(()=>{
                  this._buffering = false;
                  this._tryBuffer();
              }, 50);
              return false;
          }
          try {
              this.dataChannel.send(msg);
          } catch (e) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);
              this._buffering = true;
              this.close();
              return false;
          }
          return true;
      }
      // Try to send the first message in the buffer.
      _tryBuffer() {
          if (!this.open) return;
          if (this._buffer.length === 0) return;
          const msg = this._buffer[0];
          if (this._trySend(msg)) {
              this._buffer.shift();
              this._bufferSize = this._buffer.length;
              this._tryBuffer();
          }
      }
      close(options) {
          if (options?.flush) {
              this.send({
                  __peerData: {
                      type: "close"
                  }
              });
              return;
          }
          this._buffer = [];
          this._bufferSize = 0;
          super.close();
      }
      constructor(...args){
          super(...args);
          this._buffer = [];
          this._bufferSize = 0;
          this._buffering = false;
      }
  }
  
  
  
  
  class $e27c324aebf32a14$export$f0a5a64d5bb37108 extends (0, $5a8a3892973da73a$export$ff7c9d4c11d94e8b) {
      close(options) {
          super.close(options);
          this._chunkedData = {};
      }
      // Handles a DataChannel message.
      _handleDataMessage({ data: data }) {
          const deserializedData = (0, $41cdfe0a3ede2608$export$417857010dc9287f)(data);
          // PeerJS specific message
          const peerData = deserializedData["__peerData"];
          if (peerData) {
              if (peerData.type === "close") {
                  this.close();
                  return;
              }
              // Chunked data -- piece things back together.
              // @ts-ignore
              this._handleChunk(deserializedData);
              return;
          }
          this.emit("data", deserializedData);
      }
      _handleChunk(data) {
          const id = data.__peerData;
          const chunkInfo = this._chunkedData[id] || {
              data: [],
              count: 0,
              total: data.total
          };
          chunkInfo.data[data.n] = new Uint8Array(data.data);
          chunkInfo.count++;
          this._chunkedData[id] = chunkInfo;
          if (chunkInfo.total === chunkInfo.count) {
              // Clean up before making the recursive call to `_handleDataMessage`.
              delete this._chunkedData[id];
              // We've received all the chunks--time to construct the complete data.
              // const data = new Blob(chunkInfo.data);
              const data = (0, $337647a69164cf0a$export$52c89ebcdc4f53f2)(chunkInfo.data);
              this._handleDataMessage({
                  data: data
              });
          }
      }
      _send(data, chunked) {
          const blob = (0, $41cdfe0a3ede2608$export$2a703dbb0cb35339)(data);
          if (blob instanceof Promise) return this._send_blob(blob);
          if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {
              this._sendChunks(blob);
              return;
          }
          this._bufferedSend(blob);
      }
      async _send_blob(blobPromise) {
          const blob = await blobPromise;
          if (blob.byteLength > this.chunker.chunkedMTU) {
              this._sendChunks(blob);
              return;
          }
          this._bufferedSend(blob);
      }
      _sendChunks(blob) {
          const blobs = this.chunker.chunk(blob);
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);
          for (const blob of blobs)this.send(blob, true);
      }
      constructor(peerId, provider, options){
          super(peerId, provider, options);
          this.chunker = new (0, $337647a69164cf0a$export$f1c5f4c9cb95390b)();
          this.serialization = (0, $200acda04d260725$export$89f507cf986a947).Binary;
          this._chunkedData = {};
      }
  }
  
  
  
  
  class $f1ddf74f51c0f6f4$export$6f88fe47d32c9c94 extends (0, $5a8a3892973da73a$export$ff7c9d4c11d94e8b) {
      _handleDataMessage({ data: data }) {
          super.emit("data", data);
      }
      _send(data, _chunked) {
          this._bufferedSend(data);
      }
      constructor(...args){
          super(...args);
          this.serialization = (0, $200acda04d260725$export$89f507cf986a947).None;
      }
  }
  
  
  
  
  
  class $c051ae28a1212d1c$export$48880ac635f47186 extends (0, $5a8a3892973da73a$export$ff7c9d4c11d94e8b) {
      // Handles a DataChannel message.
      _handleDataMessage({ data: data }) {
          const deserializedData = this.parse(this.decoder.decode(data));
          // PeerJS specific message
          const peerData = deserializedData["__peerData"];
          if (peerData && peerData.type === "close") {
              this.close();
              return;
          }
          this.emit("data", deserializedData);
      }
      _send(data, _chunked) {
          const encodedData = this.encoder.encode(this.stringify(data));
          if (encodedData.byteLength >= (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).chunkedMTU) {
              this.emitError((0, $200acda04d260725$export$49ae800c114df41d).MessageToBig, "Message too big for JSON channel");
              return;
          }
          this._bufferedSend(encodedData);
      }
      constructor(...args){
          super(...args);
          this.serialization = (0, $200acda04d260725$export$89f507cf986a947).JSON;
          this.encoder = new TextEncoder();
          this.decoder = new TextDecoder();
          this.stringify = JSON.stringify;
          this.parse = JSON.parse;
      }
  }
  
  
  
  class $400fc96dabc502a5$var$PeerOptions {
  }
  class $400fc96dabc502a5$export$ecd1fc136c422448 extends (0, $a084ca3b0aa8dd08$export$6a678e589c8a4542) {
      /**
     * The brokering ID of this peer
     *
     * If no ID was specified in {@apilink Peer | the constructor},
     * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.
     */ get id() {
          return this._id;
      }
      get options() {
          return this._options;
      }
      get open() {
          return this._open;
      }
      /**
     * @internal
     */ get socket() {
          return this._socket;
      }
      /**
     * A hash of all connections associated with this peer, keyed by the remote peer's ID.
     * @deprecated
     * Return type will change from Object to Map<string,[]>
     */ get connections() {
          const plainConnections = Object.create(null);
          for (const [k, v] of this._connections)plainConnections[k] = v;
          return plainConnections;
      }
      /**
     * true if this peer and all of its connections can no longer be used.
     */ get destroyed() {
          return this._destroyed;
      }
      /**
     * false if there is an active connection to the PeerServer.
     */ get disconnected() {
          return this._disconnected;
      }
      _createServerConnection() {
          const socket = new (0, $9dca0f9415f15a97$export$4798917dbf149b79)(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
          socket.on((0, $200acda04d260725$export$3b5c4a4b6354f023).Message, (data)=>{
              this._handleMessage(data);
          });
          socket.on((0, $200acda04d260725$export$3b5c4a4b6354f023).Error, (error)=>{
              this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).SocketError, error);
          });
          socket.on((0, $200acda04d260725$export$3b5c4a4b6354f023).Disconnected, ()=>{
              if (this.disconnected) return;
              this.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).Network, "Lost connection to server.");
              this.disconnect();
          });
          socket.on((0, $200acda04d260725$export$3b5c4a4b6354f023).Close, ()=>{
              if (this.disconnected) return;
              this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).SocketClosed, "Underlying socket is already closed.");
          });
          return socket;
      }
      /** Initialize a connection with the server. */ _initialize(id) {
          this._id = id;
          this.socket.start(id, this._options.token);
      }
      /** Handles messages from the server. */ _handleMessage(message) {
          const type = message.type;
          const payload = message.payload;
          const peerId = message.src;
          switch(type){
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Open:
                  this._lastServerId = this.id;
                  this._open = true;
                  this.emit("open", this.id);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Error:
                  this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).ServerError, payload.msg);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).IdTaken:
                  this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).UnavailableID, `ID "${this.id}" is taken`);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).InvalidKey:
                  this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).InvalidKey, `API KEY "${this._options.key}" is invalid`);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Leave:
                  (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Received leave message from ${peerId}`);
                  this._cleanupPeer(peerId);
                  this._connections.delete(peerId);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Expire:
                  this.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).PeerUnavailable, `Could not connect to peer ${peerId}`);
                  break;
              case (0, $200acda04d260725$export$adb4a1754da6f10d).Offer:
                  {
                      // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
                      const connectionId = payload.connectionId;
                      let connection = this.getConnection(peerId, connectionId);
                      if (connection) {
                          connection.close();
                          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn(`Offer received for existing Connection ID:${connectionId}`);
                      }
                      // Create a new connection.
                      if (payload.type === (0, $200acda04d260725$export$3157d57b4135e3bc).Media) {
                          const mediaConnection = new (0, $b568d66a5799a705$export$4a84e95a2324ac29)(peerId, this, {
                              connectionId: connectionId,
                              _payload: payload,
                              metadata: payload.metadata
                          });
                          connection = mediaConnection;
                          this._addConnection(peerId, connection);
                          this.emit("call", mediaConnection);
                      } else if (payload.type === (0, $200acda04d260725$export$3157d57b4135e3bc).Data) {
                          const dataConnection = new this._serializers[payload.serialization](peerId, this, {
                              connectionId: connectionId,
                              _payload: payload,
                              metadata: payload.metadata,
                              label: payload.label,
                              serialization: payload.serialization,
                              reliable: payload.reliable
                          });
                          connection = dataConnection;
                          this._addConnection(peerId, connection);
                          this.emit("connection", dataConnection);
                      } else {
                          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn(`Received malformed connection type:${payload.type}`);
                          return;
                      }
                      // Find messages.
                      const messages = this._getMessages(connectionId);
                      for (const message of messages)connection.handleMessage(message);
                      break;
                  }
              default:
                  {
                      if (!payload) {
                          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn(`You received a malformed message from ${peerId} of type ${type}`);
                          return;
                      }
                      const connectionId = payload.connectionId;
                      const connection = this.getConnection(peerId, connectionId);
                      if (connection && connection.peerConnection) // Pass it on.
                      connection.handleMessage(message);
                      else if (connectionId) // Store for possible later use
                      this._storeMessage(connectionId, message);
                      else (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn("You received an unrecognized message:", message);
                      break;
                  }
          }
      }
      /** Stores messages without a set up connection, to be claimed later. */ _storeMessage(connectionId, message) {
          if (!this._lostMessages.has(connectionId)) this._lostMessages.set(connectionId, []);
          this._lostMessages.get(connectionId).push(message);
      }
      /**
     * Retrieve messages from lost message store
     * @internal
     */ //TODO Change it to private
      _getMessages(connectionId) {
          const messages = this._lostMessages.get(connectionId);
          if (messages) {
              this._lostMessages.delete(connectionId);
              return messages;
          }
          return [];
      }
      /**
     * Connects to the remote peer specified by id and returns a data connection.
     * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).
     * @param options for specifying details about Peer Connection
     */ connect(peer, options = {}) {
          options = {
              serialization: "default",
              ...options
          };
          if (this.disconnected) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.");
              this.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).Disconnected, "Cannot connect to new Peer after disconnecting from server.");
              return;
          }
          const dataConnection = new this._serializers[options.serialization](peer, this, options);
          this._addConnection(peer, dataConnection);
          return dataConnection;
      }
      /**
     * Calls the remote peer specified by id and returns a media connection.
     * @param peer The brokering ID of the remote peer (their peer.id).
     * @param stream The caller's media stream
     * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
     */ call(peer, stream, options = {}) {
          if (this.disconnected) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.");
              this.emitError((0, $200acda04d260725$export$9547aaa2e39030ff).Disconnected, "Cannot connect to new Peer after disconnecting from server.");
              return;
          }
          if (!stream) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
              return;
          }
          const mediaConnection = new (0, $b568d66a5799a705$export$4a84e95a2324ac29)(peer, this, {
              ...options,
              _stream: stream
          });
          this._addConnection(peer, mediaConnection);
          return mediaConnection;
      }
      /** Add a data/media connection to this peer. */ _addConnection(peerId, connection) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);
          if (!this._connections.has(peerId)) this._connections.set(peerId, []);
          this._connections.get(peerId).push(connection);
      }
      //TODO should be private
      _removeConnection(connection) {
          const connections = this._connections.get(connection.peer);
          if (connections) {
              const index = connections.indexOf(connection);
              if (index !== -1) connections.splice(index, 1);
          }
          //remove from lost messages
          this._lostMessages.delete(connection.connectionId);
      }
      /** Retrieve a data/media connection for this peer. */ getConnection(peerId, connectionId) {
          const connections = this._connections.get(peerId);
          if (!connections) return null;
          for (const connection of connections){
              if (connection.connectionId === connectionId) return connection;
          }
          return null;
      }
      _delayedAbort(type, message) {
          setTimeout(()=>{
              this._abort(type, message);
          }, 0);
      }
      /**
     * Emits an error message and destroys the Peer.
     * The Peer is not destroyed if it's in a disconnected state, in which case
     * it retains its disconnected state and its existing connections.
     */ _abort(type, message) {
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("Aborting!");
          this.emitError(type, message);
          if (!this._lastServerId) this.destroy();
          else this.disconnect();
      }
      /**
     * Destroys the Peer: closes all active connections as well as the connection
     * to the server.
     *
     * :::caution
     * This cannot be undone; the respective peer object will no longer be able
     * to create or receive any connections, its ID will be forfeited on the server,
     * and all of its data and media connections will be closed.
     * :::
     */ destroy() {
          if (this.destroyed) return;
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Destroy peer with ID:${this.id}`);
          this.disconnect();
          this._cleanup();
          this._destroyed = true;
          this.emit("close");
      }
      /** Disconnects every connection on this peer. */ _cleanup() {
          for (const peerId of this._connections.keys()){
              this._cleanupPeer(peerId);
              this._connections.delete(peerId);
          }
          this.socket.removeAllListeners();
      }
      /** Closes all connections to this peer. */ _cleanupPeer(peerId) {
          const connections = this._connections.get(peerId);
          if (!connections) return;
          for (const connection of connections)connection.close();
      }
      /**
     * Disconnects the Peer's connection to the PeerServer. Does not close any
     *  active connections.
     * Warning: The peer can no longer create or accept connections after being
     *  disconnected. It also cannot reconnect to the server.
     */ disconnect() {
          if (this.disconnected) return;
          const currentId = this.id;
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Disconnect peer with ID:${currentId}`);
          this._disconnected = true;
          this._open = false;
          this.socket.close();
          this._lastServerId = currentId;
          this._id = null;
          this.emit("disconnected", currentId);
      }
      /** Attempts to reconnect with the same ID.
     *
     * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.
     * Destroyed peers cannot be reconnected.
     * If the connection fails (as an example, if the peer's old ID is now taken),
     * the peer's existing connections will not close, but any associated errors events will fire.
     */ reconnect() {
          if (this.disconnected && !this.destroyed) {
              (0, $6adb9b697958aa01$export$2e2bcd8739ae039).log(`Attempting reconnection to server with ID ${this._lastServerId}`);
              this._disconnected = false;
              this._initialize(this._lastServerId);
          } else if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
          else if (!this.disconnected && !this.open) // Do nothing. We're still connecting the first time.
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).error("In a hurry? We're still trying to make the initial connection!");
          else throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);
      }
      /**
     * Get a list of available peer IDs. If you're running your own server, you'll
     * want to set allow_discovery: true in the PeerServer options. If you're using
     * the cloud server, email team@peerjs.com to get the functionality enabled for
     * your key.
     */ listAllPeers(cb = (_)=>{}) {
          this._api.listAllPeers().then((peers)=>cb(peers)).catch((error)=>this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).ServerError, error));
      }
      constructor(id, options){
          super();
          this._serializers = {
              raw: (0, $f1ddf74f51c0f6f4$export$6f88fe47d32c9c94),
              json: (0, $c051ae28a1212d1c$export$48880ac635f47186),
              binary: (0, $e27c324aebf32a14$export$f0a5a64d5bb37108),
              "binary-utf8": (0, $e27c324aebf32a14$export$f0a5a64d5bb37108),
              default: (0, $e27c324aebf32a14$export$f0a5a64d5bb37108)
          };
          this._id = null;
          this._lastServerId = null;
          // States.
          this._destroyed = false // Connections have been killed
          ;
          this._disconnected = false // Connection to PeerServer killed but P2P connections still active
          ;
          this._open = false // Sockets and such are not yet open.
          ;
          this._connections = new Map() // All connections for this peer.
          ;
          this._lostMessages = new Map() // src => [list of messages]
          ;
          let userId;
          // Deal with overloading
          if (id && id.constructor == Object) options = id;
          else if (id) userId = id.toString();
          // Configurize options
          options = {
              debug: 0,
              host: (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_HOST,
              port: (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_PORT,
              path: "/",
              key: $400fc96dabc502a5$export$ecd1fc136c422448.DEFAULT_KEY,
              token: (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).randomToken(),
              config: (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).defaultConfig,
              referrerPolicy: "strict-origin-when-cross-origin",
              serializers: {},
              ...options
          };
          this._options = options;
          this._serializers = {
              ...this._serializers,
              ...this.options.serializers
          };
          // Detect relative URL host.
          if (this._options.host === "/") this._options.host = window.location.hostname;
          // Set path correctly.
          if (this._options.path) {
              if (this._options.path[0] !== "/") this._options.path = "/" + this._options.path;
              if (this._options.path[this._options.path.length - 1] !== "/") this._options.path += "/";
          }
          // Set whether we use SSL to same as current host
          if (this._options.secure === undefined && this._options.host !== (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).isSecure();
          else if (this._options.host == (0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = true;
          // Set a custom log function if present
          if (this._options.logFunction) (0, $6adb9b697958aa01$export$2e2bcd8739ae039).setLogFunction(this._options.logFunction);
          (0, $6adb9b697958aa01$export$2e2bcd8739ae039).logLevel = this._options.debug || 0;
          this._api = new (0, $916c68e858bb49ef$export$2c4e825dc9120f87)(options);
          this._socket = this._createServerConnection();
          // Sanity checks
          // Ensure WebRTC supported
          if (!(0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).supports.audioVideo && !(0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).supports.data) {
              this._delayedAbort((0, $200acda04d260725$export$9547aaa2e39030ff).BrowserIncompatible, "The current browser does not support WebRTC");
              return;
          }
          // Ensure alphanumeric id
          if (!!userId && !(0, $0c88dccd73f5641e$export$7debb50ef11d5e0b).validateId(userId)) {
              this._delayedAbort((0, $200acda04d260725$export$9547aaa2e39030ff).InvalidID, `ID "${userId}" is invalid`);
              return;
          }
          if (userId) this._initialize(userId);
          else this._api.retrieveId().then((id)=>this._initialize(id)).catch((error)=>this._abort((0, $200acda04d260725$export$9547aaa2e39030ff).ServerError, error));
      }
  }
  $400fc96dabc502a5$export$ecd1fc136c422448.DEFAULT_KEY = "peerjs";
  
  
  window.peerjs = {
      Peer: $400fc96dabc502a5$export$ecd1fc136c422448,
      util: $0c88dccd73f5641e$export$7debb50ef11d5e0b
  };
  /** @deprecated Should use peerjs namespace */ window.Peer = (0, $400fc96dabc502a5$export$ecd1fc136c422448);
  
  })();
  //# sourceMappingURL=peerjs.min.js.map
  ",
  "import { util } from "./util";
  import { Peer } from "./peer";
  
  (<any>window).peerjs = {
    Peer,
    util,
  };
  /** @deprecated Should use peerjs namespace */
  (<any>window).Peer = Peer;
  ",
  "import { BinaryPackChunker } from "./dataconnection/BufferedConnection/binaryPackChunker";
  import * as BinaryPack from "peerjs-js-binarypack";
  import { Supports } from "./supports";
  import { validateId } from "./utils/validateId";
  import { randomToken } from "./utils/randomToken";
  
  export interface UtilSupportsObj {
    /**
     * The current browser.
     * This property can be useful in determining whether two peers can connect.
     *
     * ```ts
     * if (util.browser === 'firefox') {
     *  // OK to peer with Firefox peers.
     * }
     * ```
     *
     * `util.browser` can currently have the values
     * `'firefox', 'chrome', 'safari', 'edge', 'Not a supported browser.', 'Not a browser.' (unknown WebRTC-compatible agent).
     */
    browser: boolean;
    webRTC: boolean;
    /**
     * True if the current browser supports media streams and PeerConnection.
     */
    audioVideo: boolean;
    /**
     * True if the current browser supports DataChannel and PeerConnection.
     */
    data: boolean;
    binaryBlob: boolean;
    /**
     * True if the current browser supports reliable DataChannels.
     */
    reliable: boolean;
  }
  
  const DEFAULT_CONFIG = {
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      {
        urls: [
          "turn:eu-0.turn.peerjs.com:3478",
          "turn:us-0.turn.peerjs.com:3478",
        ],
        username: "peerjs",
        credential: "peerjsp",
      },
    ],
    sdpSemantics: "unified-plan",
  };
  
  export class Util extends BinaryPackChunker {
    noop(): void {}
  
    readonly CLOUD_HOST = "0.peerjs.com";
    readonly CLOUD_PORT = 443;
  
    // Browsers that need chunking:
    readonly chunkedBrowsers = { Chrome: 1, chrome: 1 };
  
    // Returns browser-agnostic default config
    readonly defaultConfig = DEFAULT_CONFIG;
  
    readonly browser = Supports.getBrowser();
    readonly browserVersion = Supports.getVersion();
  
    pack = BinaryPack.pack;
    unpack = BinaryPack.unpack;
  
    /**
     * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.
     *
     * :::caution
     * Only the properties documented here are guaranteed to be present on `util.supports`
     * :::
     */
    readonly supports = (function () {
      const supported: UtilSupportsObj = {
        browser: Supports.isBrowserSupported(),
        webRTC: Supports.isWebRTCSupported(),
        audioVideo: false,
        data: false,
        binaryBlob: false,
        reliable: false,
      };
  
      if (!supported.webRTC) return supported;
  
      let pc: RTCPeerConnection;
  
      try {
        pc = new RTCPeerConnection(DEFAULT_CONFIG);
  
        supported.audioVideo = true;
  
        let dc: RTCDataChannel;
  
        try {
          dc = pc.createDataChannel("_PEERJSTEST", { ordered: true });
          supported.data = true;
          supported.reliable = !!dc.ordered;
  
          // Binary test
          try {
            dc.binaryType = "blob";
            supported.binaryBlob = !Supports.isIOS;
          } catch (e) {}
        } catch (e) {
        } finally {
          if (dc) {
            dc.close();
          }
        }
      } catch (e) {
      } finally {
        if (pc) {
          pc.close();
        }
      }
  
      return supported;
    })();
  
    // Ensure alphanumeric ids
    validateId = validateId;
    randomToken = randomToken;
  
    blobToArrayBuffer(
      blob: Blob,
      cb: (arg: ArrayBuffer | null) => void,
    ): FileReader {
      const fr = new FileReader();
  
      fr.onload = function (evt) {
        if (evt.target) {
          cb(evt.target.result as ArrayBuffer);
        }
      };
  
      fr.readAsArrayBuffer(blob);
  
      return fr;
    }
  
    binaryStringToArrayBuffer(binary: string): ArrayBuffer | SharedArrayBuffer {
      const byteArray = new Uint8Array(binary.length);
  
      for (let i = 0; i < binary.length; i++) {
        byteArray[i] = binary.charCodeAt(i) & 0xff;
      }
  
      return byteArray.buffer;
    }
    isSecure(): boolean {
      return location.protocol === "https:";
    }
  }
  
  /**
   * Provides a variety of helpful utilities.
   *
   * :::caution
   * Only the utilities documented here are guaranteed to be present on `util`.
   * Undocumented utilities can be removed without warning.
   * We don't consider these to be breaking changes.
   * :::
   */
  export const util = new Util();
  ",
  "export class BinaryPackChunker {
    readonly chunkedMTU = 16300; // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.
  
    // Binary stuff
  
    private _dataCount: number = 1;
  
    chunk = (
      blob: ArrayBuffer,
    ): { __peerData: number; n: number; total: number; data: Uint8Array }[] => {
      const chunks = [];
      const size = blob.byteLength;
      const total = Math.ceil(size / this.chunkedMTU);
  
      let index = 0;
      let start = 0;
  
      while (start < size) {
        const end = Math.min(size, start + this.chunkedMTU);
        const b = blob.slice(start, end);
  
        const chunk = {
          __peerData: this._dataCount,
          n: index,
          data: b,
          total,
        };
  
        chunks.push(chunk);
  
        start = end;
        index++;
      }
  
      this._dataCount++;
  
      return chunks;
    };
  }
  
  export function concatArrayBuffers(bufs: Uint8Array[]) {
    let size = 0;
    for (const buf of bufs) {
      size += buf.byteLength;
    }
    const result = new Uint8Array(size);
    let offset = 0;
    for (const buf of bufs) {
      result.set(buf, offset);
      offset += buf.byteLength;
    }
    return result;
  }
  ",
  "class $e8379818650e2442$export$93654d4f2d6cd524 {
      constructor(){
          this.encoder = new TextEncoder();
          this._pieces = [];
          this._parts = [];
      }
      append_buffer(data) {
          this.flush();
          this._parts.push(data);
      }
      append(data) {
          this._pieces.push(data);
      }
      flush() {
          if (this._pieces.length > 0) {
              const buf = new Uint8Array(this._pieces);
              this._parts.push(buf);
              this._pieces = [];
          }
      }
      toArrayBuffer() {
          const buffer = [];
          for (const part of this._parts)buffer.push(part);
          return $e8379818650e2442$var$concatArrayBuffers(buffer).buffer;
      }
  }
  function $e8379818650e2442$var$concatArrayBuffers(bufs) {
      let size = 0;
      for (const buf of bufs)size += buf.byteLength;
      const result = new Uint8Array(size);
      let offset = 0;
      for (const buf of bufs){
          const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
          result.set(view, offset);
          offset += buf.byteLength;
      }
      return result;
  }
  
  
  function $0cfd7828ad59115f$export$417857010dc9287f(data) {
      const unpacker = new $0cfd7828ad59115f$var$Unpacker(data);
      return unpacker.unpack();
  }
  function $0cfd7828ad59115f$export$2a703dbb0cb35339(data) {
      const packer = new $0cfd7828ad59115f$export$b9ec4b114aa40074();
      const res = packer.pack(data);
      if (res instanceof Promise) return res.then(()=>packer.getBuffer());
      return packer.getBuffer();
  }
  class $0cfd7828ad59115f$var$Unpacker {
      constructor(data){
          this.index = 0;
          this.dataBuffer = data;
          this.dataView = new Uint8Array(this.dataBuffer);
          this.length = this.dataBuffer.byteLength;
      }
      unpack() {
          const type = this.unpack_uint8();
          if (type < 0x80) return type;
          else if ((type ^ 0xe0) < 0x20) return (type ^ 0xe0) - 0x20;
          let size;
          if ((size = type ^ 0xa0) <= 0x0f) return this.unpack_raw(size);
          else if ((size = type ^ 0xb0) <= 0x0f) return this.unpack_string(size);
          else if ((size = type ^ 0x90) <= 0x0f) return this.unpack_array(size);
          else if ((size = type ^ 0x80) <= 0x0f) return this.unpack_map(size);
          switch(type){
              case 0xc0:
                  return null;
              case 0xc1:
                  return undefined;
              case 0xc2:
                  return false;
              case 0xc3:
                  return true;
              case 0xca:
                  return this.unpack_float();
              case 0xcb:
                  return this.unpack_double();
              case 0xcc:
                  return this.unpack_uint8();
              case 0xcd:
                  return this.unpack_uint16();
              case 0xce:
                  return this.unpack_uint32();
              case 0xcf:
                  return this.unpack_uint64();
              case 0xd0:
                  return this.unpack_int8();
              case 0xd1:
                  return this.unpack_int16();
              case 0xd2:
                  return this.unpack_int32();
              case 0xd3:
                  return this.unpack_int64();
              case 0xd4:
                  return undefined;
              case 0xd5:
                  return undefined;
              case 0xd6:
                  return undefined;
              case 0xd7:
                  return undefined;
              case 0xd8:
                  size = this.unpack_uint16();
                  return this.unpack_string(size);
              case 0xd9:
                  size = this.unpack_uint32();
                  return this.unpack_string(size);
              case 0xda:
                  size = this.unpack_uint16();
                  return this.unpack_raw(size);
              case 0xdb:
                  size = this.unpack_uint32();
                  return this.unpack_raw(size);
              case 0xdc:
                  size = this.unpack_uint16();
                  return this.unpack_array(size);
              case 0xdd:
                  size = this.unpack_uint32();
                  return this.unpack_array(size);
              case 0xde:
                  size = this.unpack_uint16();
                  return this.unpack_map(size);
              case 0xdf:
                  size = this.unpack_uint32();
                  return this.unpack_map(size);
          }
      }
      unpack_uint8() {
          const byte = this.dataView[this.index] & 0xff;
          this.index++;
          return byte;
      }
      unpack_uint16() {
          const bytes = this.read(2);
          const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);
          this.index += 2;
          return uint16;
      }
      unpack_uint32() {
          const bytes = this.read(4);
          const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
          this.index += 4;
          return uint32;
      }
      unpack_uint64() {
          const bytes = this.read(8);
          const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
          this.index += 8;
          return uint64;
      }
      unpack_int8() {
          const uint8 = this.unpack_uint8();
          return uint8 < 0x80 ? uint8 : uint8 - 256;
      }
      unpack_int16() {
          const uint16 = this.unpack_uint16();
          return uint16 < 0x8000 ? uint16 : uint16 - 65536;
      }
      unpack_int32() {
          const uint32 = this.unpack_uint32();
          return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;
      }
      unpack_int64() {
          const uint64 = this.unpack_uint64();
          return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;
      }
      unpack_raw(size) {
          if (this.length < this.index + size) throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`);
          const buf = this.dataBuffer.slice(this.index, this.index + size);
          this.index += size;
          return buf;
      }
      unpack_string(size) {
          const bytes = this.read(size);
          let i = 0;
          let str = "";
          let c;
          let code;
          while(i < size){
              c = bytes[i];
              // The length of a UTF-8 sequence is specified in the first byte:
              // 0xxxxxxx means length 1,
              // 110xxxxx means length 2,
              // 1110xxxx means length 3,
              // 11110xxx means length 4.
              // 10xxxxxx is for non-initial bytes.
              if (c < 0xa0) {
                  // One-byte sequence: bits 0xxxxxxx
                  code = c;
                  i++;
              } else if ((c ^ 0xc0) < 0x20) {
                  // Two-byte sequence: bits 110xxxxx 10xxxxxx
                  code = (c & 0x1f) << 6 | bytes[i + 1] & 0x3f;
                  i += 2;
              } else if ((c ^ 0xe0) < 0x10) {
                  // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx
                  code = (c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f;
                  i += 3;
              } else {
                  // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                  code = (c & 0x07) << 18 | (bytes[i + 1] & 0x3f) << 12 | (bytes[i + 2] & 0x3f) << 6 | bytes[i + 3] & 0x3f;
                  i += 4;
              }
              str += String.fromCodePoint(code);
          }
          this.index += size;
          return str;
      }
      unpack_array(size) {
          const objects = new Array(size);
          for(let i = 0; i < size; i++)objects[i] = this.unpack();
          return objects;
      }
      unpack_map(size) {
          const map = {};
          for(let i = 0; i < size; i++){
              const key = this.unpack();
              map[key] = this.unpack();
          }
          return map;
      }
      unpack_float() {
          const uint32 = this.unpack_uint32();
          const sign = uint32 >> 31;
          const exp = (uint32 >> 23 & 0xff) - 127;
          const fraction = uint32 & 0x7fffff | 0x800000;
          return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);
      }
      unpack_double() {
          const h32 = this.unpack_uint32();
          const l32 = this.unpack_uint32();
          const sign = h32 >> 31;
          const exp = (h32 >> 20 & 0x7ff) - 1023;
          const hfrac = h32 & 0xfffff | 0x100000;
          const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);
          return (sign === 0 ? 1 : -1) * frac;
      }
      read(length) {
          const j = this.index;
          if (j + length <= this.length) return this.dataView.subarray(j, j + length);
          else throw new Error("BinaryPackFailure: read index out of range");
      }
  }
  class $0cfd7828ad59115f$export$b9ec4b114aa40074 {
      getBuffer() {
          return this._bufferBuilder.toArrayBuffer();
      }
      pack(value) {
          if (typeof value === "string") this.pack_string(value);
          else if (typeof value === "number") {
              if (Math.floor(value) === value) this.pack_integer(value);
              else this.pack_double(value);
          } else if (typeof value === "boolean") {
              if (value === true) this._bufferBuilder.append(0xc3);
              else if (value === false) this._bufferBuilder.append(0xc2);
          } else if (value === undefined) this._bufferBuilder.append(0xc0);
          else if (typeof value === "object") {
              if (value === null) this._bufferBuilder.append(0xc0);
              else {
                  const constructor = value.constructor;
                  if (value instanceof Array) {
                      const res = this.pack_array(value);
                      if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());
                  } else if (value instanceof ArrayBuffer) this.pack_bin(new Uint8Array(value));
                  else if ("BYTES_PER_ELEMENT" in value) {
                      const v = value;
                      this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
                  } else if (value instanceof Date) this.pack_string(value.toString());
                  else if (value instanceof Blob) return value.arrayBuffer().then((buffer)=>{
                      this.pack_bin(new Uint8Array(buffer));
                      this._bufferBuilder.flush();
                  });
                  else if (constructor == Object || constructor.toString().startsWith("class")) {
                      const res = this.pack_object(value);
                      if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());
                  } else throw new Error(`Type "${constructor.toString()}" not yet supported`);
              }
          } else throw new Error(`Type "${typeof value}" not yet supported`);
          this._bufferBuilder.flush();
      }
      pack_bin(blob) {
          const length = blob.length;
          if (length <= 0x0f) this.pack_uint8(0xa0 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xda);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdb);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          this._bufferBuilder.append_buffer(blob);
      }
      pack_string(str) {
          const encoded = this._textEncoder.encode(str);
          const length = encoded.length;
          if (length <= 0x0f) this.pack_uint8(0xb0 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xd8);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xd9);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          this._bufferBuilder.append_buffer(encoded);
      }
      pack_array(ary) {
          const length = ary.length;
          if (length <= 0x0f) this.pack_uint8(0x90 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xdc);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdd);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          const packNext = (index)=>{
              if (index < length) {
                  const res = this.pack(ary[index]);
                  if (res instanceof Promise) return res.then(()=>packNext(index + 1));
                  return packNext(index + 1);
              }
          };
          return packNext(0);
      }
      pack_integer(num) {
          if (num >= -32 && num <= 0x7f) this._bufferBuilder.append(num & 0xff);
          else if (num >= 0x00 && num <= 0xff) {
              this._bufferBuilder.append(0xcc);
              this.pack_uint8(num);
          } else if (num >= -128 && num <= 0x7f) {
              this._bufferBuilder.append(0xd0);
              this.pack_int8(num);
          } else if (num >= 0x0000 && num <= 0xffff) {
              this._bufferBuilder.append(0xcd);
              this.pack_uint16(num);
          } else if (num >= -32768 && num <= 0x7fff) {
              this._bufferBuilder.append(0xd1);
              this.pack_int16(num);
          } else if (num >= 0x00000000 && num <= 0xffffffff) {
              this._bufferBuilder.append(0xce);
              this.pack_uint32(num);
          } else if (num >= -2147483648 && num <= 0x7fffffff) {
              this._bufferBuilder.append(0xd2);
              this.pack_int32(num);
          } else if (num >= -9223372036854776000 && num <= 0x7fffffffffffffff) {
              this._bufferBuilder.append(0xd3);
              this.pack_int64(num);
          } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {
              this._bufferBuilder.append(0xcf);
              this.pack_uint64(num);
          } else throw new Error("Invalid integer");
      }
      pack_double(num) {
          let sign = 0;
          if (num < 0) {
              sign = 1;
              num = -num;
          }
          const exp = Math.floor(Math.log(num) / Math.LN2);
          const frac0 = num / 2 ** exp - 1;
          const frac1 = Math.floor(frac0 * 2 ** 52);
          const b32 = 2 ** 32;
          const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 0x0fffff;
          const l32 = frac1 % b32;
          this._bufferBuilder.append(0xcb);
          this.pack_int32(h32);
          this.pack_int32(l32);
      }
      pack_object(obj) {
          const keys = Object.keys(obj);
          const length = keys.length;
          if (length <= 0x0f) this.pack_uint8(0x80 + length);
          else if (length <= 0xffff) {
              this._bufferBuilder.append(0xde);
              this.pack_uint16(length);
          } else if (length <= 0xffffffff) {
              this._bufferBuilder.append(0xdf);
              this.pack_uint32(length);
          } else throw new Error("Invalid length");
          const packNext = (index)=>{
              if (index < keys.length) {
                  const prop = keys[index];
                  // eslint-disable-next-line no-prototype-builtins
                  if (obj.hasOwnProperty(prop)) {
                      this.pack(prop);
                      const res = this.pack(obj[prop]);
                      if (res instanceof Promise) return res.then(()=>packNext(index + 1));
                  }
                  return packNext(index + 1);
              }
          };
          return packNext(0);
      }
      pack_uint8(num) {
          this._bufferBuilder.append(num);
      }
      pack_uint16(num) {
          this._bufferBuilder.append(num >> 8);
          this._bufferBuilder.append(num & 0xff);
      }
      pack_uint32(num) {
          const n = num & 0xffffffff;
          this._bufferBuilder.append((n & 0xff000000) >>> 24);
          this._bufferBuilder.append((n & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((n & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(n & 0x000000ff);
      }
      pack_uint64(num) {
          const high = num / 2 ** 32;
          const low = num % 2 ** 32;
          this._bufferBuilder.append((high & 0xff000000) >>> 24);
          this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(high & 0x000000ff);
          this._bufferBuilder.append((low & 0xff000000) >>> 24);
          this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(low & 0x000000ff);
      }
      pack_int8(num) {
          this._bufferBuilder.append(num & 0xff);
      }
      pack_int16(num) {
          this._bufferBuilder.append((num & 0xff00) >> 8);
          this._bufferBuilder.append(num & 0xff);
      }
      pack_int32(num) {
          this._bufferBuilder.append(num >>> 24 & 0xff);
          this._bufferBuilder.append((num & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((num & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(num & 0x000000ff);
      }
      pack_int64(num) {
          const high = Math.floor(num / 2 ** 32);
          const low = num % 2 ** 32;
          this._bufferBuilder.append((high & 0xff000000) >>> 24);
          this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(high & 0x000000ff);
          this._bufferBuilder.append((low & 0xff000000) >>> 24);
          this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
          this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
          this._bufferBuilder.append(low & 0x000000ff);
      }
      constructor(){
          this._bufferBuilder = new (0, $e8379818650e2442$export$93654d4f2d6cd524)();
          this._textEncoder = new TextEncoder();
      }
  }
  
  
  export {$0cfd7828ad59115f$export$417857010dc9287f as unpack, $0cfd7828ad59115f$export$2a703dbb0cb35339 as pack, $0cfd7828ad59115f$export$b9ec4b114aa40074 as Packer};
  //# sourceMappingURL=binarypack.mjs.map
  ",
  "import { BufferBuilder } from "./bufferbuilder";
  
  export type Packable =
    | null
    | undefined
    | string
    | number
    | boolean
    | Date
    | ArrayBuffer
    | Blob
    | Array<Packable>
    | { [key: string]: Packable }
    | ({ BYTES_PER_ELEMENT: number } & ArrayBufferView);
  export type Unpackable =
    | null
    | undefined
    | string
    | number
    | boolean
    | ArrayBuffer
    | Array<Unpackable>
    | { [key: string]: Unpackable };
  
  export function unpack<T extends Unpackable>(data: ArrayBuffer) {
    const unpacker = new Unpacker(data);
    return unpacker.unpack() as T;
  }
  
  export function pack(data: Packable) {
    const packer = new Packer();
    const res = packer.pack(data);
    if (res instanceof Promise) {
      return res.then(() => packer.getBuffer());
    }
    return packer.getBuffer();
  }
  
  class Unpacker {
    private index: number;
    private readonly dataBuffer: ArrayBuffer;
    private readonly dataView: Uint8Array;
    private readonly length: number;
  
    constructor(data: ArrayBuffer) {
      this.index = 0;
      this.dataBuffer = data;
      this.dataView = new Uint8Array(this.dataBuffer);
      this.length = this.dataBuffer.byteLength;
    }
  
    unpack(): Unpackable {
      const type = this.unpack_uint8();
      if (type < 0x80) {
        return type;
      } else if ((type ^ 0xe0) < 0x20) {
        return (type ^ 0xe0) - 0x20;
      }
  
      let size;
      if ((size = type ^ 0xa0) <= 0x0f) {
        return this.unpack_raw(size);
      } else if ((size = type ^ 0xb0) <= 0x0f) {
        return this.unpack_string(size);
      } else if ((size = type ^ 0x90) <= 0x0f) {
        return this.unpack_array(size);
      } else if ((size = type ^ 0x80) <= 0x0f) {
        return this.unpack_map(size);
      }
  
      switch (type) {
        case 0xc0:
          return null;
        case 0xc1:
          return undefined;
        case 0xc2:
          return false;
        case 0xc3:
          return true;
        case 0xca:
          return this.unpack_float();
        case 0xcb:
          return this.unpack_double();
        case 0xcc:
          return this.unpack_uint8();
        case 0xcd:
          return this.unpack_uint16();
        case 0xce:
          return this.unpack_uint32();
        case 0xcf:
          return this.unpack_uint64();
        case 0xd0:
          return this.unpack_int8();
        case 0xd1:
          return this.unpack_int16();
        case 0xd2:
          return this.unpack_int32();
        case 0xd3:
          return this.unpack_int64();
        case 0xd4:
          return undefined;
        case 0xd5:
          return undefined;
        case 0xd6:
          return undefined;
        case 0xd7:
          return undefined;
        case 0xd8:
          size = this.unpack_uint16();
          return this.unpack_string(size);
        case 0xd9:
          size = this.unpack_uint32();
          return this.unpack_string(size);
        case 0xda:
          size = this.unpack_uint16();
          return this.unpack_raw(size);
        case 0xdb:
          size = this.unpack_uint32();
          return this.unpack_raw(size);
        case 0xdc:
          size = this.unpack_uint16();
          return this.unpack_array(size);
        case 0xdd:
          size = this.unpack_uint32();
          return this.unpack_array(size);
        case 0xde:
          size = this.unpack_uint16();
          return this.unpack_map(size);
        case 0xdf:
          size = this.unpack_uint32();
          return this.unpack_map(size);
      }
    }
  
    unpack_uint8() {
      const byte = this.dataView[this.index] & 0xff;
      this.index++;
      return byte;
    }
  
    unpack_uint16() {
      const bytes = this.read(2);
      const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);
      this.index += 2;
      return uint16;
    }
  
    unpack_uint32() {
      const bytes = this.read(4);
      const uint32 =
        ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
      this.index += 4;
      return uint32;
    }
  
    unpack_uint64() {
      const bytes = this.read(8);
      const uint64 =
        ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) *
          256 +
          bytes[4]) *
          256 +
          bytes[5]) *
          256 +
          bytes[6]) *
          256 +
        bytes[7];
      this.index += 8;
      return uint64;
    }
  
    unpack_int8() {
      const uint8 = this.unpack_uint8();
      return uint8 < 0x80 ? uint8 : uint8 - (1 << 8);
    }
  
    unpack_int16() {
      const uint16 = this.unpack_uint16();
      return uint16 < 0x8000 ? uint16 : uint16 - (1 << 16);
    }
  
    unpack_int32() {
      const uint32 = this.unpack_uint32();
      return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;
    }
  
    unpack_int64() {
      const uint64 = this.unpack_uint64();
      return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;
    }
  
    unpack_raw(size: number) {
      if (this.length < this.index + size) {
        throw new Error(
          `BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`,
        );
      }
      const buf = this.dataBuffer.slice(this.index, this.index + size);
      this.index += size;
  
      return buf;
    }
  
    unpack_string(size: number) {
      const bytes = this.read(size);
      let i = 0;
      let str = "";
      let c;
      let code;
  
      while (i < size) {
        c = bytes[i];
        // The length of a UTF-8 sequence is specified in the first byte:
        // 0xxxxxxx means length 1,
        // 110xxxxx means length 2,
        // 1110xxxx means length 3,
        // 11110xxx means length 4.
        // 10xxxxxx is for non-initial bytes.
        if (c < 0xa0) {
          // One-byte sequence: bits 0xxxxxxx
          code = c;
          i++;
        } else if ((c ^ 0xc0) < 0x20) {
          // Two-byte sequence: bits 110xxxxx 10xxxxxx
          code = ((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f);
          i += 2;
        } else if ((c ^ 0xe0) < 0x10) {
          // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx
          code =
            ((c & 0x0f) << 12) |
            ((bytes[i + 1] & 0x3f) << 6) |
            (bytes[i + 2] & 0x3f);
          i += 3;
        } else {
          // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
          code =
            ((c & 0x07) << 18) |
            ((bytes[i + 1] & 0x3f) << 12) |
            ((bytes[i + 2] & 0x3f) << 6) |
            (bytes[i + 3] & 0x3f);
          i += 4;
        }
        str += String.fromCodePoint(code);
      }
  
      this.index += size;
      return str;
    }
  
    unpack_array(size: number) {
      const objects = new Array<Unpackable>(size);
      for (let i = 0; i < size; i++) {
        objects[i] = this.unpack();
      }
      return objects;
    }
  
    unpack_map(size: number) {
      const map: { [key: string]: Unpackable } = {};
      for (let i = 0; i < size; i++) {
        const key = this.unpack() as string;
        map[key] = this.unpack();
      }
      return map;
    }
  
    unpack_float() {
      const uint32 = this.unpack_uint32();
      const sign = uint32 >> 31;
      const exp = ((uint32 >> 23) & 0xff) - 127;
      const fraction = (uint32 & 0x7fffff) | 0x800000;
      return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);
    }
  
    unpack_double() {
      const h32 = this.unpack_uint32();
      const l32 = this.unpack_uint32();
      const sign = h32 >> 31;
      const exp = ((h32 >> 20) & 0x7ff) - 1023;
      const hfrac = (h32 & 0xfffff) | 0x100000;
      const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);
      return (sign === 0 ? 1 : -1) * frac;
    }
  
    read(length: number) {
      const j = this.index;
      if (j + length <= this.length) {
        return this.dataView.subarray(j, j + length);
      } else {
        throw new Error("BinaryPackFailure: read index out of range");
      }
    }
  }
  
  export class Packer {
    private _bufferBuilder = new BufferBuilder();
    private _textEncoder = new TextEncoder();
  
    getBuffer() {
      return this._bufferBuilder.toArrayBuffer();
    }
  
    pack(value: Packable) {
      if (typeof value === "string") {
        this.pack_string(value);
      } else if (typeof value === "number") {
        if (Math.floor(value) === value) {
          this.pack_integer(value);
        } else {
          this.pack_double(value);
        }
      } else if (typeof value === "boolean") {
        if (value === true) {
          this._bufferBuilder.append(0xc3);
        } else if (value === false) {
          this._bufferBuilder.append(0xc2);
        }
      } else if (value === undefined) {
        this._bufferBuilder.append(0xc0);
      } else if (typeof value === "object") {
        if (value === null) {
          this._bufferBuilder.append(0xc0);
        } else {
          const constructor = value.constructor;
          if (value instanceof Array) {
            const res = this.pack_array(value);
            if (res instanceof Promise) {
              return res.then(() => this._bufferBuilder.flush());
            }
          } else if (value instanceof ArrayBuffer) {
            this.pack_bin(new Uint8Array(value));
          } else if ("BYTES_PER_ELEMENT" in value) {
            const v = value as unknown as DataView;
            this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
          } else if (value instanceof Date) {
            this.pack_string(value.toString());
          } else if (value instanceof Blob) {
            return value.arrayBuffer().then((buffer) => {
              this.pack_bin(new Uint8Array(buffer));
              this._bufferBuilder.flush();
            });
            // this.pack_bin(new Uint8Array(await value.arrayBuffer()));
          } else if (
            constructor == Object ||
            constructor.toString().startsWith("class")
          ) {
            const res = this.pack_object(value);
            if (res instanceof Promise) {
              return res.then(() => this._bufferBuilder.flush());
            }
          } else {
            throw new Error(`Type "${constructor.toString()}" not yet supported`);
          }
        }
      } else {
        throw new Error(`Type "${typeof value}" not yet supported`);
      }
      this._bufferBuilder.flush();
    }
  
    pack_bin(blob: Uint8Array) {
      const length = blob.length;
  
      if (length <= 0x0f) {
        this.pack_uint8(0xa0 + length);
      } else if (length <= 0xffff) {
        this._bufferBuilder.append(0xda);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this._bufferBuilder.append(0xdb);
        this.pack_uint32(length);
      } else {
        throw new Error("Invalid length");
      }
      this._bufferBuilder.append_buffer(blob);
    }
  
    pack_string(str: string) {
      const encoded = this._textEncoder.encode(str);
      const length = encoded.length;
  
      if (length <= 0x0f) {
        this.pack_uint8(0xb0 + length);
      } else if (length <= 0xffff) {
        this._bufferBuilder.append(0xd8);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this._bufferBuilder.append(0xd9);
        this.pack_uint32(length);
      } else {
        throw new Error("Invalid length");
      }
      this._bufferBuilder.append_buffer(encoded);
    }
  
    pack_array(ary: Packable[]) {
      const length = ary.length;
      if (length <= 0x0f) {
        this.pack_uint8(0x90 + length);
      } else if (length <= 0xffff) {
        this._bufferBuilder.append(0xdc);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this._bufferBuilder.append(0xdd);
        this.pack_uint32(length);
      } else {
        throw new Error("Invalid length");
      }
  
      const packNext = (index: number): Promise<void> | void => {
        if (index < length) {
          const res = this.pack(ary[index]);
          if (res instanceof Promise) {
            return res.then(() => packNext(index + 1));
          }
          return packNext(index + 1);
        }
      };
  
      return packNext(0);
    }
  
    pack_integer(num: number) {
      if (num >= -0x20 && num <= 0x7f) {
        this._bufferBuilder.append(num & 0xff);
      } else if (num >= 0x00 && num <= 0xff) {
        this._bufferBuilder.append(0xcc);
        this.pack_uint8(num);
      } else if (num >= -0x80 && num <= 0x7f) {
        this._bufferBuilder.append(0xd0);
        this.pack_int8(num);
      } else if (num >= 0x0000 && num <= 0xffff) {
        this._bufferBuilder.append(0xcd);
        this.pack_uint16(num);
      } else if (num >= -0x8000 && num <= 0x7fff) {
        this._bufferBuilder.append(0xd1);
        this.pack_int16(num);
      } else if (num >= 0x00000000 && num <= 0xffffffff) {
        this._bufferBuilder.append(0xce);
        this.pack_uint32(num);
      } else if (num >= -0x80000000 && num <= 0x7fffffff) {
        this._bufferBuilder.append(0xd2);
        this.pack_int32(num);
      } else if (num >= -0x8000000000000000 && num <= 0x7fffffffffffffff) {
        this._bufferBuilder.append(0xd3);
        this.pack_int64(num);
      } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {
        this._bufferBuilder.append(0xcf);
        this.pack_uint64(num);
      } else {
        throw new Error("Invalid integer");
      }
    }
  
    pack_double(num: number) {
      let sign = 0;
      if (num < 0) {
        sign = 1;
        num = -num;
      }
      const exp = Math.floor(Math.log(num) / Math.LN2);
      const frac0 = num / 2 ** exp - 1;
      const frac1 = Math.floor(frac0 * 2 ** 52);
      const b32 = 2 ** 32;
      const h32 =
        (sign << 31) | ((exp + 1023) << 20) | ((frac1 / b32) & 0x0fffff);
      const l32 = frac1 % b32;
      this._bufferBuilder.append(0xcb);
      this.pack_int32(h32);
      this.pack_int32(l32);
    }
  
    pack_object(obj: { [key: string]: Packable }) {
      const keys = Object.keys(obj);
      const length = keys.length;
      if (length <= 0x0f) {
        this.pack_uint8(0x80 + length);
      } else if (length <= 0xffff) {
        this._bufferBuilder.append(0xde);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this._bufferBuilder.append(0xdf);
        this.pack_uint32(length);
      } else {
        throw new Error("Invalid length");
      }
  
      const packNext = (index: number): Promise<void> | void => {
        if (index < keys.length) {
          const prop = keys[index];
          // eslint-disable-next-line no-prototype-builtins
          if (obj.hasOwnProperty(prop)) {
            this.pack(prop);
            const res = this.pack(obj[prop]);
            if (res instanceof Promise) {
              return res.then(() => packNext(index + 1));
            }
          }
          return packNext(index + 1);
        }
      };
  
      return packNext(0);
    }
  
    pack_uint8(num: number) {
      this._bufferBuilder.append(num);
    }
  
    pack_uint16(num: number) {
      this._bufferBuilder.append(num >> 8);
      this._bufferBuilder.append(num & 0xff);
    }
  
    pack_uint32(num: number) {
      const n = num & 0xffffffff;
      this._bufferBuilder.append((n & 0xff000000) >>> 24);
      this._bufferBuilder.append((n & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((n & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(n & 0x000000ff);
    }
  
    pack_uint64(num: number) {
      const high = num / 2 ** 32;
      const low = num % 2 ** 32;
      this._bufferBuilder.append((high & 0xff000000) >>> 24);
      this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(high & 0x000000ff);
      this._bufferBuilder.append((low & 0xff000000) >>> 24);
      this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(low & 0x000000ff);
    }
  
    pack_int8(num: number) {
      this._bufferBuilder.append(num & 0xff);
    }
  
    pack_int16(num: number) {
      this._bufferBuilder.append((num & 0xff00) >> 8);
      this._bufferBuilder.append(num & 0xff);
    }
  
    pack_int32(num: number) {
      this._bufferBuilder.append((num >>> 24) & 0xff);
      this._bufferBuilder.append((num & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((num & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(num & 0x000000ff);
    }
  
    pack_int64(num: number) {
      const high = Math.floor(num / 2 ** 32);
      const low = num % 2 ** 32;
      this._bufferBuilder.append((high & 0xff000000) >>> 24);
      this._bufferBuilder.append((high & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((high & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(high & 0x000000ff);
      this._bufferBuilder.append((low & 0xff000000) >>> 24);
      this._bufferBuilder.append((low & 0x00ff0000) >>> 16);
      this._bufferBuilder.append((low & 0x0000ff00) >>> 8);
      this._bufferBuilder.append(low & 0x000000ff);
    }
  }
  ",
  "class BufferBuilder {
    private _pieces: number[];
    private readonly _parts: ArrayBufferView[];
  
    constructor() {
      this._pieces = [];
      this._parts = [];
    }
  
    append_buffer(data: ArrayBufferView) {
      this.flush();
      this._parts.push(data);
    }
  
    append(data: number) {
      this._pieces.push(data);
    }
  
    flush() {
      if (this._pieces.length > 0) {
        const buf = new Uint8Array(this._pieces);
        this._parts.push(buf);
        this._pieces = [];
      }
    }
  
    private encoder = new TextEncoder();
  
    public toArrayBuffer() {
      const buffer = [];
      for (const part of this._parts) {
        buffer.push(part);
      }
      return concatArrayBuffers(buffer).buffer;
    }
  }
  
  export { BufferBuilder };
  
  function concatArrayBuffers(bufs: ArrayBufferView[]) {
    let size = 0;
    for (const buf of bufs) {
      size += buf.byteLength;
    }
    const result = new Uint8Array(size);
    let offset = 0;
    for (const buf of bufs) {
      const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      result.set(view, offset);
      offset += buf.byteLength;
    }
    return result;
  }
  ",
  "import webRTCAdapter_import from "webrtc-adapter";
  
  const webRTCAdapter: typeof webRTCAdapter_import =
    //@ts-ignore
    webRTCAdapter_import.default || webRTCAdapter_import;
  
  export const Supports = new (class {
    readonly isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform);
    readonly supportedBrowsers = ["firefox", "chrome", "safari"];
  
    readonly minFirefoxVersion = 59;
    readonly minChromeVersion = 72;
    readonly minSafariVersion = 605;
  
    isWebRTCSupported(): boolean {
      return typeof RTCPeerConnection !== "undefined";
    }
  
    isBrowserSupported(): boolean {
      const browser = this.getBrowser();
      const version = this.getVersion();
  
      const validBrowser = this.supportedBrowsers.includes(browser);
  
      if (!validBrowser) return false;
  
      if (browser === "chrome") return version >= this.minChromeVersion;
      if (browser === "firefox") return version >= this.minFirefoxVersion;
      if (browser === "safari")
        return !this.isIOS && version >= this.minSafariVersion;
  
      return false;
    }
  
    getBrowser(): string {
      return webRTCAdapter.browserDetails.browser;
    }
  
    getVersion(): number {
      return webRTCAdapter.browserDetails.version || 0;
    }
  
    isUnifiedPlanSupported(): boolean {
      const browser = this.getBrowser();
      const version = webRTCAdapter.browserDetails.version || 0;
  
      if (browser === "chrome" && version < this.minChromeVersion) return false;
      if (browser === "firefox" && version >= this.minFirefoxVersion) return true;
      if (
        !window.RTCRtpTransceiver ||
        !("currentDirection" in RTCRtpTransceiver.prototype)
      )
        return false;
  
      let tempPc: RTCPeerConnection;
      let supported = false;
  
      try {
        tempPc = new RTCPeerConnection();
        tempPc.addTransceiver("audio");
        supported = true;
      } catch (e) {
      } finally {
        if (tempPc) {
          tempPc.close();
        }
      }
  
      return supported;
    }
  
    toString(): string {
      return `Supports:
      browser:${this.getBrowser()}
      version:${this.getVersion()}
      isIOS:${this.isIOS}
      isWebRTCSupported:${this.isWebRTCSupported()}
      isBrowserSupported:${this.isBrowserSupported()}
      isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;
    }
  })();
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  
  'use strict';
  
  import {adapterFactory} from './adapter_factory.js';
  
  const adapter =
    adapterFactory({window: typeof window === 'undefined' ? undefined : window});
  export default adapter;
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  import * as utils from './utils';
  
  // Browser shims.
  import * as chromeShim from './chrome/chrome_shim';
  import * as firefoxShim from './firefox/firefox_shim';
  import * as safariShim from './safari/safari_shim';
  import * as commonShim from './common_shim';
  import * as sdp from 'sdp';
  
  // Shimming starts here.
  export function adapterFactory({window} = {}, options = {
    shimChrome: true,
    shimFirefox: true,
    shimSafari: true,
  }) {
    // Utils.
    const logging = utils.log;
    const browserDetails = utils.detectBrowser(window);
  
    const adapter = {
      browserDetails,
      commonShim,
      extractVersion: utils.extractVersion,
      disableLog: utils.disableLog,
      disableWarnings: utils.disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp,
    };
  
    // Shim browser if found.
    switch (browserDetails.browser) {
      case 'chrome':
        if (!chromeShim || !chromeShim.shimPeerConnection ||
            !options.shimChrome) {
          logging('Chrome shim is not included in this adapter release.');
          return adapter;
        }
        if (browserDetails.version === null) {
          logging('Chrome shim can not determine version, not shimming.');
          return adapter;
        }
        logging('adapter.js shimming chrome.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = chromeShim;
  
        // Must be called before shimPeerConnection.
        commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);
        commonShim.shimParameterlessSetLocalDescription(window, browserDetails);
  
        chromeShim.shimGetUserMedia(window, browserDetails);
        chromeShim.shimMediaStream(window, browserDetails);
        chromeShim.shimPeerConnection(window, browserDetails);
        chromeShim.shimOnTrack(window, browserDetails);
        chromeShim.shimAddTrackRemoveTrack(window, browserDetails);
        chromeShim.shimGetSendersWithDtmf(window, browserDetails);
        chromeShim.shimGetStats(window, browserDetails);
        chromeShim.shimSenderReceiverGetStats(window, browserDetails);
        chromeShim.fixNegotiationNeeded(window, browserDetails);
  
        commonShim.shimRTCIceCandidate(window, browserDetails);
        commonShim.shimRTCIceCandidateRelayProtocol(window, browserDetails);
        commonShim.shimConnectionState(window, browserDetails);
        commonShim.shimMaxMessageSize(window, browserDetails);
        commonShim.shimSendThrowTypeError(window, browserDetails);
        commonShim.removeExtmapAllowMixed(window, browserDetails);
        break;
      case 'firefox':
        if (!firefoxShim || !firefoxShim.shimPeerConnection ||
            !options.shimFirefox) {
          logging('Firefox shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming firefox.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = firefoxShim;
  
        // Must be called before shimPeerConnection.
        commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);
        commonShim.shimParameterlessSetLocalDescription(window, browserDetails);
  
        firefoxShim.shimGetUserMedia(window, browserDetails);
        firefoxShim.shimPeerConnection(window, browserDetails);
        firefoxShim.shimOnTrack(window, browserDetails);
        firefoxShim.shimRemoveStream(window, browserDetails);
        firefoxShim.shimSenderGetStats(window, browserDetails);
        firefoxShim.shimReceiverGetStats(window, browserDetails);
        firefoxShim.shimRTCDataChannel(window, browserDetails);
        firefoxShim.shimAddTransceiver(window, browserDetails);
        firefoxShim.shimGetParameters(window, browserDetails);
        firefoxShim.shimCreateOffer(window, browserDetails);
        firefoxShim.shimCreateAnswer(window, browserDetails);
  
        commonShim.shimRTCIceCandidate(window, browserDetails);
        commonShim.shimConnectionState(window, browserDetails);
        commonShim.shimMaxMessageSize(window, browserDetails);
        commonShim.shimSendThrowTypeError(window, browserDetails);
        break;
      case 'safari':
        if (!safariShim || !options.shimSafari) {
          logging('Safari shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming safari.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = safariShim;
  
        // Must be called before shimCallbackAPI.
        commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);
        commonShim.shimParameterlessSetLocalDescription(window, browserDetails);
  
        safariShim.shimRTCIceServerUrls(window, browserDetails);
        safariShim.shimCreateOfferLegacy(window, browserDetails);
        safariShim.shimCallbacksAPI(window, browserDetails);
        safariShim.shimLocalStreamsAPI(window, browserDetails);
        safariShim.shimRemoteStreamsAPI(window, browserDetails);
        safariShim.shimTrackEventTransceiver(window, browserDetails);
        safariShim.shimGetUserMedia(window, browserDetails);
        safariShim.shimAudioContext(window, browserDetails);
  
        commonShim.shimRTCIceCandidate(window, browserDetails);
        commonShim.shimRTCIceCandidateRelayProtocol(window, browserDetails);
        commonShim.shimMaxMessageSize(window, browserDetails);
        commonShim.shimSendThrowTypeError(window, browserDetails);
        commonShim.removeExtmapAllowMixed(window, browserDetails);
        break;
      default:
        logging('Unsupported browser!');
        break;
    }
  
    return adapter;
  }
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  
  let logDisabled_ = true;
  let deprecationWarnings_ = true;
  
  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  export function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }
  
  // Wraps the peerconnection event eventNameToWrap in a function
  // which returns the modified event object (or false to prevent
  // the event).
  export function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
    if (!window.RTCPeerConnection) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e) => {
        const modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName,
        wrappedCallback]);
    };
  
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap
          || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName,
        unwrappedCb]);
    };
  
    Object.defineProperty(proto, 'on' + eventNameToWrap, {
      get() {
        return this['_on' + eventNameToWrap];
      },
      set(cb) {
        if (this['_on' + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
          delete this['_on' + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  }
  
  export function disableLog(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
      'adapter.js logging enabled';
  }
  
  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  export function disableWarnings(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  }
  
  export function log() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  }
  
  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  export function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  }
  
  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  export function detectBrowser(window) {
    // Returned result object.
    const result = {browser: null, version: null};
  
    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator ||
        !window.navigator.userAgent) {
      result.browser = 'Not a browser.';
      return result;
    }
  
    const {navigator} = window;
  
    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
        /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia ||
        (window.isSecureContext === false && window.webkitRTCPeerConnection)) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      // Chrome 74 removed webkitGetUserMedia on http as well so we need the
      // more complicated fallback to webkitRTCPeerConnection.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
        /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
        /AppleWebKit\/(\d+)\./, 1);
      result.supportsUnifiedPlan = window.RTCRtpTransceiver &&
          'currentDirection' in window.RTCRtpTransceiver.prototype;
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }
  
    return result;
  }
  
  /**
   * Checks if something is an object.
   *
   * @param {*} val The something you want to check.
   * @return true if val is an object, false otherwise.
   */
  function isObject(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }
  
  /**
   * Remove all empty objects and undefined values
   * from a nested object -- an enhanced and vanilla version
   * of Lodash's `compact`.
   */
  export function compactObject(data) {
    if (!isObject(data)) {
      return data;
    }
  
    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === undefined || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {[key]: value});
    }, {});
  }
  
  /* iterates the stats graph recursively. */
  export function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach(name => {
      if (name.endsWith('Id')) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith('Ids')) {
        base[name].forEach(id => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }
  
  /* filter getStats for a sender/receiver track. */
  export function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
    const filteredResult = new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach(value => {
      if (value.type === 'track' &&
          value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach(trackStat => {
      result.forEach(stats => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }
  
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  import * as utils from '../utils.js';
  
  export {shimGetUserMedia} from './getusermedia';
  export {shimGetDisplayMedia} from './getdisplaymedia';
  
  export function shimMediaStream(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }
  
  export function shimOnTrack(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get() {
          return this._ontrack;
        },
        set(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription =
        function setRemoteDescription() {
          if (!this._ontrackpoly) {
            this._ontrackpoly = (e) => {
              // onaddstream does not fire when a track is added to an existing
              // stream. But stream.onaddtrack is implemented so we use that.
              e.stream.addEventListener('addtrack', te => {
                let receiver;
                if (window.RTCPeerConnection.prototype.getReceivers) {
                  receiver = this.getReceivers()
                    .find(r => r.track && r.track.id === te.track.id);
                } else {
                  receiver = {track: te.track};
                }
  
                const event = new Event('track');
                event.track = te.track;
                event.receiver = receiver;
                event.transceiver = {receiver};
                event.streams = [e.stream];
                this.dispatchEvent(event);
              });
              e.stream.getTracks().forEach(track => {
                let receiver;
                if (window.RTCPeerConnection.prototype.getReceivers) {
                  receiver = this.getReceivers()
                    .find(r => r.track && r.track.id === track.id);
                } else {
                  receiver = {track};
                }
                const event = new Event('track');
                event.track = track;
                event.receiver = receiver;
                event.transceiver = {receiver};
                event.streams = [e.stream];
                this.dispatchEvent(event);
              });
            };
            this.addEventListener('addstream', this._ontrackpoly);
          }
          return origSetRemoteDescription.apply(this, arguments);
        };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      utils.wrapPeerConnectionEvent(window, 'track', e => {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver',
            {value: {receiver: e.receiver}});
        }
        return e;
      });
    }
  }
  
  export function shimGetSendersWithDtmf(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };
  
      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack =
          function addTrack(track, stream) {
            let sender = origAddTrack.apply(this, arguments);
            if (!sender) {
              sender = shimSenderWithDtmf(this, track);
              this._senders.push(sender);
            }
            return sender;
          };
  
        const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack =
          function removeTrack(sender) {
            origRemoveTrack.apply(this, arguments);
            const idx = this._senders.indexOf(sender);
            if (idx !== -1) {
              this._senders.splice(idx, 1);
            }
          };
      }
      const origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach(track => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
  
      const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream =
        function removeStream(stream) {
          this._senders = this._senders || [];
          origRemoveStream.apply(this, [stream]);
  
          stream.getTracks().forEach(track => {
            const sender = this._senders.find(s => s.track === track);
            if (sender) { // remove sender
              this._senders.splice(this._senders.indexOf(sender), 1);
            }
          });
        };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };
  
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }
  
  export function shimGetStats(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
  
    const origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
  
      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }
  
      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof selector !== 'function')) {
        return origGetStats.apply(this, []);
      }
  
      const fixChromeStats_ = function(response) {
        const standardReport = {};
        const reports = response.result();
        reports.forEach(report => {
          const standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(name => {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });
  
        return standardReport;
      };
  
      // shim getStats with maplike support
      const makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(key => [key, stats[key]]));
      };
  
      if (arguments.length >= 2) {
        const successCallbackWrapper_ = function(response) {
          onSucc(makeMapStats(fixChromeStats_(response)));
        };
  
        return origGetStats.apply(this, [successCallbackWrapper_,
          selector]);
      }
  
      // promise-support
      return new Promise((resolve, reject) => {
        origGetStats.apply(this, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(onSucc, onErr);
    };
  }
  
  export function shimSenderReceiverGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }
  
    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach(sender => sender._pc = this);
          return senders;
        };
      }
  
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then(result =>
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          utils.filterStats(result, sender.track, true));
      };
    }
  
    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers =
          function getReceivers() {
            const receivers = origGetReceivers.apply(this, []);
            receivers.forEach(receiver => receiver._pc = this);
            return receivers;
          };
      }
      utils.wrapPeerConnectionEvent(window, 'track', e => {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then(result =>
          utils.filterStats(result, receiver.track, false));
      };
    }
  
    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }
  
    // shim RTCPeerConnection.getStats(track).
    const origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach(s => {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach(r => {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(this, arguments);
    };
  }
  
  export function shimAddTrackRemoveTrackWithNative(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        return Object.keys(this._shimmedLocalStreams)
          .map(streamId => this._shimmedLocalStreams[streamId][0]);
      };
  
    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, stream) {
        if (!stream) {
          return origAddTrack.apply(this, arguments);
        }
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
  
        const sender = origAddTrack.apply(this, arguments);
        if (!this._shimmedLocalStreams[stream.id]) {
          this._shimmedLocalStreams[stream.id] = [stream, sender];
        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
          this._shimmedLocalStreams[stream.id].push(sender);
        }
        return sender;
      };
  
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
  
      stream.getTracks().forEach(track => {
        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders()
        .filter(newSender => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };
  
    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        delete this._shimmedLocalStreams[stream.id];
        return origRemoveStream.apply(this, arguments);
      };
  
    const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack =
      function removeTrack(sender) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        if (sender) {
          Object.keys(this._shimmedLocalStreams).forEach(streamId => {
            const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
            if (idx !== -1) {
              this._shimmedLocalStreams[streamId].splice(idx, 1);
            }
            if (this._shimmedLocalStreams[streamId].length === 1) {
              delete this._shimmedLocalStreams[streamId];
            }
          });
        }
        return origRemoveTrack.apply(this, arguments);
      };
  }
  
  export function shimAddTrackRemoveTrack(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window);
    }
  
    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    const origGetLocalStreams = window.RTCPeerConnection.prototype
      .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        const nativeStreams = origGetLocalStreams.apply(this);
        this._reverseStreams = this._reverseStreams || {};
        return nativeStreams.map(stream => this._reverseStreams[stream.id]);
      };
  
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
  
      stream.getTracks().forEach(track => {
        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };
  
    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._streams = this._streams || {};
        this._reverseStreams = this._reverseStreams || {};
  
        origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);
        delete this._reverseStreams[(this._streams[stream.id] ?
          this._streams[stream.id].id : stream.id)];
        delete this._streams[stream.id];
      };
  
    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, stream) {
        if (this.signalingState === 'closed') {
          throw new DOMException(
            'The RTCPeerConnection\'s signalingState is \'closed\'.',
            'InvalidStateError');
        }
        const streams = [].slice.call(arguments, 1);
        if (streams.length !== 1 ||
            !streams[0].getTracks().find(t => t === track)) {
          // this is not fully correct but all we can manage without
          // [[associated MediaStreams]] internal slot.
          throw new DOMException(
            'The adapter.js addTrack polyfill only supports a single ' +
            ' stream which is associated with the specified track.',
            'NotSupportedError');
        }
  
        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }
  
        this._streams = this._streams || {};
        this._reverseStreams = this._reverseStreams || {};
        const oldStream = this._streams[stream.id];
        if (oldStream) {
          // this is using odd Chrome behaviour, use with caution:
          // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
          // Note: we rely on the high-level addTrack/dtmf shim to
          // create the sender with a dtmf sender.
          oldStream.addTrack(track);
  
          // Trigger ONN async.
          Promise.resolve().then(() => {
            this.dispatchEvent(new Event('negotiationneeded'));
          });
        } else {
          const newStream = new window.MediaStream([track]);
          this._streams[stream.id] = newStream;
          this._reverseStreams[newStream.id] = stream;
          this.addStream(newStream);
        }
        return this.getSenders().find(s => s.track === track);
      };
  
    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(internalId => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
          externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(internalId => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
          internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      const nativeMethod = window.RTCPeerConnection.prototype[method];
      const methodObj = {[method]() {
        const args = arguments;
        const isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(this, [
            (description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            },
            (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(this, arguments)
          .then(description => replaceInternalStreamId(this, description));
      }};
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  
    const origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription =
      function setLocalDescription() {
        if (!arguments.length || !arguments[0].type) {
          return origSetLocalDescription.apply(this, arguments);
        }
        arguments[0] = replaceExternalStreamId(this, arguments[0]);
        return origSetLocalDescription.apply(this, arguments);
      };
  
    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier
  
    const origLocalDescription = Object.getOwnPropertyDescriptor(
      window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
      'localDescription', {
        get() {
          const description = origLocalDescription.get.apply(this);
          if (description.type === '') {
            return description;
          }
          return replaceInternalStreamId(this, description);
        }
      });
  
    window.RTCPeerConnection.prototype.removeTrack =
      function removeTrack(sender) {
        if (this.signalingState === 'closed') {
          throw new DOMException(
            'The RTCPeerConnection\'s signalingState is \'closed\'.',
            'InvalidStateError');
        }
        // We can not yet check for sender instanceof RTCRtpSender
        // since we shim RTPSender. So we check if sender._pc is set.
        if (!sender._pc) {
          throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
              'does not implement interface RTCRtpSender.', 'TypeError');
        }
        const isLocal = sender._pc === this;
        if (!isLocal) {
          throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
        }
  
        // Search for the native stream the senders track belongs to.
        this._streams = this._streams || {};
        let stream;
        Object.keys(this._streams).forEach(streamid => {
          const hasTrack = this._streams[streamid].getTracks()
            .find(track => sender.track === track);
          if (hasTrack) {
            stream = this._streams[streamid];
          }
        });
  
        if (stream) {
          if (stream.getTracks().length === 1) {
            // if this is the last track of the stream, remove the stream. This
            // takes care of any shimmed _senders.
            this.removeStream(this._reverseStreams[stream.id]);
          } else {
            // relying on the same odd chrome behaviour as above.
            stream.removeTrack(sender.track);
          }
          this.dispatchEvent(new Event('negotiationneeded'));
        }
      };
  }
  
  export function shimPeerConnection(window, browserDetails) {
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
    }
    if (!window.RTCPeerConnection) {
      return;
    }
  
    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    if (browserDetails.version < 53) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
              window.RTCIceCandidate :
              window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
    }
  }
  
  // Attempt to fix ONN in plan-b mode.
  export function fixNegotiationNeeded(window, browserDetails) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
      const pc = e.target;
      if (browserDetails.version < 72 || (pc.getConfiguration &&
          pc.getConfiguration().sdpSemantics === 'plan-b')) {
        if (pc.signalingState !== 'stable') {
          return;
        }
      }
      return e;
    });
  }
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  import * as utils from '../utils.js';
  const logging = utils.log;
  
  export function shimGetUserMedia(window, browserDetails) {
    const navigator = window && window.navigator;
  
    if (!navigator.mediaDevices) {
      return;
    }
  
    const constraintsToChrome_ = function(c) {
      if (typeof c !== 'object' || c.mandatory || c.optional) {
        return c;
      }
      const cc = {};
      Object.keys(c).forEach(key => {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
        if (r.exact !== undefined && typeof r.exact === 'number') {
          r.min = r.max = r.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return (name === 'deviceId') ? 'sourceId' : name;
        };
        if (r.ideal !== undefined) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r.ideal === 'number') {
            oc[oldname_('min', key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_('max', key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_('', key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== undefined && typeof r.exact !== 'number') {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_('', key)] = r.exact;
        } else {
          ['min', 'max'].forEach(mix => {
            if (r[mix] !== undefined) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };
  
    const shimConstraints_ = function(constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === 'object') {
        const remap = function(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === 'object') {
        // Shim facingMode for mobile & surface pro.
        let face = constraints.video.facingMode;
        face = face && ((typeof face === 'object') ? face : {ideal: face});
        const getSupportedFacingModeLies = browserDetails.version < 66;
  
        if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                      face.ideal === 'user' || face.ideal === 'environment')) &&
            !(navigator.mediaDevices.getSupportedConstraints &&
              navigator.mediaDevices.getSupportedConstraints().facingMode &&
              !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === 'environment' || face.ideal === 'environment') {
            matches = ['back', 'rear'];
          } else if (face.exact === 'user' || face.ideal === 'user') {
            matches = ['front'];
          }
          if (matches) {
            // Look for matches in label, or use last cam for back (typical).
            return navigator.mediaDevices.enumerateDevices()
              .then(devices => {
                devices = devices.filter(d => d.kind === 'videoinput');
                let dev = devices.find(d => matches.some(match =>
                  d.label.toLowerCase().includes(match)));
                if (!dev && devices.length && matches.includes('back')) {
                  dev = devices[devices.length - 1]; // more likely the back cam
                }
                if (dev) {
                  constraints.video.deviceId = face.exact
                    ? {exact: dev.deviceId}
                    : {ideal: dev.deviceId};
                }
                constraints.video = constraintsToChrome_(constraints.video);
                logging('chrome: ' + JSON.stringify(constraints));
                return func(constraints);
              });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging('chrome: ' + JSON.stringify(constraints));
      return func(constraints);
    };
  
    const shimError_ = function(e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: 'NotAllowedError',
          PermissionDismissedError: 'NotAllowedError',
          InvalidStateError: 'NotAllowedError',
          DevicesNotFoundError: 'NotFoundError',
          ConstraintNotSatisfiedError: 'OverconstrainedError',
          TrackStartError: 'NotReadableError',
          MediaDeviceFailedDueToShutdown: 'NotAllowedError',
          MediaDeviceKillSwitchOn: 'NotAllowedError',
          TabCaptureError: 'AbortError',
          ScreenCaptureError: 'AbortError',
          DeviceCaptureError: 'AbortError'
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString() {
          return this.name + (this.message && ': ') + this.message;
        }
      };
    };
  
    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, c => {
        navigator.webkitGetUserMedia(c, onSuccess, e => {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator.getUserMedia = getUserMedia_.bind(navigator);
  
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    if (navigator.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function(cs) {
        return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(track => {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, e => Promise.reject(shimError_(e))));
      };
    }
  }
  ",
  "/*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  export function shimGetDisplayMedia(window, getSourceId) {
    if (window.navigator.mediaDevices &&
      'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!(window.navigator.mediaDevices)) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' +
          'a function');
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia =
      function getDisplayMedia(constraints) {
        return getSourceId(constraints)
          .then(sourceId => {
            const widthSpecified = constraints.video && constraints.video.width;
            const heightSpecified = constraints.video &&
              constraints.video.height;
            const frameRateSpecified = constraints.video &&
              constraints.video.frameRate;
            constraints.video = {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: sourceId,
                maxFrameRate: frameRateSpecified || 3
              }
            };
            if (widthSpecified) {
              constraints.video.mandatory.maxWidth = widthSpecified;
            }
            if (heightSpecified) {
              constraints.video.mandatory.maxHeight = heightSpecified;
            }
            return window.navigator.mediaDevices.getUserMedia(constraints);
          });
      };
  }
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  
  import * as utils from '../utils';
  export {shimGetUserMedia} from './getusermedia';
  export {shimGetDisplayMedia} from './getdisplaymedia';
  
  export function shimOnTrack(window) {
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {receiver: this.receiver};
        }
      });
    }
  }
  
  export function shimPeerConnection(window, browserDetails) {
    if (typeof window !== 'object' ||
        !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
    }
  
    if (browserDetails.version < 53) {
      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
              window.RTCIceCandidate :
              window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
    }
  
    const modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };
  
    const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null])
        .then(stats => {
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(stat => {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach((stat, i) => {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  }
  
  export function shimSenderGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };
    }
  
    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) :
        Promise.resolve(new Map());
    };
  }
  
  export function shimReceiverGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach(receiver => receiver._pc = this);
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', e => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  
  export function shimRemoveStream(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        utils.deprecated('removeStream', 'removeTrack');
        this.getSenders().forEach(sender => {
          if (sender.track && stream.getTracks().includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
  }
  
  export function shimRTCDataChannel(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  }
  
  export function shimAddTransceiver(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window.RTCPeerConnection.prototype.addTransceiver =
        function addTransceiver() {
          this.setParametersPromises = [];
          // WebIDL input coercion and validation
          let sendEncodings = arguments[1] && arguments[1].sendEncodings;
          if (sendEncodings === undefined) {
            sendEncodings = [];
          }
          sendEncodings = [...sendEncodings];
          const shouldPerformCheck = sendEncodings.length > 0;
          if (shouldPerformCheck) {
            // If sendEncodings params are provided, validate grammar
            sendEncodings.forEach((encodingParam) => {
              if ('rid' in encodingParam) {
                const ridRegex = /^[a-z0-9]{0,16}$/i;
                if (!ridRegex.test(encodingParam.rid)) {
                  throw new TypeError('Invalid RID value provided.');
                }
              }
              if ('scaleResolutionDownBy' in encodingParam) {
                if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                  throw new RangeError('scale_resolution_down_by must be >= 1.0');
                }
              }
              if ('maxFramerate' in encodingParam) {
                if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                  throw new RangeError('max_framerate must be >= 0.0');
                }
              }
            });
          }
          const transceiver = origAddTransceiver.apply(this, arguments);
          if (shouldPerformCheck) {
            // Check if the init options were applied. If not we do this in an
            // asynchronous way and save the promise reference in a global object.
            // This is an ugly hack, but at the same time is way more robust than
            // checking the sender parameters before and after the createOffer
            // Also note that after the createoffer we are not 100% sure that
            // the params were asynchronously applied so we might miss the
            // opportunity to recreate offer.
            const {sender} = transceiver;
            const params = sender.getParameters();
            if (!('encodings' in params) ||
                // Avoid being fooled by patched getParameters() below.
                (params.encodings.length === 1 &&
                 Object.keys(params.encodings[0]).length === 0)) {
              params.encodings = sendEncodings;
              sender.sendEncodings = sendEncodings;
              this.setParametersPromises.push(sender.setParameters(params)
                .then(() => {
                  delete sender.sendEncodings;
                }).catch(() => {
                  delete sender.sendEncodings;
                })
              );
            }
          }
          return transceiver;
        };
    }
  }
  
  export function shimGetParameters(window) {
    if (!(typeof window === 'object' && window.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window.RTCRtpSender.prototype.getParameters =
        function getParameters() {
          const params = origGetParameters.apply(this, arguments);
          if (!('encodings' in params)) {
            params.encodings = [].concat(this.sendEncodings || [{}]);
          }
          return params;
        };
    }
  }
  
  export function shimCreateOffer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateOffer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  
  export function shimCreateAnswer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
    window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateAnswer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  
  import * as utils from '../utils';
  
  export function shimGetUserMedia(window, browserDetails) {
    const navigator = window && window.navigator;
    const MediaStreamTrack = window && window.MediaStreamTrack;
  
    navigator.getUserMedia = function(constraints, onSuccess, onError) {
      // Replace Firefox 44+'s deprecation warning with unprefixed version.
      utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
  
    if (!(browserDetails.version > 55 &&
        'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
  
      const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function(c) {
        if (typeof c === 'object' && typeof c.audio === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
          remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeGetUserMedia(c);
      };
  
      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, 'mozAutoGainControl', 'autoGainControl');
          remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
          return obj;
        };
      }
  
      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        const nativeApplyConstraints =
          MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function(c) {
          if (this.kind === 'audio' && typeof c === 'object') {
            c = JSON.parse(JSON.stringify(c));
            remap(c, 'autoGainControl', 'mozAutoGainControl');
            remap(c, 'noiseSuppression', 'mozNoiseSuppression');
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }
  ",
  "/*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  
  export function shimGetDisplayMedia(window, preferredMediaSource) {
    if (window.navigator.mediaDevices &&
      'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!(window.navigator.mediaDevices)) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia =
      function getDisplayMedia(constraints) {
        if (!(constraints && constraints.video)) {
          const err = new DOMException('getDisplayMedia without video ' +
              'constraints is undefined');
          err.name = 'NotFoundError';
          // from https://heycam.github.io/webidl/#idl-DOMException-error-names
          err.code = 8;
          return Promise.reject(err);
        }
        if (constraints.video === true) {
          constraints.video = {mediaSource: preferredMediaSource};
        } else {
          constraints.video.mediaSource = preferredMediaSource;
        }
        return window.navigator.mediaDevices.getUserMedia(constraints);
      };
  }
  ",
  "/*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  'use strict';
  import * as utils from '../utils';
  
  export function shimLocalStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams =
        function getLocalStreams() {
          if (!this._localStreams) {
            this._localStreams = [];
          }
          return this._localStreams;
        };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      const _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        // Try to emulate Chrome's behaviour of adding in audio-video order.
        // Safari orders by track id.
        stream.getAudioTracks().forEach(track => _addTrack.call(this, track,
          stream));
        stream.getVideoTracks().forEach(track => _addTrack.call(this, track,
          stream));
      };
  
      window.RTCPeerConnection.prototype.addTrack =
        function addTrack(track, ...streams) {
          if (streams) {
            streams.forEach((stream) => {
              if (!this._localStreams) {
                this._localStreams = [stream];
              } else if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              }
            });
          }
          return _addTrack.apply(this, arguments);
        };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream =
        function removeStream(stream) {
          if (!this._localStreams) {
            this._localStreams = [];
          }
          const index = this._localStreams.indexOf(stream);
          if (index === -1) {
            return;
          }
          this._localStreams.splice(index, 1);
          const tracks = stream.getTracks();
          this.getSenders().forEach(sender => {
            if (tracks.includes(sender.track)) {
              this.removeTrack(sender);
            }
          });
        };
    }
  }
  
  export function shimRemoteStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams =
        function getRemoteStreams() {
          return this._remoteStreams ? this._remoteStreams : [];
        };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get() {
          return this._onaddstream;
        },
        set(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = (e) => {
            e.streams.forEach(stream => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream)) {
                return;
              }
              this._remoteStreams.push(stream);
              const event = new Event('addstream');
              event.stream = stream;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription =
        function setRemoteDescription() {
          const pc = this;
          if (!this._onaddstreampoly) {
            this.addEventListener('track', this._onaddstreampoly = function(e) {
              e.streams.forEach(stream => {
                if (!pc._remoteStreams) {
                  pc._remoteStreams = [];
                }
                if (pc._remoteStreams.indexOf(stream) >= 0) {
                  return;
                }
                pc._remoteStreams.push(stream);
                const event = new Event('addstream');
                event.stream = stream;
                pc.dispatchEvent(event);
              });
            });
          }
          return origSetRemoteDescription.apply(pc, arguments);
        };
    }
  }
  
  export function shimCallbacksAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    const prototype = window.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;
  
    prototype.createOffer =
      function createOffer(successCallback, failureCallback) {
        const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
        const promise = origCreateOffer.apply(this, [options]);
        if (!failureCallback) {
          return promise;
        }
        promise.then(successCallback, failureCallback);
        return Promise.resolve();
      };
  
    prototype.createAnswer =
      function createAnswer(successCallback, failureCallback) {
        const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
        const promise = origCreateAnswer.apply(this, [options]);
        if (!failureCallback) {
          return promise;
        }
        promise.then(successCallback, failureCallback);
        return Promise.resolve();
      };
  
    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;
  
    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;
  
    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }
  
  export function shimGetUserMedia(window) {
    const navigator = window && window.navigator;
  
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // shim not needed in Safari 12.1
      const mediaDevices = navigator.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
  
    if (!navigator.getUserMedia && navigator.mediaDevices &&
      navigator.mediaDevices.getUserMedia) {
      navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
        navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
      }.bind(navigator);
    }
  }
  
  export function shimConstraints(constraints) {
    if (constraints && constraints.video !== undefined) {
      return Object.assign({},
        constraints,
        {video: utils.compactObject(constraints.video)}
      );
    }
  
    return constraints;
  }
  
  export function shimRTCIceServerUrls(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    const OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection =
      function RTCPeerConnection(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          const newIceServers = [];
          for (let i = 0; i < pcConfig.iceServers.length; i++) {
            let server = pcConfig.iceServers[i];
            if (server.urls === undefined && server.url) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              delete server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in OrigPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }
  
  export function shimTrackEventTransceiver(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCTrackEvent &&
        'receiver' in window.RTCTrackEvent.prototype &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {receiver: this.receiver};
        }
      });
    }
  }
  
  export function shimCreateOfferLegacy(window) {
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer =
      function createOffer(offerOptions) {
        if (offerOptions) {
          if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
            // support bit values
            offerOptions.offerToReceiveAudio =
              !!offerOptions.offerToReceiveAudio;
          }
          const audioTransceiver = this.getTransceivers().find(transceiver =>
            transceiver.receiver.track.kind === 'audio');
          if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
            if (audioTransceiver.direction === 'sendrecv') {
              if (audioTransceiver.setDirection) {
                audioTransceiver.setDirection('sendonly');
              } else {
                audioTransceiver.direction = 'sendonly';
              }
            } else if (audioTransceiver.direction === 'recvonly') {
              if (audioTransceiver.setDirection) {
                audioTransceiver.setDirection('inactive');
              } else {
                audioTransceiver.direction = 'inactive';
              }
            }
          } else if (offerOptions.offerToReceiveAudio === true &&
              !audioTransceiver) {
            this.addTransceiver('audio', {direction: 'recvonly'});
          }
  
          if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
            // support bit values
            offerOptions.offerToReceiveVideo =
              !!offerOptions.offerToReceiveVideo;
          }
          const videoTransceiver = this.getTransceivers().find(transceiver =>
            transceiver.receiver.track.kind === 'video');
          if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
            if (videoTransceiver.direction === 'sendrecv') {
              if (videoTransceiver.setDirection) {
                videoTransceiver.setDirection('sendonly');
              } else {
                videoTransceiver.direction = 'sendonly';
              }
            } else if (videoTransceiver.direction === 'recvonly') {
              if (videoTransceiver.setDirection) {
                videoTransceiver.setDirection('inactive');
              } else {
                videoTransceiver.direction = 'inactive';
              }
            }
          } else if (offerOptions.offerToReceiveVideo === true &&
              !videoTransceiver) {
            this.addTransceiver('video', {direction: 'recvonly'});
          }
        }
        return origCreateOffer.apply(this, arguments);
      };
  }
  
  export function shimAudioContext(window) {
    if (typeof window !== 'object' || window.AudioContext) {
      return;
    }
    window.AudioContext = window.webkitAudioContext;
  }
  
  ",
  "/*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';
  
  import SDPUtils from 'sdp';
  import * as utils from './utils';
  
  export function shimRTCIceCandidate(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }
  
    const NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function RTCIceCandidate(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }
  
      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key,
              {value: parsedCandidate[key]});
          }
        }
  
        // Override serializer to not serialize the extra attributes.
        nativeCandidate.toJSON = function toJSON() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment,
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  
    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', e => {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  }
  
  export function shimRTCIceCandidateRelayProtocol(window) {
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'relayProtocol' in
        window.RTCIceCandidate.prototype)) {
      return;
    }
  
    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', e => {
      if (e.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
        if (parsedCandidate.type === 'relay') {
          // This is a libwebrtc-specific mapping of local type preference
          // to relayProtocol.
          e.candidate.relayProtocol = {
            0: 'tls',
            1: 'tcp',
            2: 'udp',
          }[parsedCandidate.priority >> 24];
        }
      }
      return e;
    });
  }
  
  export function shimMaxMessageSize(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }
  
    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }
  
    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(mediaSection => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };
  
    const getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };
  
    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      let canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
  
    const getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      let maxMessageSize = 65536;
  
      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }
  
      const match = SDPUtils.matchPrefix(description.sdp,
        'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
  
    const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        this._sctp = null;
        // Chrome decided to not expose .sctp in plan-b mode.
        // As usual, adapter.js has to do an 'ugly worakaround'
        // to cover up the mess.
        if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
          const {sdpSemantics} = this.getConfiguration();
          if (sdpSemantics === 'plan-b') {
            Object.defineProperty(this, 'sctp', {
              get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              },
              enumerable: true,
              configurable: true,
            });
          }
        }
  
        if (sctpInDescription(arguments[0])) {
          // Check if the remote is FF.
          const isFirefox = getRemoteFirefoxVersion(arguments[0]);
  
          // Get the maximum message size the local peer is capable of sending
          const canSendMMS = getCanSendMaxMessageSize(isFirefox);
  
          // Get the maximum message size of the remote peer.
          const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
  
          // Determine final maximum message size
          let maxMessageSize;
          if (canSendMMS === 0 && remoteMMS === 0) {
            maxMessageSize = Number.POSITIVE_INFINITY;
          } else if (canSendMMS === 0 || remoteMMS === 0) {
            maxMessageSize = Math.max(canSendMMS, remoteMMS);
          } else {
            maxMessageSize = Math.min(canSendMMS, remoteMMS);
          }
  
          // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
          // attribute.
          const sctp = {};
          Object.defineProperty(sctp, 'maxMessageSize', {
            get() {
              return maxMessageSize;
            }
          });
          this._sctp = sctp;
        }
  
        return origSetRemoteDescription.apply(this, arguments);
      };
  }
  
  export function shimSendThrowTypeError(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }
  
    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
  
    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel =
      function createDataChannel() {
        const dataChannel = origCreateDataChannel.apply(this, arguments);
        wrapDcSend(dataChannel, this);
        return dataChannel;
      };
    utils.wrapPeerConnectionEvent(window, 'datachannel', e => {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
  
  
  /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
   * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
   * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
   * since DTLS failures would be hidden. See
   * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
   * for the Firefox tracking bug.
   */
  export function shimConnectionState(window) {
    if (!window.RTCPeerConnection ||
        'connectionState' in window.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    Object.defineProperty(proto, 'connectionState', {
      get() {
        return {
          completed: 'connected',
          checking: 'connecting'
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, 'onconnectionstatechange', {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener('connectionstatechange',
            this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener('connectionstatechange',
            this._onconnectionstatechange = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  
    ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = e => {
            const pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event('connectionstatechange', e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener('iceconnectionstatechange',
            this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  
  export function removeExtmapAllowMixed(window, browserDetails) {
    /* remove a=extmap-allow-mixed for webrtc.org < M71 */
    if (!window.RTCPeerConnection) {
      return;
    }
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
      return;
    }
    if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
      return;
    }
    const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
    function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
        const sdp = desc.sdp.split('\n').filter((line) => {
          return line.trim() !== 'a=extmap-allow-mixed';
        }).join('\n');
        // Safari enforces read-only-ness of RTCSessionDescription fields.
        if (window.RTCSessionDescription &&
            desc instanceof window.RTCSessionDescription) {
          arguments[0] = new window.RTCSessionDescription({
            type: desc.type,
            sdp,
          });
        } else {
          desc.sdp = sdp;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  
  export function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
    // Support for addIceCandidate(null or undefined)
    // as well as addIceCandidate({candidate: "", ...})
    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
    // Note: must be called before other polyfills which change the signature.
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.addIceCandidate =
      function addIceCandidate() {
        if (!arguments[0]) {
          if (arguments[1]) {
            arguments[1].apply(null);
          }
          return Promise.resolve();
        }
        // Firefox 68+ emits and processes {candidate: "", ...}, ignore
        // in older versions.
        // Native support for ignoring exists for Chrome M77+.
        // Safari ignores as well, exact version unknown but works in the same
        // version that also ignores addIceCandidate(null).
        if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)
             || (browserDetails.browser === 'firefox'
                 && browserDetails.version < 68)
             || (browserDetails.browser === 'safari'))
            && arguments[0] && arguments[0].candidate === '') {
          return Promise.resolve();
        }
        return nativeAddIceCandidate.apply(this, arguments);
      };
  }
  
  // Note: Make sure to call this ahead of APIs that modify
  // setLocalDescription.length
  export function shimParameterlessSetLocalDescription(window, browserDetails) {
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.setLocalDescription =
      function setLocalDescription() {
        let desc = arguments[0] || {};
        if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
          return nativeSetLocalDescription.apply(this, arguments);
        }
        // The remaining steps should technically happen when SLD comes off the
        // RTCPeerConnection's operations chain (not ahead of going on it), but
        // this is too difficult to shim. Instead, this shim only covers the
        // common case where the operations chain is empty. This is imperfect, but
        // should cover many cases. Rationale: Even if we can't reduce the glare
        // window to zero on imperfect implementations, there's value in tapping
        // into the perfect negotiation pattern that several browsers support.
        desc = {type: desc.type, sdp: desc.sdp};
        if (!desc.type) {
          switch (this.signalingState) {
            case 'stable':
            case 'have-local-offer':
            case 'have-remote-pranswer':
              desc.type = 'offer';
              break;
            default:
              desc.type = 'answer';
              break;
          }
        }
        if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
          return nativeSetLocalDescription.apply(this, [desc]);
        }
        const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
        return func.apply(this)
          .then(d => nativeSetLocalDescription.apply(this, [d]));
      };
  }
  ",
  "/* eslint-env node */
  'use strict';
  
  // SDP helpers.
  const SDPUtils = {};
  
  // Generate an alphanumeric identifier for cname or mids.
  // TODO: use UUIDs instead? https://gist.github.com/jed/982883
  SDPUtils.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  };
  
  // The RTCP CNAME used by all peerconnections from the same JS.
  SDPUtils.localCName = SDPUtils.generateIdentifier();
  
  // Splits SDP into lines, dealing with both CRLF and LF.
  SDPUtils.splitLines = function(blob) {
    return blob.trim().split('\n').map(line => line.trim());
  };
  // Splits SDP into sessionpart and mediasections. Ensures CRLF.
  SDPUtils.splitSections = function(blob) {
    const parts = blob.split('\nm=');
    return parts.map((part, index) => (index > 0 ?
      'm=' + part : part).trim() + '\r\n');
  };
  
  // Returns the session description.
  SDPUtils.getDescription = function(blob) {
    const sections = SDPUtils.splitSections(blob);
    return sections && sections[0];
  };
  
  // Returns the individual media sections.
  SDPUtils.getMediaSections = function(blob) {
    const sections = SDPUtils.splitSections(blob);
    sections.shift();
    return sections;
  };
  
  // Returns lines that start with a certain prefix.
  SDPUtils.matchPrefix = function(blob, prefix) {
    return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
  };
  
  // Parses an ICE candidate line. Sample input:
  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
  // rport 55996"
  // Input can be prefixed with a=.
  SDPUtils.parseCandidate = function(line) {
    let parts;
    // Parse both variants.
    if (line.indexOf('a=candidate:') === 0) {
      parts = line.substring(12).split(' ');
    } else {
      parts = line.substring(10).split(' ');
    }
  
    const candidate = {
      foundation: parts[0],
      component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4], // address is an alias for ip.
      port: parseInt(parts[5], 10),
      // skip parts[6] == 'typ'
      type: parts[7],
    };
  
    for (let i = 8; i < parts.length; i += 2) {
      switch (parts[i]) {
        case 'raddr':
          candidate.relatedAddress = parts[i + 1];
          break;
        case 'rport':
          candidate.relatedPort = parseInt(parts[i + 1], 10);
          break;
        case 'tcptype':
          candidate.tcpType = parts[i + 1];
          break;
        case 'ufrag':
          candidate.ufrag = parts[i + 1]; // for backward compatibility.
          candidate.usernameFragment = parts[i + 1];
          break;
        default: // extension handling, in particular ufrag. Don't overwrite.
          if (candidate[parts[i]] === undefined) {
            candidate[parts[i]] = parts[i + 1];
          }
          break;
      }
    }
    return candidate;
  };
  
  // Translates a candidate object into SDP candidate attribute.
  // This does not include the a= prefix!
  SDPUtils.writeCandidate = function(candidate) {
    const sdp = [];
    sdp.push(candidate.foundation);
  
    const component = candidate.component;
    if (component === 'rtp') {
      sdp.push(1);
    } else if (component === 'rtcp') {
      sdp.push(2);
    } else {
      sdp.push(component);
    }
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.address || candidate.ip);
    sdp.push(candidate.port);
  
    const type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type !== 'host' && candidate.relatedAddress &&
        candidate.relatedPort) {
      sdp.push('raddr');
      sdp.push(candidate.relatedAddress);
      sdp.push('rport');
      sdp.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
      sdp.push('tcptype');
      sdp.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp.push('ufrag');
      sdp.push(candidate.usernameFragment || candidate.ufrag);
    }
    return 'candidate:' + sdp.join(' ');
  };
  
  // Parses an ice-options line, returns an array of option tags.
  // Sample input:
  // a=ice-options:foo bar
  SDPUtils.parseIceOptions = function(line) {
    return line.substring(14).split(' ');
  };
  
  // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
  // a=rtpmap:111 opus/48000/2
  SDPUtils.parseRtpMap = function(line) {
    let parts = line.substring(9).split(' ');
    const parsed = {
      payloadType: parseInt(parts.shift(), 10), // was: id
    };
  
    parts = parts[0].split('/');
  
    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    // legacy alias, got renamed back to channels in ORTC.
    parsed.numChannels = parsed.channels;
    return parsed;
  };
  
  // Generates a rtpmap line from RTCRtpCodecCapability or
  // RTCRtpCodecParameters.
  SDPUtils.writeRtpMap = function(codec) {
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    const channels = codec.channels || codec.numChannels || 1;
    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
        (channels !== 1 ? '/' + channels : '') + '\r\n';
  };
  
  // Parses a extmap line (headerextension from RFC 5285). Sample input:
  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
  SDPUtils.parseExtmap = function(line) {
    const parts = line.substring(9).split(' ');
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
      uri: parts[1],
      attributes: parts.slice(2).join(' '),
    };
  };
  
  // Generates an extmap line from RTCRtpHeaderExtensionParameters or
  // RTCRtpHeaderExtension.
  SDPUtils.writeExtmap = function(headerExtension) {
    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
        (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
        ' ' + headerExtension.uri +
        (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
        '\r\n';
  };
  
  // Parses a fmtp line, returns dictionary. Sample input:
  // a=fmtp:96 vbr=on;cng=on
  // Also deals with vbr=on; cng=on
  SDPUtils.parseFmtp = function(line) {
    const parsed = {};
    let kv;
    const parts = line.substring(line.indexOf(' ') + 1).split(';');
    for (let j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split('=');
      parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
  };
  
  // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeFmtp = function(codec) {
    let line = '';
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      const params = [];
      Object.keys(codec.parameters).forEach(param => {
        if (codec.parameters[param] !== undefined) {
          params.push(param + '=' + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
    }
    return line;
  };
  
  // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
  // a=rtcp-fb:98 nack rpsi
  SDPUtils.parseRtcpFb = function(line) {
    const parts = line.substring(line.indexOf(' ') + 1).split(' ');
    return {
      type: parts.shift(),
      parameter: parts.join(' '),
    };
  };
  
  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeRtcpFb = function(codec) {
    let lines = '';
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      // FIXME: special handling for trr-int?
      codec.rtcpFeedback.forEach(fb => {
        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
            '\r\n';
      });
    }
    return lines;
  };
  
  // Parses a RFC 5576 ssrc media attribute. Sample input:
  // a=ssrc:3735928559 cname:something
  SDPUtils.parseSsrcMedia = function(line) {
    const sp = line.indexOf(' ');
    const parts = {
      ssrc: parseInt(line.substring(7, sp), 10),
    };
    const colon = line.indexOf(':', sp);
    if (colon > -1) {
      parts.attribute = line.substring(sp + 1, colon);
      parts.value = line.substring(colon + 1);
    } else {
      parts.attribute = line.substring(sp + 1);
    }
    return parts;
  };
  
  // Parse a ssrc-group line (see RFC 5576). Sample input:
  // a=ssrc-group:semantics 12 34
  SDPUtils.parseSsrcGroup = function(line) {
    const parts = line.substring(13).split(' ');
    return {
      semantics: parts.shift(),
      ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
    };
  };
  
  // Extracts the MID (RFC 5888) from a media section.
  // Returns the MID or undefined if no mid line was found.
  SDPUtils.getMid = function(mediaSection) {
    const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
    if (mid) {
      return mid.substring(6);
    }
  };
  
  // Parses a fingerprint line for DTLS-SRTP.
  SDPUtils.parseFingerprint = function(line) {
    const parts = line.substring(14).split(' ');
    return {
      algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
      value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
    };
  };
  
  // Extracts DTLS parameters from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the fingerprint line as input. See also getIceParameters.
  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
    // Note: a=setup line is ignored since we use the 'auto' role in Edge.
    return {
      role: 'auto',
      fingerprints: lines.map(SDPUtils.parseFingerprint),
    };
  };
  
  // Serializes DTLS parameters to SDP.
  SDPUtils.writeDtlsParameters = function(params, setupType) {
    let sdp = 'a=setup:' + setupType + '\r\n';
    params.fingerprints.forEach(fp => {
      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
    });
    return sdp;
  };
  
  // Parses a=crypto lines into
  //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
  SDPUtils.parseCryptoLine = function(line) {
    const parts = line.substring(9).split(' ');
    return {
      tag: parseInt(parts[0], 10),
      cryptoSuite: parts[1],
      keyParams: parts[2],
      sessionParams: parts.slice(3),
    };
  };
  
  SDPUtils.writeCryptoLine = function(parameters) {
    return 'a=crypto:' + parameters.tag + ' ' +
      parameters.cryptoSuite + ' ' +
      (typeof parameters.keyParams === 'object'
        ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
        : parameters.keyParams) +
      (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
      '\r\n';
  };
  
  // Parses the crypto key parameters into
  //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
  SDPUtils.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf('inline:') !== 0) {
      return null;
    }
    const parts = keyParams.substring(7).split('|');
    return {
      keyMethod: 'inline',
      keySalt: parts[0],
      lifeTime: parts[1],
      mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
      mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
    };
  };
  
  SDPUtils.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ':'
      + keyParams.keySalt +
      (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
      (keyParams.mkiValue && keyParams.mkiLength
        ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
        : '');
  };
  
  // Extracts all SDES parameters.
  SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=crypto:');
    return lines.map(SDPUtils.parseCryptoLine);
  };
  
  // Parses ICE information from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the ice-ufrag and ice-pwd lines as input.
  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
    const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=ice-ufrag:')[0];
    const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=ice-pwd:')[0];
    if (!(ufrag && pwd)) {
      return null;
    }
    return {
      usernameFragment: ufrag.substring(12),
      password: pwd.substring(10),
    };
  };
  
  // Serializes ICE parameters to SDP.
  SDPUtils.writeIceParameters = function(params) {
    let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
        'a=ice-pwd:' + params.password + '\r\n';
    if (params.iceLite) {
      sdp += 'a=ice-lite\r\n';
    }
    return sdp;
  };
  
  // Parses the SDP media section and returns RTCRtpParameters.
  SDPUtils.parseRtpParameters = function(mediaSection) {
    const description = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: [],
    };
    const lines = SDPUtils.splitLines(mediaSection);
    const mline = lines[0].split(' ');
    description.profile = mline[2];
    for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
      const pt = mline[i];
      const rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
      if (rtpmapline) {
        const codec = SDPUtils.parseRtpMap(rtpmapline);
        const fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
        // Only the first a=fmtp:<pt> is considered.
        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
          .map(SDPUtils.parseRtcpFb);
        description.codecs.push(codec);
        // parse FEC mechanisms from rtpmap lines.
        switch (codec.name.toUpperCase()) {
          case 'RED':
          case 'ULPFEC':
            description.fecMechanisms.push(codec.name.toUpperCase());
            break;
          default: // only RED and ULPFEC are recognized as FEC mechanisms.
            break;
        }
      }
    }
    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
      description.headerExtensions.push(SDPUtils.parseExtmap(line));
    });
    const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
      .map(SDPUtils.parseRtcpFb);
    description.codecs.forEach(codec => {
      wildcardRtcpFb.forEach(fb=> {
        const duplicate = codec.rtcpFeedback.find(existingFeedback => {
          return existingFeedback.type === fb.type &&
            existingFeedback.parameter === fb.parameter;
        });
        if (!duplicate) {
          codec.rtcpFeedback.push(fb);
        }
      });
    });
    // FIXME: parse rtcp.
    return description;
  };
  
  // Generates parts of the SDP media section describing the capabilities /
  // parameters.
  SDPUtils.writeRtpDescription = function(kind, caps) {
    let sdp = '';
  
    // Build the mline.
    sdp += 'm=' + kind + ' ';
    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
    sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
    sdp += caps.codecs.map(codec => {
      if (codec.preferredPayloadType !== undefined) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(' ') + '\r\n';
  
    sdp += 'c=IN IP4 0.0.0.0\r\n';
    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';
  
    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
    caps.codecs.forEach(codec => {
      sdp += SDPUtils.writeRtpMap(codec);
      sdp += SDPUtils.writeFmtp(codec);
      sdp += SDPUtils.writeRtcpFb(codec);
    });
    let maxptime = 0;
    caps.codecs.forEach(codec => {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp += 'a=maxptime:' + maxptime + '\r\n';
    }
  
    if (caps.headerExtensions) {
      caps.headerExtensions.forEach(extension => {
        sdp += SDPUtils.writeExtmap(extension);
      });
    }
    // FIXME: write fecMechanisms.
    return sdp;
  };
  
  // Parses the SDP media section and returns an array of
  // RTCRtpEncodingParameters.
  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
    const encodingParameters = [];
    const description = SDPUtils.parseRtpParameters(mediaSection);
    const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
    const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;
  
    // filter a=ssrc:... cname:, ignore PlanB-msid
    const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(line => SDPUtils.parseSsrcMedia(line))
      .filter(parts => parts.attribute === 'cname');
    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    let secondarySsrc;
  
    const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
      .map(line => {
        const parts = line.substring(17).split(' ');
        return parts.map(part => parseInt(part, 10));
      });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }
  
    description.codecs.forEach(codec => {
      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
        let encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10),
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = {ssrc: secondarySsrc};
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc,
      });
    }
  
    // we support both b=AS and b=TIAS but interpret AS as TIAS.
    let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
    if (bandwidth.length) {
      if (bandwidth[0].indexOf('b=TIAS:') === 0) {
        bandwidth = parseInt(bandwidth[0].substring(7), 10);
      } else if (bandwidth[0].indexOf('b=AS:') === 0) {
        // use formula from JSEP to convert b=AS to TIAS value.
        bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
            - (50 * 40 * 8);
      } else {
        bandwidth = undefined;
      }
      encodingParameters.forEach(params => {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };
  
  // parses http://draft.ortc.org/#rtcrtcpparameters*
  SDPUtils.parseRtcpParameters = function(mediaSection) {
    const rtcpParameters = {};
  
    // Gets the first SSRC. Note that with RTX there might be multiple
    // SSRCs.
    const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(line => SDPUtils.parseSsrcMedia(line))
      .filter(obj => obj.attribute === 'cname')[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
  
    // Edge uses the compound attribute instead of reducedSize
    // compound is !reducedSize
    const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
  
    // parses the rtcp-mux attrbute.
    // Note that Edge does not support unmuxed RTCP.
    const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
    rtcpParameters.mux = mux.length > 0;
  
    return rtcpParameters;
  };
  
  SDPUtils.writeRtcpParameters = function(rtcpParameters) {
    let sdp = '';
    if (rtcpParameters.reducedSize) {
      sdp += 'a=rtcp-rsize\r\n';
    }
    if (rtcpParameters.mux) {
      sdp += 'a=rtcp-mux\r\n';
    }
    if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
      sdp += 'a=ssrc:' + rtcpParameters.ssrc +
        ' cname:' + rtcpParameters.cname + '\r\n';
    }
    return sdp;
  };
  
  
  // parses either a=msid: or a=ssrc:... msid lines and returns
  // the id of the MediaStream and MediaStreamTrack.
  SDPUtils.parseMsid = function(mediaSection) {
    let parts;
    const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
    if (spec.length === 1) {
      parts = spec[0].substring(7).split(' ');
      return {stream: parts[0], track: parts[1]};
    }
    const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(line => SDPUtils.parseSsrcMedia(line))
      .filter(msidParts => msidParts.attribute === 'msid');
    if (planB.length > 0) {
      parts = planB[0].value.split(' ');
      return {stream: parts[0], track: parts[1]};
    }
  };
  
  // SCTP
  // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
  // to draft-ietf-mmusic-sctp-sdp-05
  SDPUtils.parseSctpDescription = function(mediaSection) {
    const mline = SDPUtils.parseMLine(mediaSection);
    const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
    let maxMessageSize;
    if (maxSizeLine.length > 0) {
      maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
    }
    if (isNaN(maxMessageSize)) {
      maxMessageSize = 65536;
    }
    const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
    if (sctpPort.length > 0) {
      return {
        port: parseInt(sctpPort[0].substring(12), 10),
        protocol: mline.fmt,
        maxMessageSize,
      };
    }
    const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
    if (sctpMapLines.length > 0) {
      const parts = sctpMapLines[0]
        .substring(10)
        .split(' ');
      return {
        port: parseInt(parts[0], 10),
        protocol: parts[1],
        maxMessageSize,
      };
    }
  };
  
  // SCTP
  // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
  // support by now receiving in this format, unless we originally parsed
  // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
  // protocol of DTLS/SCTP -- without UDP/ or TCP/)
  SDPUtils.writeSctpDescription = function(media, sctp) {
    let output = [];
    if (media.protocol !== 'DTLS/SCTP') {
      output = [
        'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
        'c=IN IP4 0.0.0.0\r\n',
        'a=sctp-port:' + sctp.port + '\r\n',
      ];
    } else {
      output = [
        'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
        'c=IN IP4 0.0.0.0\r\n',
        'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
      ];
    }
    if (sctp.maxMessageSize !== undefined) {
      output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
    }
    return output.join('');
  };
  
  // Generate a session ID for SDP.
  // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
  // recommends using a cryptographically random +ve 64-bit value
  // but right now this should be acceptable and within the right range
  SDPUtils.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  };
  
  // Write boiler plate for start of SDP
  // sessId argument is optional - if not supplied it will
  // be generated randomly
  // sessVersion is optional and defaults to 2
  // sessUser is optional and defaults to 'thisisadapterortc'
  SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    let sessionId;
    const version = sessVer !== undefined ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils.generateSessionId();
    }
    const user = sessUser || 'thisisadapterortc';
    // FIXME: sess-id should be an NTP timestamp.
    return 'v=0\r\n' +
        'o=' + user + ' ' + sessionId + ' ' + version +
          ' IN IP4 127.0.0.1\r\n' +
        's=-\r\n' +
        't=0 0\r\n';
  };
  
  // Gets the direction from the mediaSection or the sessionpart.
  SDPUtils.getDirection = function(mediaSection, sessionpart) {
    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
    const lines = SDPUtils.splitLines(mediaSection);
    for (let i = 0; i < lines.length; i++) {
      switch (lines[i]) {
        case 'a=sendrecv':
        case 'a=sendonly':
        case 'a=recvonly':
        case 'a=inactive':
          return lines[i].substring(2);
        default:
          // FIXME: What should happen here?
      }
    }
    if (sessionpart) {
      return SDPUtils.getDirection(sessionpart);
    }
    return 'sendrecv';
  };
  
  SDPUtils.getKind = function(mediaSection) {
    const lines = SDPUtils.splitLines(mediaSection);
    const mline = lines[0].split(' ');
    return mline[0].substring(2);
  };
  
  SDPUtils.isRejected = function(mediaSection) {
    return mediaSection.split(' ', 2)[1] === '0';
  };
  
  SDPUtils.parseMLine = function(mediaSection) {
    const lines = SDPUtils.splitLines(mediaSection);
    const parts = lines[0].substring(2).split(' ');
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(' '),
    };
  };
  
  SDPUtils.parseOLine = function(mediaSection) {
    const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
    const parts = line.substring(2).split(' ');
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5],
    };
  };
  
  // a very naive interpretation of a valid SDP.
  SDPUtils.isValidSDP = function(blob) {
    if (typeof blob !== 'string' || blob.length === 0) {
      return false;
    }
    const lines = SDPUtils.splitLines(blob);
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
        return false;
      }
      // TODO: check the modifier a bit more.
    }
    return true;
  };
  
  // Expose public methods.
  if (typeof module === 'object') {
    module.exports = SDPUtils;
  }
  ",
  "export const validateId = (id: string): boolean => {
    // Allow empty ids
    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);
  };
  ",
  "export const randomToken = () => Math.random().toString(36).slice(2);
  ",
  "import { util } from "./util";
  import logger, { LogLevel } from "./logger";
  import { Socket } from "./socket";
  import { MediaConnection } from "./mediaconnection";
  import type { DataConnection } from "./dataconnection/DataConnection";
  import {
    ConnectionType,
    PeerErrorType,
    ServerMessageType,
    SocketEventType,
  } from "./enums";
  import type { ServerMessage } from "./servermessage";
  import { API } from "./api";
  import type {
    CallOption,
    PeerConnectOption,
    PeerJSOption,
  } from "./optionInterfaces";
  import { BinaryPack } from "./dataconnection/BufferedConnection/BinaryPack";
  import { Raw } from "./dataconnection/BufferedConnection/Raw";
  import { Json } from "./dataconnection/BufferedConnection/Json";
  
  import { EventEmitterWithError, PeerError } from "./peerError";
  
  class PeerOptions implements PeerJSOption {
    /**
     * Prints log messages depending on the debug level passed in.
     */
    debug?: LogLevel;
    /**
     * Server host. Defaults to `0.peerjs.com`.
     * Also accepts `'/'` to signify relative hostname.
     */
    host?: string;
    /**
     * Server port. Defaults to `443`.
     */
    port?: number;
    /**
     * The path where your self-hosted PeerServer is running. Defaults to `'/'`
     */
    path?: string;
    /**
     * API key for the PeerServer.
     * This is not used anymore.
     * @deprecated
     */
    key?: string;
    token?: string;
    /**
     * Configuration hash passed to RTCPeerConnection.
     * This hash contains any custom ICE/TURN server configuration.
     *
     * Defaults to {@apilink util.defaultConfig}
     */
    config?: any;
    /**
     * Set to true `true` if you're using TLS.
     * :::danger
     * If possible *always use TLS*
     * :::
     */
    secure?: boolean;
    pingInterval?: number;
    referrerPolicy?: ReferrerPolicy;
    logFunction?: (logLevel: LogLevel, ...rest: any[]) => void;
    serializers?: SerializerMapping;
  }
  
  export { type PeerOptions };
  
  export interface SerializerMapping {
    [key: string]: new (
      peerId: string,
      provider: Peer,
      options: any,
    ) => DataConnection;
  }
  
  export interface PeerEvents {
    /**
     * Emitted when a connection to the PeerServer is established.
     *
     * You may use the peer before this is emitted, but messages to the server will be queued. <code>id</code> is the brokering ID of the peer (which was either provided in the constructor or assigned by the server).<span class='tip'>You should not wait for this event before connecting to other peers if connection speed is important.</span>
     */
    open: (id: string) => void;
    /**
     * Emitted when a new data connection is established from a remote peer.
     */
    connection: (dataConnection: DataConnection) => void;
    /**
     * Emitted when a remote peer attempts to call you.
     */
    call: (mediaConnection: MediaConnection) => void;
    /**
     * Emitted when the peer is destroyed and can no longer accept or create any new connections.
     */
    close: () => void;
    /**
     * Emitted when the peer is disconnected from the signalling server
     */
    disconnected: (currentId: string) => void;
    /**
     * Errors on the peer are almost always fatal and will destroy the peer.
     *
     * Errors from the underlying socket and PeerConnections are forwarded here.
     */
    error: (error: PeerError<`${PeerErrorType}`>) => void;
  }
  /**
   * A peer who can initiate connections with other peers.
   */
  export class Peer extends EventEmitterWithError<PeerErrorType, PeerEvents> {
    private static readonly DEFAULT_KEY = "peerjs";
  
    protected readonly _serializers: SerializerMapping = {
      raw: Raw,
      json: Json,
      binary: BinaryPack,
      "binary-utf8": BinaryPack,
  
      default: BinaryPack,
    };
    private readonly _options: PeerOptions;
    private readonly _api: API;
    private readonly _socket: Socket;
  
    private _id: string | null = null;
    private _lastServerId: string | null = null;
  
    // States.
    private _destroyed = false; // Connections have been killed
    private _disconnected = false; // Connection to PeerServer killed but P2P connections still active
    private _open = false; // Sockets and such are not yet open.
    private readonly _connections: Map<
      string,
      (DataConnection | MediaConnection)[]
    > = new Map(); // All connections for this peer.
    private readonly _lostMessages: Map<string, ServerMessage[]> = new Map(); // src => [list of messages]
    /**
     * The brokering ID of this peer
     *
     * If no ID was specified in {@apilink Peer | the constructor},
     * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.
     */
    get id() {
      return this._id;
    }
  
    get options() {
      return this._options;
    }
  
    get open() {
      return this._open;
    }
  
    /**
     * @internal
     */
    get socket() {
      return this._socket;
    }
  
    /**
     * A hash of all connections associated with this peer, keyed by the remote peer's ID.
     * @deprecated
     * Return type will change from Object to Map<string,[]>
     */
    get connections(): Object {
      const plainConnections = Object.create(null);
  
      for (const [k, v] of this._connections) {
        plainConnections[k] = v;
      }
  
      return plainConnections;
    }
  
    /**
     * true if this peer and all of its connections can no longer be used.
     */
    get destroyed() {
      return this._destroyed;
    }
    /**
     * false if there is an active connection to the PeerServer.
     */
    get disconnected() {
      return this._disconnected;
    }
  
    /**
     * A peer can connect to other peers and listen for connections.
     */
    constructor();
  
    /**
     * A peer can connect to other peers and listen for connections.
     * @param options for specifying details about PeerServer
     */
    constructor(options: PeerOptions);
  
    /**
     * A peer can connect to other peers and listen for connections.
     * @param id Other peers can connect to this peer using the provided ID.
     *     If no ID is given, one will be generated by the brokering server.
     * The ID must start and end with an alphanumeric character (lower or upper case character or a digit). In the middle of the ID spaces, dashes (-) and underscores (_) are allowed. Use {@apilink PeerOptions.metadata } to send identifying information.
     * @param options for specifying details about PeerServer
     */
    constructor(id: string, options?: PeerOptions);
  
    constructor(id?: string | PeerOptions, options?: PeerOptions) {
      super();
  
      let userId: string | undefined;
  
      // Deal with overloading
      if (id && id.constructor == Object) {
        options = id as PeerOptions;
      } else if (id) {
        userId = id.toString();
      }
  
      // Configurize options
      options = {
        debug: 0, // 1: Errors, 2: Warnings, 3: All logs
        host: util.CLOUD_HOST,
        port: util.CLOUD_PORT,
        path: "/",
        key: Peer.DEFAULT_KEY,
        token: util.randomToken(),
        config: util.defaultConfig,
        referrerPolicy: "strict-origin-when-cross-origin",
        serializers: {},
        ...options,
      };
      this._options = options;
      this._serializers = { ...this._serializers, ...this.options.serializers };
  
      // Detect relative URL host.
      if (this._options.host === "/") {
        this._options.host = window.location.hostname;
      }
  
      // Set path correctly.
      if (this._options.path) {
        if (this._options.path[0] !== "/") {
          this._options.path = "/" + this._options.path;
        }
        if (this._options.path[this._options.path.length - 1] !== "/") {
          this._options.path += "/";
        }
      }
  
      // Set whether we use SSL to same as current host
      if (
        this._options.secure === undefined &&
        this._options.host !== util.CLOUD_HOST
      ) {
        this._options.secure = util.isSecure();
      } else if (this._options.host == util.CLOUD_HOST) {
        this._options.secure = true;
      }
      // Set a custom log function if present
      if (this._options.logFunction) {
        logger.setLogFunction(this._options.logFunction);
      }
  
      logger.logLevel = this._options.debug || 0;
  
      this._api = new API(options);
      this._socket = this._createServerConnection();
  
      // Sanity checks
      // Ensure WebRTC supported
      if (!util.supports.audioVideo && !util.supports.data) {
        this._delayedAbort(
          PeerErrorType.BrowserIncompatible,
          "The current browser does not support WebRTC",
        );
        return;
      }
  
      // Ensure alphanumeric id
      if (!!userId && !util.validateId(userId)) {
        this._delayedAbort(PeerErrorType.InvalidID, `ID "${userId}" is invalid`);
        return;
      }
  
      if (userId) {
        this._initialize(userId);
      } else {
        this._api
          .retrieveId()
          .then((id) => this._initialize(id))
          .catch((error) => this._abort(PeerErrorType.ServerError, error));
      }
    }
  
    private _createServerConnection(): Socket {
      const socket = new Socket(
        this._options.secure,
        this._options.host!,
        this._options.port!,
        this._options.path!,
        this._options.key!,
        this._options.pingInterval,
      );
  
      socket.on(SocketEventType.Message, (data: ServerMessage) => {
        this._handleMessage(data);
      });
  
      socket.on(SocketEventType.Error, (error: string) => {
        this._abort(PeerErrorType.SocketError, error);
      });
  
      socket.on(SocketEventType.Disconnected, () => {
        if (this.disconnected) {
          return;
        }
  
        this.emitError(PeerErrorType.Network, "Lost connection to server.");
        this.disconnect();
      });
  
      socket.on(SocketEventType.Close, () => {
        if (this.disconnected) {
          return;
        }
  
        this._abort(
          PeerErrorType.SocketClosed,
          "Underlying socket is already closed.",
        );
      });
  
      return socket;
    }
  
    /** Initialize a connection with the server. */
    private _initialize(id: string): void {
      this._id = id;
      this.socket.start(id, this._options.token!);
    }
  
    /** Handles messages from the server. */
    private _handleMessage(message: ServerMessage): void {
      const type = message.type;
      const payload = message.payload;
      const peerId = message.src;
  
      switch (type) {
        case ServerMessageType.Open: // The connection to the server is open.
          this._lastServerId = this.id;
          this._open = true;
          this.emit("open", this.id);
          break;
        case ServerMessageType.Error: // Server error.
          this._abort(PeerErrorType.ServerError, payload.msg);
          break;
        case ServerMessageType.IdTaken: // The selected ID is taken.
          this._abort(PeerErrorType.UnavailableID, `ID "${this.id}" is taken`);
          break;
        case ServerMessageType.InvalidKey: // The given API key cannot be found.
          this._abort(
            PeerErrorType.InvalidKey,
            `API KEY "${this._options.key}" is invalid`,
          );
          break;
        case ServerMessageType.Leave: // Another peer has closed its connection to this peer.
          logger.log(`Received leave message from ${peerId}`);
          this._cleanupPeer(peerId);
          this._connections.delete(peerId);
          break;
        case ServerMessageType.Expire: // The offer sent to a peer has expired without response.
          this.emitError(
            PeerErrorType.PeerUnavailable,
            `Could not connect to peer ${peerId}`,
          );
          break;
        case ServerMessageType.Offer: {
          // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
          const connectionId = payload.connectionId;
          let connection = this.getConnection(peerId, connectionId);
  
          if (connection) {
            connection.close();
            logger.warn(
              `Offer received for existing Connection ID:${connectionId}`,
            );
          }
  
          // Create a new connection.
          if (payload.type === ConnectionType.Media) {
            const mediaConnection = new MediaConnection(peerId, this, {
              connectionId: connectionId,
              _payload: payload,
              metadata: payload.metadata,
            });
            connection = mediaConnection;
            this._addConnection(peerId, connection);
            this.emit("call", mediaConnection);
          } else if (payload.type === ConnectionType.Data) {
            const dataConnection = new this._serializers[payload.serialization](
              peerId,
              this,
              {
                connectionId: connectionId,
                _payload: payload,
                metadata: payload.metadata,
                label: payload.label,
                serialization: payload.serialization,
                reliable: payload.reliable,
              },
            );
            connection = dataConnection;
  
            this._addConnection(peerId, connection);
            this.emit("connection", dataConnection);
          } else {
            logger.warn(`Received malformed connection type:${payload.type}`);
            return;
          }
  
          // Find messages.
          const messages = this._getMessages(connectionId);
          for (const message of messages) {
            connection.handleMessage(message);
          }
  
          break;
        }
        default: {
          if (!payload) {
            logger.warn(
              `You received a malformed message from ${peerId} of type ${type}`,
            );
            return;
          }
  
          const connectionId = payload.connectionId;
          const connection = this.getConnection(peerId, connectionId);
  
          if (connection && connection.peerConnection) {
            // Pass it on.
            connection.handleMessage(message);
          } else if (connectionId) {
            // Store for possible later use
            this._storeMessage(connectionId, message);
          } else {
            logger.warn("You received an unrecognized message:", message);
          }
          break;
        }
      }
    }
  
    /** Stores messages without a set up connection, to be claimed later. */
    private _storeMessage(connectionId: string, message: ServerMessage): void {
      if (!this._lostMessages.has(connectionId)) {
        this._lostMessages.set(connectionId, []);
      }
  
      this._lostMessages.get(connectionId).push(message);
    }
  
    /**
     * Retrieve messages from lost message store
     * @internal
     */
    //TODO Change it to private
    public _getMessages(connectionId: string): ServerMessage[] {
      const messages = this._lostMessages.get(connectionId);
  
      if (messages) {
        this._lostMessages.delete(connectionId);
        return messages;
      }
  
      return [];
    }
  
    /**
     * Connects to the remote peer specified by id and returns a data connection.
     * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).
     * @param options for specifying details about Peer Connection
     */
    connect(peer: string, options: PeerConnectOption = {}): DataConnection {
      options = {
        serialization: "default",
        ...options,
      };
      if (this.disconnected) {
        logger.warn(
          "You cannot connect to a new Peer because you called " +
            ".disconnect() on this Peer and ended your connection with the " +
            "server. You can create a new Peer to reconnect, or call reconnect " +
            "on this peer if you believe its ID to still be available.",
        );
        this.emitError(
          PeerErrorType.Disconnected,
          "Cannot connect to new Peer after disconnecting from server.",
        );
        return;
      }
  
      const dataConnection = new this._serializers[options.serialization](
        peer,
        this,
        options,
      );
      this._addConnection(peer, dataConnection);
      return dataConnection;
    }
  
    /**
     * Calls the remote peer specified by id and returns a media connection.
     * @param peer The brokering ID of the remote peer (their peer.id).
     * @param stream The caller's media stream
     * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
     */
    call(
      peer: string,
      stream: MediaStream,
      options: CallOption = {},
    ): MediaConnection {
      if (this.disconnected) {
        logger.warn(
          "You cannot connect to a new Peer because you called " +
            ".disconnect() on this Peer and ended your connection with the " +
            "server. You can create a new Peer to reconnect.",
        );
        this.emitError(
          PeerErrorType.Disconnected,
          "Cannot connect to new Peer after disconnecting from server.",
        );
        return;
      }
  
      if (!stream) {
        logger.error(
          "To call a peer, you must provide a stream from your browser's `getUserMedia`.",
        );
        return;
      }
  
      const mediaConnection = new MediaConnection(peer, this, {
        ...options,
        _stream: stream,
      });
      this._addConnection(peer, mediaConnection);
      return mediaConnection;
    }
  
    /** Add a data/media connection to this peer. */
    private _addConnection(
      peerId: string,
      connection: MediaConnection | DataConnection,
    ): void {
      logger.log(
        `add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`,
      );
  
      if (!this._connections.has(peerId)) {
        this._connections.set(peerId, []);
      }
      this._connections.get(peerId).push(connection);
    }
  
    //TODO should be private
    _removeConnection(connection: DataConnection | MediaConnection): void {
      const connections = this._connections.get(connection.peer);
  
      if (connections) {
        const index = connections.indexOf(connection);
  
        if (index !== -1) {
          connections.splice(index, 1);
        }
      }
  
      //remove from lost messages
      this._lostMessages.delete(connection.connectionId);
    }
  
    /** Retrieve a data/media connection for this peer. */
    getConnection(
      peerId: string,
      connectionId: string,
    ): null | DataConnection | MediaConnection {
      const connections = this._connections.get(peerId);
      if (!connections) {
        return null;
      }
  
      for (const connection of connections) {
        if (connection.connectionId === connectionId) {
          return connection;
        }
      }
  
      return null;
    }
  
    private _delayedAbort(type: PeerErrorType, message: string | Error): void {
      setTimeout(() => {
        this._abort(type, message);
      }, 0);
    }
  
    /**
     * Emits an error message and destroys the Peer.
     * The Peer is not destroyed if it's in a disconnected state, in which case
     * it retains its disconnected state and its existing connections.
     */
    private _abort(type: PeerErrorType, message: string | Error): void {
      logger.error("Aborting!");
  
      this.emitError(type, message);
  
      if (!this._lastServerId) {
        this.destroy();
      } else {
        this.disconnect();
      }
    }
  
    /**
     * Destroys the Peer: closes all active connections as well as the connection
     * to the server.
     *
     * :::caution
     * This cannot be undone; the respective peer object will no longer be able
     * to create or receive any connections, its ID will be forfeited on the server,
     * and all of its data and media connections will be closed.
     * :::
     */
    destroy(): void {
      if (this.destroyed) {
        return;
      }
  
      logger.log(`Destroy peer with ID:${this.id}`);
  
      this.disconnect();
      this._cleanup();
  
      this._destroyed = true;
  
      this.emit("close");
    }
  
    /** Disconnects every connection on this peer. */
    private _cleanup(): void {
      for (const peerId of this._connections.keys()) {
        this._cleanupPeer(peerId);
        this._connections.delete(peerId);
      }
  
      this.socket.removeAllListeners();
    }
  
    /** Closes all connections to this peer. */
    private _cleanupPeer(peerId: string): void {
      const connections = this._connections.get(peerId);
  
      if (!connections) return;
  
      for (const connection of connections) {
        connection.close();
      }
    }
  
    /**
     * Disconnects the Peer's connection to the PeerServer. Does not close any
     *  active connections.
     * Warning: The peer can no longer create or accept connections after being
     *  disconnected. It also cannot reconnect to the server.
     */
    disconnect(): void {
      if (this.disconnected) {
        return;
      }
  
      const currentId = this.id;
  
      logger.log(`Disconnect peer with ID:${currentId}`);
  
      this._disconnected = true;
      this._open = false;
  
      this.socket.close();
  
      this._lastServerId = currentId;
      this._id = null;
  
      this.emit("disconnected", currentId);
    }
  
    /** Attempts to reconnect with the same ID.
     *
     * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.
     * Destroyed peers cannot be reconnected.
     * If the connection fails (as an example, if the peer's old ID is now taken),
     * the peer's existing connections will not close, but any associated errors events will fire.
     */
    reconnect(): void {
      if (this.disconnected && !this.destroyed) {
        logger.log(
          `Attempting reconnection to server with ID ${this._lastServerId}`,
        );
        this._disconnected = false;
        this._initialize(this._lastServerId!);
      } else if (this.destroyed) {
        throw new Error(
          "This peer cannot reconnect to the server. It has already been destroyed.",
        );
      } else if (!this.disconnected && !this.open) {
        // Do nothing. We're still connecting the first time.
        logger.error(
          "In a hurry? We're still trying to make the initial connection!",
        );
      } else {
        throw new Error(
          `Peer ${this.id} cannot reconnect because it is not disconnected from the server!`,
        );
      }
    }
  
    /**
     * Get a list of available peer IDs. If you're running your own server, you'll
     * want to set allow_discovery: true in the PeerServer options. If you're using
     * the cloud server, email team@peerjs.com to get the functionality enabled for
     * your key.
     */
    listAllPeers(cb = (_: any[]) => {}): void {
      this._api
        .listAllPeers()
        .then((peers) => cb(peers))
        .catch((error) => this._abort(PeerErrorType.ServerError, error));
    }
  }
  ",
  "const LOG_PREFIX = "PeerJS: ";
  
  /*
  Prints log messages depending on the debug level passed in. Defaults to 0.
  0  Prints no logs.
  1  Prints only errors.
  2  Prints errors and warnings.
  3  Prints all logs.
  */
  export enum LogLevel {
    /**
     * Prints no logs.
     */
    Disabled,
    /**
     * Prints only errors.
     */
    Errors,
    /**
     * Prints errors and warnings.
     */
    Warnings,
    /**
     * Prints all logs.
     */
    All,
  }
  
  class Logger {
    private _logLevel = LogLevel.Disabled;
  
    get logLevel(): LogLevel {
      return this._logLevel;
    }
  
    set logLevel(logLevel: LogLevel) {
      this._logLevel = logLevel;
    }
  
    log(...args: any[]) {
      if (this._logLevel >= LogLevel.All) {
        this._print(LogLevel.All, ...args);
      }
    }
  
    warn(...args: any[]) {
      if (this._logLevel >= LogLevel.Warnings) {
        this._print(LogLevel.Warnings, ...args);
      }
    }
  
    error(...args: any[]) {
      if (this._logLevel >= LogLevel.Errors) {
        this._print(LogLevel.Errors, ...args);
      }
    }
  
    setLogFunction(fn: (logLevel: LogLevel, ..._: any[]) => void): void {
      this._print = fn;
    }
  
    private _print(logLevel: LogLevel, ...rest: any[]): void {
      const copy = [LOG_PREFIX, ...rest];
  
      for (const i in copy) {
        if (copy[i] instanceof Error) {
          copy[i] = "(" + copy[i].name + ") " + copy[i].message;
        }
      }
  
      if (logLevel >= LogLevel.All) {
        console.log(...copy);
      } else if (logLevel >= LogLevel.Warnings) {
        console.warn("WARNING", ...copy);
      } else if (logLevel >= LogLevel.Errors) {
        console.error("ERROR", ...copy);
      }
    }
  }
  
  export default new Logger();
  ",
  "import { EventEmitter } from "eventemitter3";
  import logger from "./logger";
  import { ServerMessageType, SocketEventType } from "./enums";
  import { version } from "../package.json";
  
  /**
   * An abstraction on top of WebSockets to provide fastest
   * possible connection for peers.
   */
  export class Socket extends EventEmitter {
    private _disconnected: boolean = true;
    private _id?: string;
    private _messagesQueue: Array<object> = [];
    private _socket?: WebSocket;
    private _wsPingTimer?: any;
    private readonly _baseUrl: string;
  
    constructor(
      secure: any,
      host: string,
      port: number,
      path: string,
      key: string,
      private readonly pingInterval: number = 5000,
    ) {
      super();
  
      const wsProtocol = secure ? "wss://" : "ws://";
  
      this._baseUrl = wsProtocol + host + ":" + port + path + "peerjs?key=" + key;
    }
  
    start(id: string, token: string): void {
      this._id = id;
  
      const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;
  
      if (!!this._socket || !this._disconnected) {
        return;
      }
  
      this._socket = new WebSocket(wsUrl + "&version=" + version);
      this._disconnected = false;
  
      this._socket.onmessage = (event) => {
        let data;
  
        try {
          data = JSON.parse(event.data);
          logger.log("Server message received:", data);
        } catch (e) {
          logger.log("Invalid server message", event.data);
          return;
        }
  
        this.emit(SocketEventType.Message, data);
      };
  
      this._socket.onclose = (event) => {
        if (this._disconnected) {
          return;
        }
  
        logger.log("Socket closed.", event);
  
        this._cleanup();
        this._disconnected = true;
  
        this.emit(SocketEventType.Disconnected);
      };
  
      // Take care of the queue of connections if necessary and make sure Peer knows
      // socket is open.
      this._socket.onopen = () => {
        if (this._disconnected) {
          return;
        }
  
        this._sendQueuedMessages();
  
        logger.log("Socket open");
  
        this._scheduleHeartbeat();
      };
    }
  
    private _scheduleHeartbeat(): void {
      this._wsPingTimer = setTimeout(() => {
        this._sendHeartbeat();
      }, this.pingInterval);
    }
  
    private _sendHeartbeat(): void {
      if (!this._wsOpen()) {
        logger.log(`Cannot send heartbeat, because socket closed`);
        return;
      }
  
      const message = JSON.stringify({ type: ServerMessageType.Heartbeat });
  
      this._socket!.send(message);
  
      this._scheduleHeartbeat();
    }
  
    /** Is the websocket currently open? */
    private _wsOpen(): boolean {
      return !!this._socket && this._socket.readyState === 1;
    }
  
    /** Send queued messages. */
    private _sendQueuedMessages(): void {
      //Create copy of queue and clear it,
      //because send method push the message back to queue if smth will go wrong
      const copiedQueue = [...this._messagesQueue];
      this._messagesQueue = [];
  
      for (const message of copiedQueue) {
        this.send(message);
      }
    }
  
    /** Exposed send for DC & Peer. */
    send(data: any): void {
      if (this._disconnected) {
        return;
      }
  
      // If we didn't get an ID yet, we can't yet send anything so we should queue
      // up these messages.
      if (!this._id) {
        this._messagesQueue.push(data);
        return;
      }
  
      if (!data.type) {
        this.emit(SocketEventType.Error, "Invalid message");
        return;
      }
  
      if (!this._wsOpen()) {
        return;
      }
  
      const message = JSON.stringify(data);
  
      this._socket!.send(message);
    }
  
    close(): void {
      if (this._disconnected) {
        return;
      }
  
      this._cleanup();
  
      this._disconnected = true;
    }
  
    private _cleanup(): void {
      if (this._socket) {
        this._socket.onopen =
          this._socket.onmessage =
          this._socket.onclose =
            null;
        this._socket.close();
        this._socket = undefined;
      }
  
      clearTimeout(this._wsPingTimer!);
    }
  }
  ",
  "'use strict';
  
  var has = Object.prototype.hasOwnProperty
    , prefix = '~';
  
  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}
  
  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);
  
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }
  
  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  
  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }
  
    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;
  
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
  
    return emitter;
  }
  
  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  
  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  
  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;
  
    if (this._eventsCount === 0) return names;
  
    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
  
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
  
    return names;
  };
  
  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];
  
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
  
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
  
    return ee;
  };
  
  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];
  
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  
  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events[evt]) return false;
  
    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;
  
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
  
      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
  
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;
  
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
  
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
  
    return true;
  };
  
  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  
  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  
  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
  
    var listeners = this._events[evt];
  
    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
  
      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
  
    return this;
  };
  
  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
  
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
  
    return this;
  };
  
  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;
  
  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;
  
  //
  // Expose the module.
  //
  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
  ",
  "export enum ConnectionType {
    Data = "data",
    Media = "media",
  }
  
  export enum PeerErrorType {
    /**
     * The client's browser does not support some or all WebRTC features that you are trying to use.
     */
    BrowserIncompatible = "browser-incompatible",
    /**
     * You've already disconnected this peer from the server and can no longer make any new connections on it.
     */
    Disconnected = "disconnected",
    /**
     * The ID passed into the Peer constructor contains illegal characters.
     */
    InvalidID = "invalid-id",
    /**
     * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).
     */
    InvalidKey = "invalid-key",
    /**
     * Lost or cannot establish a connection to the signalling server.
     */
    Network = "network",
    /**
     * The peer you're trying to connect to does not exist.
     */
    PeerUnavailable = "peer-unavailable",
    /**
     * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.
     */
    SslUnavailable = "ssl-unavailable",
    /**
     * Unable to reach the server.
     */
    ServerError = "server-error",
    /**
     * An error from the underlying socket.
     */
    SocketError = "socket-error",
    /**
     * The underlying socket closed unexpectedly.
     */
    SocketClosed = "socket-closed",
    /**
     * The ID passed into the Peer constructor is already taken.
     *
     * :::caution
     * This error is not fatal if your peer has open peer-to-peer connections.
     * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,
     * but its old ID has now been taken.
     * :::
     */
    UnavailableID = "unavailable-id",
    /**
     * Native WebRTC errors.
     */
    WebRTC = "webrtc",
  }
  
  export enum BaseConnectionErrorType {
    NegotiationFailed = "negotiation-failed",
    ConnectionClosed = "connection-closed",
  }
  
  export enum DataConnectionErrorType {
    NotOpenYet = "not-open-yet",
    MessageToBig = "message-too-big",
  }
  
  export enum SerializationType {
    Binary = "binary",
    BinaryUTF8 = "binary-utf8",
    JSON = "json",
    None = "raw",
  }
  
  export enum SocketEventType {
    Message = "message",
    Disconnected = "disconnected",
    Error = "error",
    Close = "close",
  }
  
  export enum ServerMessageType {
    Heartbeat = "HEARTBEAT",
    Candidate = "CANDIDATE",
    Offer = "OFFER",
    Answer = "ANSWER",
    Open = "OPEN", // The connection to the server is open.
    Error = "ERROR", // Server error.
    IdTaken = "ID-TAKEN", // The selected ID is taken.
    InvalidKey = "INVALID-KEY", // The given API key cannot be found.
    Leave = "LEAVE", // Another peer has closed its connection to this peer.
    Expire = "EXPIRE", // The offer sent to a peer has expired without response.
  }
  ",
  "{
    "name": "peerjs",
    "version": "1.5.2",
    "keywords": [
      "peerjs",
      "webrtc",
      "p2p",
      "rtc"
    ],
    "description": "PeerJS client",
    "homepage": "https://peerjs.com",
    "bugs": {
      "url": "https://github.com/peers/peerjs/issues"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/peers/peerjs"
    },
    "license": "MIT",
    "contributors": [
      "Michelle Bu <michelle@michellebu.com>",
      "afrokick <devbyru@gmail.com>",
      "ericz <really.ez@gmail.com>",
      "Jairo <kidandcat@gmail.com>",
      "Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>",
      "Jairo Caro-Accino Viciana <jairo@galax.be>",
      "Carlos Caballero <carlos.caballero.gonzalez@gmail.com>",
      "hc <hheennrryy@gmail.com>",
      "Muhammad Asif <capripio@gmail.com>",
      "PrashoonB <prashoonbhattacharjee@gmail.com>",
      "Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>",
      "akotynski <aleksanderkotbury@gmail.com>",
      "lmb <i@lmb.io>",
      "Jairooo <jairocaro@msn.com>",
      "Moritz Stckler <moritz.stueckler@gmail.com>",
      "Simon <crydotsnakegithub@gmail.com>",
      "Denis Lukov <denismassters@gmail.com>",
      "Philipp Hancke <fippo@andyet.net>",
      "Hans Oksendahl <hansoksendahl@gmail.com>",
      "Jess <jessachandler@gmail.com>",
      "khankuan <khankuan@gmail.com>",
      "DUODVK <kurmanov.work@gmail.com>",
      "XiZhao <kwang1imsa@gmail.com>",
      "Matthias Lohr <matthias@lohr.me>",
      "=frank tree <=frnktrb@googlemail.com>",
      "Andre Eckardt <aeckardt@outlook.com>",
      "Chris Cowan <agentme49@gmail.com>",
      "Alex Chuev <alex@chuev.com>",
      "alxnull <alxnull@e.mail.de>",
      "Yemel Jardi <angel.jardi@gmail.com>",
      "Ben Parnell <benjaminparnell.94@gmail.com>",
      "Benny Lichtner <bennlich@gmail.com>",
      "fresheneesz <bitetrudpublic@gmail.com>",
      "bob.barstead@exaptive.com <bob.barstead@exaptive.com>",
      "chandika <chandika@gmail.com>",
      "emersion <contact@emersion.fr>",
      "Christopher Van <cvan@users.noreply.github.com>",
      "eddieherm <edhermoso@gmail.com>",
      "Eduardo Pinho <enet4mikeenet@gmail.com>",
      "Evandro Zanatta <ezanatta@tray.net.br>",
      "Gardner Bickford <gardner@users.noreply.github.com>",
      "Gian Luca <gianluca.cecchi@cynny.com>",
      "PatrickJS <github@gdi2290.com>",
      "jonnyf <github@jonathanfoss.co.uk>",
      "Hizkia Felix <hizkifw@gmail.com>",
      "Hristo Oskov <hristo.oskov@gmail.com>",
      "Isaac Madwed <i.madwed@gmail.com>",
      "Ilya Konanykhin <ilya.konanykhin@gmail.com>",
      "jasonbarry <jasbarry@me.com>",
      "Jonathan Burke <jonathan.burke.1311@googlemail.com>",
      "Josh Hamit <josh.hamit@gmail.com>",
      "Jordan Austin <jrax86@gmail.com>",
      "Joel Wetzell <jwetzell@yahoo.com>",
      "xizhao <kevin.wang@cloudera.com>",
      "Alberto Torres <kungfoobar@gmail.com>",
      "Jonathan Mayol <mayoljonathan@gmail.com>",
      "Jefferson Felix <me@jsfelix.dev>",
      "Rolf Erik Lekang <me@rolflekang.com>",
      "Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>",
      "Pepijn de Vos <pepijndevos@gmail.com>",
      "JooYoung <qkdlql@naver.com>",
      "Tobias Speicher <rootcommander@gmail.com>",
      "Steve Blaurock <sblaurock@gmail.com>",
      "Kyrylo Shegeda <shegeda@ualberta.ca>",
      "Diwank Singh Tomer <singh@diwank.name>",
      "Soren Balko <Soeren.Balko@gmail.com>",
      "Arpit Solanki <solankiarpit1997@gmail.com>",
      "Yuki Ito <yuki@gnnk.net>",
      "Artur Zayats <zag2art@gmail.com>"
    ],
    "funding": {
      "type": "opencollective",
      "url": "https://opencollective.com/peer"
    },
    "collective": {
      "type": "opencollective",
      "url": "https://opencollective.com/peer"
    },
    "files": [
      "dist/*"
    ],
    "sideEffects": [
      "lib/global.ts",
      "lib/supports.ts"
    ],
    "main": "dist/bundler.cjs",
    "module": "dist/bundler.mjs",
    "browser-minified": "dist/peerjs.min.js",
    "browser-unminified": "dist/peerjs.js",
    "browser-minified-cbor": "dist/serializer.cbor.mjs",
    "browser-minified-msgpack": "dist/serializer.msgpack.mjs",
    "types": "dist/types.d.ts",
    "engines": {
      "node": ">= 14"
    },
    "targets": {
      "types": {
        "source": "lib/exports.ts"
      },
      "main": {
        "source": "lib/exports.ts",
        "sourceMap": {
          "inlineSources": true
        }
      },
      "module": {
        "source": "lib/exports.ts",
        "includeNodeModules": [
          "eventemitter3"
        ],
        "sourceMap": {
          "inlineSources": true
        }
      },
      "browser-minified": {
        "context": "browser",
        "outputFormat": "global",
        "optimize": true,
        "engines": {
          "browsers": "chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"
        },
        "source": "lib/global.ts"
      },
      "browser-unminified": {
        "context": "browser",
        "outputFormat": "global",
        "optimize": false,
        "engines": {
          "browsers": "chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"
        },
        "source": "lib/global.ts"
      },
      "browser-minified-cbor": {
        "context": "browser",
        "outputFormat": "esmodule",
        "isLibrary": true,
        "optimize": true,
        "engines": {
          "browsers": "chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"
        },
        "source": "lib/dataconnection/StreamConnection/Cbor.ts"
      },
      "browser-minified-msgpack": {
        "context": "browser",
        "outputFormat": "esmodule",
        "isLibrary": true,
        "optimize": true,
        "engines": {
          "browsers": "chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"
        },
        "source": "lib/dataconnection/StreamConnection/MsgPack.ts"
      }
    },
    "scripts": {
      "contributors": "git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \"chore(contributors): update and sort contributors list\"",
      "check": "tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit",
      "watch": "parcel watch",
      "build": "rm -rf dist && parcel build",
      "prepublishOnly": "npm run build",
      "test": "jest",
      "test:watch": "jest --watch",
      "coverage": "jest --coverage --collectCoverageFrom=\"./lib/**\"",
      "format": "prettier --write .",
      "format:check": "prettier --check .",
      "semantic-release": "semantic-release",
      "e2e": "wdio run e2e/wdio.local.conf.ts",
      "e2e:bstack": "wdio run e2e/wdio.bstack.conf.ts"
    },
    "devDependencies": {
      "@parcel/config-default": "^2.9.3",
      "@parcel/packager-ts": "^2.9.3",
      "@parcel/transformer-typescript-tsc": "^2.9.3",
      "@parcel/transformer-typescript-types": "^2.9.3",
      "@semantic-release/changelog": "^6.0.1",
      "@semantic-release/git": "^10.0.1",
      "@swc/core": "^1.3.27",
      "@swc/jest": "^0.2.24",
      "@types/jasmine": "^4.3.4",
      "@wdio/browserstack-service": "^8.11.2",
      "@wdio/cli": "^8.11.2",
      "@wdio/globals": "^8.11.2",
      "@wdio/jasmine-framework": "^8.11.2",
      "@wdio/local-runner": "^8.11.2",
      "@wdio/spec-reporter": "^8.11.2",
      "@wdio/types": "^8.10.4",
      "http-server": "^14.1.1",
      "jest": "^29.3.1",
      "jest-environment-jsdom": "^29.3.1",
      "mock-socket": "^9.0.0",
      "parcel": "^2.9.3",
      "prettier": "^3.0.0",
      "semantic-release": "^21.0.0",
      "ts-node": "^10.9.1",
      "typescript": "^5.0.0",
      "wdio-geckodriver-service": "^5.0.1"
    },
    "dependencies": {
      "@msgpack/msgpack": "^2.8.0",
      "cbor-x": "1.5.4",
      "eventemitter3": "^4.0.7",
      "peerjs-js-binarypack": "^2.1.0",
      "webrtc-adapter": "^8.0.0"
    },
    "alias": {
      "process": false,
      "buffer": false
    }
  }
  ",
  "import { util } from "./util";
  import logger from "./logger";
  import { Negotiator } from "./negotiator";
  import { ConnectionType, ServerMessageType } from "./enums";
  import type { Peer } from "./peer";
  import { BaseConnection, type BaseConnectionEvents } from "./baseconnection";
  import type { ServerMessage } from "./servermessage";
  import type { AnswerOption } from "./optionInterfaces";
  
  export interface MediaConnectionEvents extends BaseConnectionEvents<never> {
    /**
     * Emitted when a connection to the PeerServer is established.
     *
     * ```ts
     * mediaConnection.on('stream', (stream) => { ... });
     * ```
     */
    stream: (stream: MediaStream) => void;
    /**
     * Emitted when the auxiliary data channel is established.
     * After this event, hanging up will close the connection cleanly on the remote peer.
     * @beta
     */
    willCloseOnRemote: () => void;
  }
  
  /**
   * Wraps WebRTC's media streams.
   * To get one, use {@apilink Peer.call} or listen for the {@apilink PeerEvents | `call`} event.
   */
  export class MediaConnection extends BaseConnection<MediaConnectionEvents> {
    private static readonly ID_PREFIX = "mc_";
    readonly label: string;
  
    private _negotiator: Negotiator<MediaConnectionEvents, this>;
    private _localStream: MediaStream;
    private _remoteStream: MediaStream;
  
    /**
     * For media connections, this is always 'media'.
     */
    get type() {
      return ConnectionType.Media;
    }
  
    get localStream(): MediaStream {
      return this._localStream;
    }
  
    get remoteStream(): MediaStream {
      return this._remoteStream;
    }
  
    constructor(peerId: string, provider: Peer, options: any) {
      super(peerId, provider, options);
  
      this._localStream = this.options._stream;
      this.connectionId =
        this.options.connectionId ||
        MediaConnection.ID_PREFIX + util.randomToken();
  
      this._negotiator = new Negotiator(this);
  
      if (this._localStream) {
        this._negotiator.startConnection({
          _stream: this._localStream,
          originator: true,
        });
      }
    }
  
    /** Called by the Negotiator when the DataChannel is ready. */
    override _initializeDataChannel(dc: RTCDataChannel): void {
      this.dataChannel = dc;
  
      this.dataChannel.onopen = () => {
        logger.log(`DC#${this.connectionId} dc connection success`);
        this.emit("willCloseOnRemote");
      };
  
      this.dataChannel.onclose = () => {
        logger.log(`DC#${this.connectionId} dc closed for:`, this.peer);
        this.close();
      };
    }
    addStream(remoteStream) {
      logger.log("Receiving stream", remoteStream);
  
      this._remoteStream = remoteStream;
      super.emit("stream", remoteStream); // Should we call this `open`?
    }
  
    /**
     * @internal
     */
    handleMessage(message: ServerMessage): void {
      const type = message.type;
      const payload = message.payload;
  
      switch (message.type) {
        case ServerMessageType.Answer:
          // Forward to negotiator
          void this._negotiator.handleSDP(type, payload.sdp);
          this._open = true;
          break;
        case ServerMessageType.Candidate:
          void this._negotiator.handleCandidate(payload.candidate);
          break;
        default:
          logger.warn(`Unrecognized message type:${type} from peer:${this.peer}`);
          break;
      }
    }
  
    /**
       * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call
       * `answer` on the media connection provided by the callback to accept the call
       * and optionally send your own media stream.
  
       *
       * @param stream A WebRTC media stream.
       * @param options
       * @returns
       */
    answer(stream?: MediaStream, options: AnswerOption = {}): void {
      if (this._localStream) {
        logger.warn(
          "Local stream already exists on this MediaConnection. Are you answering a call twice?",
        );
        return;
      }
  
      this._localStream = stream;
  
      if (options && options.sdpTransform) {
        this.options.sdpTransform = options.sdpTransform;
      }
  
      this._negotiator.startConnection({
        ...this.options._payload,
        _stream: stream,
      });
      // Retrieve lost messages stored because PeerConnection not set up.
      const messages = this.provider._getMessages(this.connectionId);
  
      for (const message of messages) {
        this.handleMessage(message);
      }
  
      this._open = true;
    }
  
    /**
     * Exposed functionality for users.
     */
  
    /**
     * Closes the media connection.
     */
    close(): void {
      if (this._negotiator) {
        this._negotiator.cleanup();
        this._negotiator = null;
      }
  
      this._localStream = null;
      this._remoteStream = null;
  
      if (this.provider) {
        this.provider._removeConnection(this);
  
        this.provider = null;
      }
  
      if (this.options && this.options._stream) {
        this.options._stream = null;
      }
  
      if (!this.open) {
        return;
      }
  
      this._open = false;
  
      super.emit("close");
    }
  }
  ",
  "import logger from "./logger";
  import type { MediaConnection } from "./mediaconnection";
  import type { DataConnection } from "./dataconnection/DataConnection";
  import {
    BaseConnectionErrorType,
    ConnectionType,
    PeerErrorType,
    ServerMessageType,
  } from "./enums";
  import type { BaseConnection, BaseConnectionEvents } from "./baseconnection";
  import type { ValidEventTypes } from "eventemitter3";
  
  /**
   * Manages all negotiations between Peers.
   */
  export class Negotiator<
    Events extends ValidEventTypes,
    ConnectionType extends BaseConnection<Events | BaseConnectionEvents>,
  > {
    constructor(readonly connection: ConnectionType) {}
  
    /** Returns a PeerConnection object set up correctly (for data, media). */
    startConnection(options: any) {
      const peerConnection = this._startPeerConnection();
  
      // Set the connection's PC.
      this.connection.peerConnection = peerConnection;
  
      if (this.connection.type === ConnectionType.Media && options._stream) {
        this._addTracksToConnection(options._stream, peerConnection);
      }
  
      // What do we need to do now?
      if (options.originator) {
        const dataConnection = this.connection;
  
        const config: RTCDataChannelInit = { ordered: !!options.reliable };
  
        const dataChannel = peerConnection.createDataChannel(
          dataConnection.label,
          config,
        );
        dataConnection._initializeDataChannel(dataChannel);
  
        void this._makeOffer();
      } else {
        void this.handleSDP("OFFER", options.sdp);
      }
    }
  
    /** Start a PC. */
    private _startPeerConnection(): RTCPeerConnection {
      logger.log("Creating RTCPeerConnection.");
  
      const peerConnection = new RTCPeerConnection(
        this.connection.provider.options.config,
      );
  
      this._setupListeners(peerConnection);
  
      return peerConnection;
    }
  
    /** Set up various WebRTC listeners. */
    private _setupListeners(peerConnection: RTCPeerConnection) {
      const peerId = this.connection.peer;
      const connectionId = this.connection.connectionId;
      const connectionType = this.connection.type;
      const provider = this.connection.provider;
  
      // ICE CANDIDATES.
      logger.log("Listening for ICE candidates.");
  
      peerConnection.onicecandidate = (evt) => {
        if (!evt.candidate || !evt.candidate.candidate) return;
  
        logger.log(`Received ICE candidates for ${peerId}:`, evt.candidate);
  
        provider.socket.send({
          type: ServerMessageType.Candidate,
          payload: {
            candidate: evt.candidate,
            type: connectionType,
            connectionId: connectionId,
          },
          dst: peerId,
        });
      };
  
      peerConnection.oniceconnectionstatechange = () => {
        switch (peerConnection.iceConnectionState) {
          case "failed":
            logger.log(
              "iceConnectionState is failed, closing connections to " + peerId,
            );
            this.connection.emitError(
              BaseConnectionErrorType.NegotiationFailed,
              "Negotiation of connection to " + peerId + " failed.",
            );
            this.connection.close();
            break;
          case "closed":
            logger.log(
              "iceConnectionState is closed, closing connections to " + peerId,
            );
            this.connection.emitError(
              BaseConnectionErrorType.ConnectionClosed,
              "Connection to " + peerId + " closed.",
            );
            this.connection.close();
            break;
          case "disconnected":
            logger.log(
              "iceConnectionState changed to disconnected on the connection with " +
                peerId,
            );
            break;
          case "completed":
            peerConnection.onicecandidate = () => {};
            break;
        }
  
        this.connection.emit(
          "iceStateChanged",
          peerConnection.iceConnectionState,
        );
      };
  
      // DATACONNECTION.
      logger.log("Listening for data channel");
      // Fired between offer and answer, so options should already be saved
      // in the options hash.
      peerConnection.ondatachannel = (evt) => {
        logger.log("Received data channel");
  
        const dataChannel = evt.channel;
        const connection = <DataConnection>(
          provider.getConnection(peerId, connectionId)
        );
  
        connection._initializeDataChannel(dataChannel);
      };
  
      // MEDIACONNECTION.
      logger.log("Listening for remote stream");
  
      peerConnection.ontrack = (evt) => {
        logger.log("Received remote stream");
  
        const stream = evt.streams[0];
        const connection = provider.getConnection(peerId, connectionId);
  
        if (connection.type === ConnectionType.Media) {
          const mediaConnection = <MediaConnection>connection;
  
          this._addStreamToMediaConnection(stream, mediaConnection);
        }
      };
    }
  
    cleanup(): void {
      logger.log("Cleaning up PeerConnection to " + this.connection.peer);
  
      const peerConnection = this.connection.peerConnection;
  
      if (!peerConnection) {
        return;
      }
  
      this.connection.peerConnection = null;
  
      //unsubscribe from all PeerConnection's events
      peerConnection.onicecandidate =
        peerConnection.oniceconnectionstatechange =
        peerConnection.ondatachannel =
        peerConnection.ontrack =
          () => {};
  
      const peerConnectionNotClosed = peerConnection.signalingState !== "closed";
      let dataChannelNotClosed = false;
  
      const dataChannel = this.connection.dataChannel;
  
      if (dataChannel) {
        dataChannelNotClosed =
          !!dataChannel.readyState && dataChannel.readyState !== "closed";
      }
  
      if (peerConnectionNotClosed || dataChannelNotClosed) {
        peerConnection.close();
      }
    }
  
    private async _makeOffer(): Promise<void> {
      const peerConnection = this.connection.peerConnection;
      const provider = this.connection.provider;
  
      try {
        const offer = await peerConnection.createOffer(
          this.connection.options.constraints,
        );
  
        logger.log("Created offer.");
  
        if (
          this.connection.options.sdpTransform &&
          typeof this.connection.options.sdpTransform === "function"
        ) {
          offer.sdp =
            this.connection.options.sdpTransform(offer.sdp) || offer.sdp;
        }
  
        try {
          await peerConnection.setLocalDescription(offer);
  
          logger.log(
            "Set localDescription:",
            offer,
            `for:${this.connection.peer}`,
          );
  
          let payload: any = {
            sdp: offer,
            type: this.connection.type,
            connectionId: this.connection.connectionId,
            metadata: this.connection.metadata,
          };
  
          if (this.connection.type === ConnectionType.Data) {
            const dataConnection = <DataConnection>(<unknown>this.connection);
  
            payload = {
              ...payload,
              label: dataConnection.label,
              reliable: dataConnection.reliable,
              serialization: dataConnection.serialization,
            };
          }
  
          provider.socket.send({
            type: ServerMessageType.Offer,
            payload,
            dst: this.connection.peer,
          });
        } catch (err) {
          // TODO: investigate why _makeOffer is being called from the answer
          if (
            err !=
            "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer"
          ) {
            provider.emitError(PeerErrorType.WebRTC, err);
            logger.log("Failed to setLocalDescription, ", err);
          }
        }
      } catch (err_1) {
        provider.emitError(PeerErrorType.WebRTC, err_1);
        logger.log("Failed to createOffer, ", err_1);
      }
    }
  
    private async _makeAnswer(): Promise<void> {
      const peerConnection = this.connection.peerConnection;
      const provider = this.connection.provider;
  
      try {
        const answer = await peerConnection.createAnswer();
        logger.log("Created answer.");
  
        if (
          this.connection.options.sdpTransform &&
          typeof this.connection.options.sdpTransform === "function"
        ) {
          answer.sdp =
            this.connection.options.sdpTransform(answer.sdp) || answer.sdp;
        }
  
        try {
          await peerConnection.setLocalDescription(answer);
  
          logger.log(
            `Set localDescription:`,
            answer,
            `for:${this.connection.peer}`,
          );
  
          provider.socket.send({
            type: ServerMessageType.Answer,
            payload: {
              sdp: answer,
              type: this.connection.type,
              connectionId: this.connection.connectionId,
            },
            dst: this.connection.peer,
          });
        } catch (err) {
          provider.emitError(PeerErrorType.WebRTC, err);
          logger.log("Failed to setLocalDescription, ", err);
        }
      } catch (err_1) {
        provider.emitError(PeerErrorType.WebRTC, err_1);
        logger.log("Failed to create answer, ", err_1);
      }
    }
  
    /** Handle an SDP. */
    async handleSDP(type: string, sdp: any): Promise<void> {
      sdp = new RTCSessionDescription(sdp);
      const peerConnection = this.connection.peerConnection;
      const provider = this.connection.provider;
  
      logger.log("Setting remote description", sdp);
  
      const self = this;
  
      try {
        await peerConnection.setRemoteDescription(sdp);
        logger.log(`Set remoteDescription:${type} for:${this.connection.peer}`);
        if (type === "OFFER") {
          await self._makeAnswer();
        }
      } catch (err) {
        provider.emitError(PeerErrorType.WebRTC, err);
        logger.log("Failed to setRemoteDescription, ", err);
      }
    }
  
    /** Handle a candidate. */
    async handleCandidate(ice: RTCIceCandidate) {
      logger.log(`handleCandidate:`, ice);
  
      try {
        await this.connection.peerConnection.addIceCandidate(ice);
        logger.log(`Added ICE candidate for:${this.connection.peer}`);
      } catch (err) {
        this.connection.provider.emitError(PeerErrorType.WebRTC, err);
        logger.log("Failed to handleCandidate, ", err);
      }
    }
  
    private _addTracksToConnection(
      stream: MediaStream,
      peerConnection: RTCPeerConnection,
    ): void {
      logger.log(`add tracks from stream ${stream.id} to peer connection`);
  
      if (!peerConnection.addTrack) {
        return logger.error(
          `Your browser does't support RTCPeerConnection#addTrack. Ignored.`,
        );
      }
  
      stream.getTracks().forEach((track) => {
        peerConnection.addTrack(track, stream);
      });
    }
  
    private _addStreamToMediaConnection(
      stream: MediaStream,
      mediaConnection: MediaConnection,
    ): void {
      logger.log(
        `add stream ${stream.id} to media connection ${mediaConnection.connectionId}`,
      );
  
      mediaConnection.addStream(stream);
    }
  }
  ",
  "import type { Peer } from "./peer";
  import type { ServerMessage } from "./servermessage";
  import type { ConnectionType } from "./enums";
  import { BaseConnectionErrorType } from "./enums";
  import {
    EventEmitterWithError,
    type EventsWithError,
    PeerError,
  } from "./peerError";
  import type { ValidEventTypes } from "eventemitter3";
  
  export interface BaseConnectionEvents<
    ErrorType extends string = BaseConnectionErrorType,
  > extends EventsWithError<ErrorType> {
    /**
     * Emitted when either you or the remote peer closes the connection.
     *
     * ```ts
     * connection.on('close', () => { ... });
     * ```
     */
    close: () => void;
    /**
     * ```ts
     * connection.on('error', (error) => { ... });
     * ```
     */
    error: (error: PeerError<`${ErrorType}`>) => void;
    iceStateChanged: (state: RTCIceConnectionState) => void;
  }
  
  export abstract class BaseConnection<
    SubClassEvents extends ValidEventTypes,
    ErrorType extends string = never,
  > extends EventEmitterWithError<
    ErrorType | BaseConnectionErrorType,
    SubClassEvents & BaseConnectionEvents<BaseConnectionErrorType | ErrorType>
  > {
    protected _open = false;
  
    /**
     * Any type of metadata associated with the connection,
     * passed in by whoever initiated the connection.
     */
    readonly metadata: any;
    connectionId: string;
  
    peerConnection: RTCPeerConnection;
    dataChannel: RTCDataChannel;
  
    abstract get type(): ConnectionType;
  
    /**
     * The optional label passed in or assigned by PeerJS when the connection was initiated.
     */
    label: string;
  
    /**
     * Whether the media connection is active (e.g. your call has been answered).
     * You can check this if you want to set a maximum wait time for a one-sided call.
     */
    get open() {
      return this._open;
    }
  
    protected constructor(
      /**
       * The ID of the peer on the other end of this connection.
       */
      readonly peer: string,
      public provider: Peer,
      readonly options: any,
    ) {
      super();
  
      this.metadata = options.metadata;
    }
  
    abstract close(): void;
  
    /**
     * @internal
     */
    abstract handleMessage(message: ServerMessage): void;
  
    /**
     * Called by the Negotiator when the DataChannel is ready.
     * @internal
     * */
    abstract _initializeDataChannel(dc: RTCDataChannel): void;
  }
  ",
  "import { EventEmitter } from "eventemitter3";
  import logger from "./logger";
  
  export interface EventsWithError<ErrorType extends string> {
    error: (error: PeerError<`${ErrorType}`>) => void;
  }
  
  export class EventEmitterWithError<
    ErrorType extends string,
    Events extends EventsWithError<ErrorType>,
  > extends EventEmitter<Events, never> {
    /**
     * Emits a typed error message.
     *
     * @internal
     */
    emitError(type: ErrorType, err: string | Error): void {
      logger.error("Error:", err);
  
      // @ts-ignore
      this.emit("error", new PeerError<`${ErrorType}`>(`${type}`, err));
    }
  }
  /**
   * A PeerError is emitted whenever an error occurs.
   * It always has a `.type`, which can be used to identify the error.
   */
  export class PeerError<T extends string> extends Error {
    /**
     * @internal
     */
    constructor(type: T, err: Error | string) {
      if (typeof err === "string") {
        super(err);
      } else {
        super();
        Object.assign(this, err);
      }
  
      this.type = type;
    }
  
    public type: T;
  }
  ",
  "import { util } from "./util";
  import logger from "./logger";
  import type { PeerJSOption } from "./optionInterfaces";
  import { version } from "../package.json";
  
  export class API {
    constructor(private readonly _options: PeerJSOption) {}
  
    private _buildRequest(method: string): Promise<Response> {
      const protocol = this._options.secure ? "https" : "http";
      const { host, port, path, key } = this._options;
      const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);
      // TODO: Why timestamp, why random?
      url.searchParams.set("ts", `${Date.now()}${Math.random()}`);
      url.searchParams.set("version", version);
      return fetch(url.href, {
        referrerPolicy: this._options.referrerPolicy,
      });
    }
  
    /** Get a unique ID from the server via XHR and initialize with it. */
    async retrieveId(): Promise<string> {
      try {
        const response = await this._buildRequest("id");
  
        if (response.status !== 200) {
          throw new Error(`Error. Status:${response.status}`);
        }
  
        return response.text();
      } catch (error) {
        logger.error("Error retrieving ID", error);
  
        let pathError = "";
  
        if (
          this._options.path === "/" &&
          this._options.host !== util.CLOUD_HOST
        ) {
          pathError =
            " If you passed in a `path` to your self-hosted PeerServer, " +
            "you'll also need to pass in that same path when creating a new " +
            "Peer.";
        }
  
        throw new Error("Could not get an ID from the server." + pathError);
      }
    }
  
    /** @deprecated */
    async listAllPeers(): Promise<any[]> {
      try {
        const response = await this._buildRequest("peers");
  
        if (response.status !== 200) {
          if (response.status === 401) {
            let helpfulError = "";
  
            if (this._options.host === util.CLOUD_HOST) {
              helpfulError =
                "It looks like you're using the cloud server. You can email " +
                "team@peerjs.com to enable peer listing for your API key.";
            } else {
              helpfulError =
                "You need to enable `allow_discovery` on your self-hosted " +
                "PeerServer to use this feature.";
            }
  
            throw new Error(
              "It doesn't look like you have permission to list peers IDs. " +
                helpfulError,
            );
          }
  
          throw new Error(`Error. Status:${response.status}`);
        }
  
        return response.json();
      } catch (error) {
        logger.error("Error retrieving list peers", error);
  
        throw new Error("Could not get list peers from the server." + error);
      }
    }
  }
  ",
  "import { BinaryPackChunker, concatArrayBuffers } from "./binaryPackChunker";
  import logger from "../../logger";
  import type { Peer } from "../../peer";
  import { BufferedConnection } from "./BufferedConnection";
  import { SerializationType } from "../../enums";
  import { pack, type Packable, unpack } from "peerjs-js-binarypack";
  
  export class BinaryPack extends BufferedConnection {
    private readonly chunker = new BinaryPackChunker();
    readonly serialization = SerializationType.Binary;
  
    private _chunkedData: {
      [id: number]: {
        data: Uint8Array[];
        count: number;
        total: number;
      };
    } = {};
  
    public override close(options?: { flush?: boolean }) {
      super.close(options);
      this._chunkedData = {};
    }
  
    constructor(peerId: string, provider: Peer, options: any) {
      super(peerId, provider, options);
    }
  
    // Handles a DataChannel message.
    protected override _handleDataMessage({ data }: { data: Uint8Array }): void {
      const deserializedData = unpack(data);
  
      // PeerJS specific message
      const peerData = deserializedData["__peerData"];
      if (peerData) {
        if (peerData.type === "close") {
          this.close();
          return;
        }
  
        // Chunked data -- piece things back together.
        // @ts-ignore
        this._handleChunk(deserializedData);
        return;
      }
  
      this.emit("data", deserializedData);
    }
  
    private _handleChunk(data: {
      __peerData: number;
      n: number;
      total: number;
      data: ArrayBuffer;
    }): void {
      const id = data.__peerData;
      const chunkInfo = this._chunkedData[id] || {
        data: [],
        count: 0,
        total: data.total,
      };
  
      chunkInfo.data[data.n] = new Uint8Array(data.data);
      chunkInfo.count++;
      this._chunkedData[id] = chunkInfo;
  
      if (chunkInfo.total === chunkInfo.count) {
        // Clean up before making the recursive call to `_handleDataMessage`.
        delete this._chunkedData[id];
  
        // We've received all the chunks--time to construct the complete data.
        // const data = new Blob(chunkInfo.data);
        const data = concatArrayBuffers(chunkInfo.data);
        this._handleDataMessage({ data });
      }
    }
  
    protected override _send(data: Packable, chunked: boolean) {
      const blob = pack(data);
      if (blob instanceof Promise) {
        return this._send_blob(blob);
      }
  
      if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {
        this._sendChunks(blob);
        return;
      }
  
      this._bufferedSend(blob);
    }
    private async _send_blob(blobPromise: Promise<ArrayBufferLike>) {
      const blob = await blobPromise;
      if (blob.byteLength > this.chunker.chunkedMTU) {
        this._sendChunks(blob);
        return;
      }
  
      this._bufferedSend(blob);
    }
  
    private _sendChunks(blob: ArrayBuffer) {
      const blobs = this.chunker.chunk(blob);
      logger.log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);
  
      for (const blob of blobs) {
        this.send(blob, true);
      }
    }
  }
  ",
  "import logger from "../../logger";
  import { DataConnection } from "../DataConnection";
  
  export abstract class BufferedConnection extends DataConnection {
    private _buffer: any[] = [];
    private _bufferSize = 0;
    private _buffering = false;
  
    public get bufferSize(): number {
      return this._bufferSize;
    }
  
    public override _initializeDataChannel(dc: RTCDataChannel) {
      super._initializeDataChannel(dc);
      this.dataChannel.binaryType = "arraybuffer";
      this.dataChannel.addEventListener("message", (e) =>
        this._handleDataMessage(e),
      );
    }
  
    protected abstract _handleDataMessage(e: MessageEvent): void;
  
    protected _bufferedSend(msg: ArrayBuffer): void {
      if (this._buffering || !this._trySend(msg)) {
        this._buffer.push(msg);
        this._bufferSize = this._buffer.length;
      }
    }
  
    // Returns true if the send succeeds.
    private _trySend(msg: ArrayBuffer): boolean {
      if (!this.open) {
        return false;
      }
  
      if (this.dataChannel.bufferedAmount > DataConnection.MAX_BUFFERED_AMOUNT) {
        this._buffering = true;
        setTimeout(() => {
          this._buffering = false;
          this._tryBuffer();
        }, 50);
  
        return false;
      }
  
      try {
        this.dataChannel.send(msg);
      } catch (e) {
        logger.error(`DC#:${this.connectionId} Error when sending:`, e);
        this._buffering = true;
  
        this.close();
  
        return false;
      }
  
      return true;
    }
  
    // Try to send the first message in the buffer.
    private _tryBuffer(): void {
      if (!this.open) {
        return;
      }
  
      if (this._buffer.length === 0) {
        return;
      }
  
      const msg = this._buffer[0];
  
      if (this._trySend(msg)) {
        this._buffer.shift();
        this._bufferSize = this._buffer.length;
        this._tryBuffer();
      }
    }
  
    public override close(options?: { flush?: boolean }) {
      if (options?.flush) {
        this.send({
          __peerData: {
            type: "close",
          },
        });
        return;
      }
      this._buffer = [];
      this._bufferSize = 0;
      super.close();
    }
  }
  ",
  "import logger from "../logger";
  import { Negotiator } from "../negotiator";
  import {
    BaseConnectionErrorType,
    ConnectionType,
    DataConnectionErrorType,
    ServerMessageType,
  } from "../enums";
  import type { Peer } from "../peer";
  import { BaseConnection, type BaseConnectionEvents } from "../baseconnection";
  import type { ServerMessage } from "../servermessage";
  import type { EventsWithError } from "../peerError";
  import { randomToken } from "../utils/randomToken";
  
  export interface DataConnectionEvents
    extends EventsWithError<DataConnectionErrorType | BaseConnectionErrorType>,
      BaseConnectionEvents<DataConnectionErrorType | BaseConnectionErrorType> {
    /**
     * Emitted when data is received from the remote peer.
     */
    data: (data: unknown) => void;
    /**
     * Emitted when the connection is established and ready-to-use.
     */
    open: () => void;
  }
  
  /**
   * Wraps a DataChannel between two Peers.
   */
  export abstract class DataConnection extends BaseConnection<
    DataConnectionEvents,
    DataConnectionErrorType
  > {
    protected static readonly ID_PREFIX = "dc_";
    protected static readonly MAX_BUFFERED_AMOUNT = 8 * 1024 * 1024;
  
    private _negotiator: Negotiator<DataConnectionEvents, this>;
    abstract readonly serialization: string;
    readonly reliable: boolean;
  
    public get type() {
      return ConnectionType.Data;
    }
  
    constructor(peerId: string, provider: Peer, options: any) {
      super(peerId, provider, options);
  
      this.connectionId =
        this.options.connectionId || DataConnection.ID_PREFIX + randomToken();
  
      this.label = this.options.label || this.connectionId;
      this.reliable = !!this.options.reliable;
  
      this._negotiator = new Negotiator(this);
  
      this._negotiator.startConnection(
        this.options._payload || {
          originator: true,
          reliable: this.reliable,
        },
      );
    }
  
    /** Called by the Negotiator when the DataChannel is ready. */
    override _initializeDataChannel(dc: RTCDataChannel): void {
      this.dataChannel = dc;
  
      this.dataChannel.onopen = () => {
        logger.log(`DC#${this.connectionId} dc connection success`);
        this._open = true;
        this.emit("open");
      };
  
      this.dataChannel.onmessage = (e) => {
        logger.log(`DC#${this.connectionId} dc onmessage:`, e.data);
        // this._handleDataMessage(e);
      };
  
      this.dataChannel.onclose = () => {
        logger.log(`DC#${this.connectionId} dc closed for:`, this.peer);
        this.close();
      };
    }
  
    /**
     * Exposed functionality for users.
     */
  
    /** Allows user to close connection. */
    close(options?: { flush?: boolean }): void {
      if (options?.flush) {
        this.send({
          __peerData: {
            type: "close",
          },
        });
        return;
      }
      if (this._negotiator) {
        this._negotiator.cleanup();
        this._negotiator = null;
      }
  
      if (this.provider) {
        this.provider._removeConnection(this);
  
        this.provider = null;
      }
  
      if (this.dataChannel) {
        this.dataChannel.onopen = null;
        this.dataChannel.onmessage = null;
        this.dataChannel.onclose = null;
        this.dataChannel = null;
      }
  
      if (!this.open) {
        return;
      }
  
      this._open = false;
  
      super.emit("close");
    }
  
    protected abstract _send(data: any, chunked: boolean): void | Promise<void>;
  
    /** Allows user to send data. */
    public send(data: any, chunked = false) {
      if (!this.open) {
        this.emitError(
          DataConnectionErrorType.NotOpenYet,
          "Connection is not open. You should listen for the `open` event before sending messages.",
        );
        return;
      }
      return this._send(data, chunked);
    }
  
    async handleMessage(message: ServerMessage) {
      const payload = message.payload;
  
      switch (message.type) {
        case ServerMessageType.Answer:
          await this._negotiator.handleSDP(message.type, payload.sdp);
          break;
        case ServerMessageType.Candidate:
          await this._negotiator.handleCandidate(payload.candidate);
          break;
        default:
          logger.warn(
            "Unrecognized message type:",
            message.type,
            "from peer:",
            this.peer,
          );
          break;
      }
    }
  }
  ",
  "import { BufferedConnection } from "./BufferedConnection";
  import { SerializationType } from "../../enums";
  
  export class Raw extends BufferedConnection {
    readonly serialization = SerializationType.None;
  
    protected _handleDataMessage({ data }) {
      super.emit("data", data);
    }
  
    override _send(data, _chunked) {
      this._bufferedSend(data);
    }
  }
  ",
  "import { BufferedConnection } from "./BufferedConnection";
  import { DataConnectionErrorType, SerializationType } from "../../enums";
  import { util } from "../../util";
  
  export class Json extends BufferedConnection {
    readonly serialization = SerializationType.JSON;
    private readonly encoder = new TextEncoder();
    private readonly decoder = new TextDecoder();
  
    stringify: (data: any) => string = JSON.stringify;
    parse: (data: string) => any = JSON.parse;
  
    // Handles a DataChannel message.
    protected override _handleDataMessage({ data }: { data: Uint8Array }): void {
      const deserializedData = this.parse(this.decoder.decode(data));
  
      // PeerJS specific message
      const peerData = deserializedData["__peerData"];
      if (peerData && peerData.type === "close") {
        this.close();
        return;
      }
  
      this.emit("data", deserializedData);
    }
  
    override _send(data, _chunked) {
      const encodedData = this.encoder.encode(this.stringify(data));
      if (encodedData.byteLength >= util.chunkedMTU) {
        this.emitError(
          DataConnectionErrorType.MessageToBig,
          "Message too big for JSON channel",
        );
        return;
      }
      this._bufferedSend(encodedData);
    }
  }
  "
  ],
  names: [
  "$parcel$export",
  "e",
  "n",
  "v",
  "s",
  "Object",
  "defineProperty",
  "get",
  "set",
  "enumerable",
  "configurable",
  "$parcel$interopDefault",
  "a",
  "__esModule",
  "default",
  "$337647a69164cf0a$export$f1c5f4c9cb95390b",
  "constructor",
  "chunkedMTU",
  "_dataCount",
  "chunk",
  "blob",
  "chunks",
  "size",
  "byteLength",
  "total",
  "Math",
  "ceil",
  "index",
  "start",
  "end",
  "min",
  "b",
  "slice",
  "__peerData",
  "data",
  "push",
  "$41cdfe0a3ede2608$var$$e8379818650e2442$export$93654d4f2d6cd524",
  "append_buffer",
  "flush",
  "_parts",
  "append",
  "_pieces",
  "length",
  "buf",
  "Uint8Array",
  "toArrayBuffer",
  "buffer",
  "part",
  "$41cdfe0a3ede2608$var$$e8379818650e2442$var$concatArrayBuffers",
  "bufs",
  "result",
  "offset",
  "view",
  "byteOffset",
  "encoder",
  "TextEncoder",
  "$41cdfe0a3ede2608$export$417857010dc9287f",
  "unpacker",
  "$41cdfe0a3ede2608$var$$0cfd7828ad59115f$var$Unpacker",
  "unpack",
  "$41cdfe0a3ede2608$export$2a703dbb0cb35339",
  "packer",
  "$41cdfe0a3ede2608$export$b9ec4b114aa40074",
  "res",
  "pack",
  "Promise",
  "then",
  "getBuffer",
  "type",
  "unpack_uint8",
  "unpack_raw",
  "unpack_string",
  "unpack_array",
  "unpack_map",
  "unpack_float",
  "unpack_double",
  "unpack_uint16",
  "unpack_uint32",
  "unpack_uint64",
  "unpack_int8",
  "unpack_int16",
  "unpack_int32",
  "unpack_int64",
  "byte",
  "dataView",
  "bytes",
  "read",
  "uint16",
  "uint32",
  "uint64",
  "uint8",
  "Error",
  "dataBuffer",
  "c",
  "code",
  "i",
  "str",
  "String",
  "fromCodePoint",
  "objects",
  "Array",
  "map",
  "sign",
  "exp",
  "h32",
  "l32",
  "hfrac",
  "j",
  "subarray",
  "_bufferBuilder",
  "value",
  "pack_string",
  "floor",
  "pack_integer",
  "pack_double",
  "undefined",
  "pack_array",
  "ArrayBuffer",
  "pack_bin",
  "Date",
  "toString",
  "Blob",
  "arrayBuffer",
  "startsWith",
  "pack_object",
  "pack_uint8",
  "pack_uint16",
  "pack_uint32",
  "encoded",
  "_textEncoder",
  "encode",
  "ary",
  "packNext",
  "num",
  "pack_int8",
  "pack_int16",
  "pack_int32",
  "pack_int64",
  "pack_uint64",
  "log",
  "LN2",
  "frac1",
  "frac0",
  "obj",
  "keys",
  "prop",
  "hasOwnProperty",
  "high",
  "low",
  "$11d9b3e4fc7791e1$var$logDisabled_",
  "$11d9b3e4fc7791e1$var$deprecationWarnings_",
  "$11d9b3e4fc7791e1$export$e3c02be309be1f23",
  "uastring",
  "expr",
  "pos",
  "match",
  "parseInt",
  "$11d9b3e4fc7791e1$export$1f48841962b828b1",
  "window1",
  "eventNameToWrap",
  "wrapper",
  "RTCPeerConnection",
  "proto",
  "prototype",
  "nativeAddEventListener",
  "addEventListener",
  "nativeEventName",
  "cb",
  "apply",
  "arguments",
  "wrappedCallback",
  "modifiedEvent",
  "handleEvent",
  "_eventMap",
  "Map",
  "nativeRemoveEventListener",
  "removeEventListener",
  "has",
  "unwrappedCb",
  "delete",
  "$11d9b3e4fc7791e1$export$afbfee8cc06fd3e4",
  "bool",
  "$11d9b3e4fc7791e1$export$51516be4b019e41e",
  "$11d9b3e4fc7791e1$export$bef1f36f5486a6a3",
  "window",
  "console",
  "$11d9b3e4fc7791e1$export$cdd73fc4100a6ef4",
  "oldMethod",
  "newMethod",
  "warn",
  "$11d9b3e4fc7791e1$var$isObject",
  "val",
  "call",
  "$11d9b3e4fc7791e1$export$93439ffc3f787d51",
  "track",
  "outbound",
  "streamStatsType",
  "filteredResult",
  "trackStats",
  "forEach",
  "trackIdentifier",
  "id",
  "trackStat",
  "stats",
  "trackId",
  "$11d9b3e4fc7791e1$export$571b373e75babb58",
  "base",
  "resultSet",
  "name",
  "endsWith",
  "LogLevel",
  "ConnectionType",
  "PeerErrorType",
  "BaseConnectionErrorType",
  "DataConnectionErrorType",
  "SerializationType",
  "SocketEventType",
  "ServerMessageType",
  "$6adb9b697958aa01$export$243e62d78d3b544d",
  "$200acda04d260725$export$3157d57b4135e3bc",
  "$200acda04d260725$export$9547aaa2e39030ff",
  "$200acda04d260725$export$7974935686149686",
  "$200acda04d260725$export$49ae800c114df41d",
  "$200acda04d260725$export$89f507cf986a947",
  "$200acda04d260725$export$3b5c4a4b6354f023",
  "$200acda04d260725$export$adb4a1754da6f10d",
  "$041f4f4318baab2c$exports",
  "$b54ff3b82f3d51d6$export$1ed4910f4d37dc5e",
  "browserDetails",
  "navigator",
  "mediaDevices",
  "constraintsToChrome_",
  "mandatory",
  "optional",
  "cc",
  "key",
  "r",
  "ideal",
  "exact",
  "max",
  "oldname_",
  "prefix",
  "charAt",
  "toUpperCase",
  "oc",
  "mix",
  "advanced",
  "concat",
  "shimConstraints_",
  "constraints",
  "func",
  "version",
  "JSON",
  "parse",
  "stringify",
  "audio",
  "remap",
  "video",
  "face",
  "facingMode",
  "getSupportedFacingModeLies",
  "getSupportedConstraints",
  "matches",
  "enumerateDevices",
  "devices",
  "dev",
  "filter",
  "d",
  "kind",
  "find",
  "some",
  "label",
  "toLowerCase",
  "includes",
  "deviceId",
  "$b54ff3b82f3d51d6$var$logging",
  "shimError_",
  "PermissionDeniedError",
  "PermissionDismissedError",
  "InvalidStateError",
  "DevicesNotFoundError",
  "ConstraintNotSatisfiedError",
  "TrackStartError",
  "MediaDeviceFailedDueToShutdown",
  "MediaDeviceKillSwitchOn",
  "TabCaptureError",
  "ScreenCaptureError",
  "DeviceCaptureError",
  "message",
  "constraint",
  "constraintName",
  "getUserMedia",
  "getUserMedia_",
  "onSuccess",
  "onError",
  "webkitGetUserMedia",
  "bind",
  "origGetUserMedia",
  "cs",
  "stream",
  "getAudioTracks",
  "getVideoTracks",
  "getTracks",
  "stop",
  "DOMException",
  "reject",
  "$4cbb13d690da2bd9$export$97270b87351d9c04",
  "getSourceId",
  "error",
  "getDisplayMedia",
  "sourceId",
  "widthSpecified",
  "width",
  "heightSpecified",
  "height",
  "frameRateSpecified",
  "frameRate",
  "chromeMediaSource",
  "chromeMediaSourceId",
  "maxFrameRate",
  "maxWidth",
  "maxHeight",
  "$041f4f4318baab2c$export$33ee24e7a300bcd1",
  "MediaStream",
  "webkitMediaStream",
  "$041f4f4318baab2c$export$f358708f68ab068",
  "transceiver",
  "receiver",
  "_ontrack",
  "f",
  "origSetRemoteDescription",
  "setRemoteDescription",
  "_ontrackpoly",
  "te",
  "getReceivers",
  "event",
  "Event",
  "streams",
  "dispatchEvent",
  "$041f4f4318baab2c$export$a41a030a2842f5d6",
  "shimSenderWithDtmf",
  "pc",
  "dtmf",
  "_dtmf",
  "createDTMFSender",
  "_pc",
  "getSenders",
  "_senders",
  "origAddTrack",
  "addTrack",
  "sender",
  "origRemoveTrack",
  "removeTrack",
  "idx",
  "indexOf",
  "splice",
  "origAddStream",
  "addStream",
  "origRemoveStream",
  "removeStream",
  "RTCRtpSender",
  "origGetSenders",
  "senders",
  "$041f4f4318baab2c$export$90608323826f0b17",
  "origGetStats",
  "getStats",
  "selector",
  "onSucc",
  "onErr",
  "fixChromeStats_",
  "response",
  "standardReport",
  "reports",
  "report",
  "standardStats",
  "timestamp",
  "localcandidate",
  "remotecandidate",
  "names",
  "stat",
  "makeMapStats",
  "resolve",
  "$041f4f4318baab2c$export$f2f0f2338114eb4b",
  "RTCRtpReceiver",
  "origGetReceivers",
  "receivers",
  "srcElement",
  "MediaStreamTrack",
  "err",
  "$041f4f4318baab2c$export$30e3cdd46f8d5100",
  "getLocalStreams",
  "_shimmedLocalStreams",
  "streamId",
  "existingSenders",
  "newSenders",
  "newSender",
  "$041f4f4318baab2c$export$9588259fcf4ebc91",
  "origGetLocalStreams",
  "nativeStreams",
  "_reverseStreams",
  "_streams",
  "newStream",
  "replaceInternalStreamId",
  "description",
  "sdp",
  "internalId",
  "externalStream",
  "internalStream",
  "replace",
  "RegExp",
  "RTCSessionDescription",
  "signalingState",
  "t",
  "oldStream",
  "method",
  "nativeMethod",
  "methodObj",
  "args",
  "isLegacyCall",
  "desc",
  "origSetLocalDescription",
  "setLocalDescription",
  "origLocalDescription",
  "getOwnPropertyDescriptor",
  "streamid",
  "$041f4f4318baab2c$export$852a08dda9a55ea7",
  "webkitRTCPeerConnection",
  "RTCIceCandidate",
  "$041f4f4318baab2c$export$341293bbeaae37cb",
  "target",
  "getConfiguration",
  "sdpSemantics",
  "$5ba25c21eb1c0af8$exports",
  "$138811b977baa945$export$1ed4910f4d37dc5e",
  "nativeGetUserMedia",
  "getSettings",
  "nativeGetSettings",
  "applyConstraints",
  "nativeApplyConstraints",
  "$d08a6680f3298ef0$export$97270b87351d9c04",
  "preferredMediaSource",
  "mediaSource",
  "$5ba25c21eb1c0af8$export$f358708f68ab068",
  "RTCTrackEvent",
  "$5ba25c21eb1c0af8$export$852a08dda9a55ea7",
  "mozRTCPeerConnection",
  "modernStatsTypes",
  "inboundrtp",
  "outboundrtp",
  "candidatepair",
  "nativeGetStats",
  "assign",
  "$5ba25c21eb1c0af8$export$f0525502095c04ef",
  "$5ba25c21eb1c0af8$export$83d69126527b1171",
  "$5ba25c21eb1c0af8$export$825e523ef749bd8c",
  "$5ba25c21eb1c0af8$export$ff9cb3bc8990e8f7",
  "DataChannel",
  "RTCDataChannel",
  "$5ba25c21eb1c0af8$export$70c77533b6e9908d",
  "origAddTransceiver",
  "addTransceiver",
  "setParametersPromises",
  "sendEncodings",
  "shouldPerformCheck",
  "encodingParam",
  "ridRegex",
  "test",
  "rid",
  "TypeError",
  "parseFloat",
  "scaleResolutionDownBy",
  "RangeError",
  "maxFramerate",
  "params",
  "getParameters",
  "encodings",
  "setParameters",
  "catch",
  "$5ba25c21eb1c0af8$export$66238223c298fbaa",
  "origGetParameters",
  "$5ba25c21eb1c0af8$export$51beccf0e777b843",
  "origCreateOffer",
  "createOffer",
  "all",
  "finally",
  "$5ba25c21eb1c0af8$export$df0b46e7cef08150",
  "origCreateAnswer",
  "createAnswer",
  "$93a503258ac80079$exports",
  "$93a503258ac80079$export$8df41282f4fdcea2",
  "_localStreams",
  "_addTrack",
  "tracks",
  "$93a503258ac80079$export$762aa4cbb4f2f857",
  "getRemoteStreams",
  "_remoteStreams",
  "_onaddstream",
  "_onaddstreampoly",
  "$93a503258ac80079$export$da31df245debdd3",
  "addIceCandidate",
  "successCallback",
  "failureCallback",
  "options",
  "promise",
  "withCallback",
  "candidate",
  "$93a503258ac80079$export$1ed4910f4d37dc5e",
  "_getUserMedia",
  "$93a503258ac80079$export$494a01ac68ba81ac",
  "errcb",
  "$11d9b3e4fc7791e1$export$15384eac40dc88c8",
  "reduce",
  "accumulator",
  "isObj",
  "isEmptyObject",
  "$93a503258ac80079$export$671a8b47b41b6f41",
  "OrigPeerConnection",
  "pcConfig",
  "pcConstraints",
  "iceServers",
  "newIceServers",
  "server",
  "urls",
  "url",
  "generateCertificate",
  "$93a503258ac80079$export$85d53da088cb1b14",
  "$93a503258ac80079$export$d444266503fdd2d4",
  "offerOptions",
  "offerToReceiveAudio",
  "audioTransceiver",
  "getTransceivers",
  "direction",
  "setDirection",
  "offerToReceiveVideo",
  "videoTransceiver",
  "$93a503258ac80079$export$857cd739a7b795d2",
  "AudioContext",
  "webkitAudioContext",
  "$f8e30544afcd11f0$exports",
  "$f8e30544afcd11f0$export$cf133661e444ccfe",
  "$f8e30544afcd11f0$export$fdafb8d8280e29b5",
  "$f8e30544afcd11f0$export$a99147c78a56edc4",
  "$f8e30544afcd11f0$export$d461c8d5c5db5da7",
  "$f8e30544afcd11f0$export$63bb816cc75460",
  "$f8e30544afcd11f0$export$a57d114344295149",
  "$f8e30544afcd11f0$export$51d5e40b48c771c7",
  "$f8e30544afcd11f0$export$7170d04e59f9d553",
  "$30b3171bddcf6271$exports",
  "$30b3171bddcf6271$var$SDPUtils",
  "NativeRTCIceCandidate",
  "substring",
  "nativeCandidate",
  "parsedCandidate",
  "parseCandidate",
  "toJSON",
  "sdpMid",
  "sdpMLineIndex",
  "usernameFragment",
  "writable",
  "relayProtocol",
  "priority",
  "_sctp",
  "sctpInDescription",
  "sections",
  "splitSections",
  "shift",
  "mediaSection",
  "mLine",
  "parseMLine",
  "protocol",
  "getRemoteFirefoxVersion",
  "getCanSendMaxMessageSize",
  "remoteIsFirefox",
  "canSendMaxMessageSize",
  "browser",
  "getMaxMessageSize",
  "maxMessageSize",
  "matchPrefix",
  "isFirefox",
  "canSendMMS",
  "remoteMMS",
  "Number",
  "POSITIVE_INFINITY",
  "sctp",
  "wrapDcSend",
  "dc",
  "origDataChannelSend",
  "send",
  "readyState",
  "origCreateDataChannel",
  "createDataChannel",
  "dataChannel",
  "channel",
  "completed",
  "checking",
  "iceConnectionState",
  "_onconnectionstatechange",
  "origMethod",
  "_connectionstatechangepoly",
  "_lastConnectionState",
  "connectionState",
  "newEvent",
  "nativeSRD",
  "split",
  "line",
  "trim",
  "join",
  "nativeAddIceCandidate",
  "nativeSetLocalDescription",
  "generateIdentifier",
  "random",
  "localCName",
  "splitLines",
  "parts",
  "getDescription",
  "getMediaSections",
  "foundation",
  "component",
  "ip",
  "address",
  "port",
  "relatedAddress",
  "relatedPort",
  "tcpType",
  "ufrag",
  "writeCandidate",
  "parseIceOptions",
  "parseRtpMap",
  "parsed",
  "payloadType",
  "clockRate",
  "channels",
  "numChannels",
  "writeRtpMap",
  "codec",
  "pt",
  "preferredPayloadType",
  "parseExtmap",
  "uri",
  "attributes",
  "writeExtmap",
  "headerExtension",
  "preferredId",
  "parseFmtp",
  "kv",
  "writeFmtp",
  "parameters",
  "param",
  "parseRtcpFb",
  "parameter",
  "writeRtcpFb",
  "lines",
  "rtcpFeedback",
  "fb",
  "parseSsrcMedia",
  "sp",
  "ssrc",
  "colon",
  "attribute",
  "parseSsrcGroup",
  "semantics",
  "ssrcs",
  "getMid",
  "mid",
  "parseFingerprint",
  "algorithm",
  "getDtlsParameters",
  "sessionpart",
  "role",
  "fingerprints",
  "writeDtlsParameters",
  "setupType",
  "fp",
  "parseCryptoLine",
  "tag",
  "cryptoSuite",
  "keyParams",
  "sessionParams",
  "writeCryptoLine",
  "writeCryptoKeyParams",
  "parseCryptoKeyParams",
  "keyMethod",
  "keySalt",
  "lifeTime",
  "mkiValue",
  "mkiLength",
  "getCryptoParameters",
  "getIceParameters",
  "pwd",
  "password",
  "writeIceParameters",
  "iceLite",
  "parseRtpParameters",
  "codecs",
  "headerExtensions",
  "fecMechanisms",
  "rtcp",
  "mline",
  "profile",
  "rtpmapline",
  "fmtps",
  "wildcardRtcpFb",
  "existingFeedback",
  "writeRtpDescription",
  "caps",
  "maxptime",
  "extension",
  "parseRtpEncodingParameters",
  "secondarySsrc",
  "encodingParameters",
  "hasRed",
  "hasUlpfec",
  "primarySsrc",
  "flows",
  "apt",
  "encParam",
  "codecPayloadType",
  "rtx",
  "fec",
  "mechanism",
  "bandwidth",
  "maxBitrate",
  "parseRtcpParameters",
  "rtcpParameters",
  "remoteSsrc",
  "cname",
  "rsize",
  "reducedSize",
  "compound",
  "mux",
  "writeRtcpParameters",
  "parseMsid",
  "spec",
  "planB",
  "msidParts",
  "parseSctpDescription",
  "maxSizeLine",
  "isNaN",
  "sctpPort",
  "fmt",
  "sctpMapLines",
  "writeSctpDescription",
  "media",
  "output",
  "generateSessionId",
  "substr",
  "writeSessionBoilerplate",
  "sessId",
  "sessVer",
  "sessUser",
  "getDirection",
  "getKind",
  "isRejected",
  "parseOLine",
  "username",
  "sessionId",
  "sessionVersion",
  "netType",
  "addressType",
  "isValidSDP",
  "$cd55ff0e0516c779$var$adapter",
  "shimChrome",
  "shimFirefox",
  "shimSafari",
  "$11d9b3e4fc7791e1$export$2d31490a0c05f094",
  "userAgent",
  "mozGetUserMedia",
  "isSecureContext",
  "supportsUnifiedPlan",
  "RTCRtpTransceiver",
  "adapter",
  "commonShim",
  "extractVersion",
  "disableLog",
  "disableWarnings",
  "shimPeerConnection",
  "logging",
  "browserShim",
  "shimGetUserMedia",
  "shimMediaStream",
  "shimOnTrack",
  "shimAddTrackRemoveTrack",
  "shimGetSendersWithDtmf",
  "shimGetStats",
  "shimSenderReceiverGetStats",
  "fixNegotiationNeeded",
  "shimRemoveStream",
  "shimSenderGetStats",
  "shimReceiverGetStats",
  "shimRTCDataChannel",
  "shimAddTransceiver",
  "shimGetParameters",
  "shimCreateOffer",
  "shimCreateAnswer",
  "shimRTCIceServerUrls",
  "shimCreateOfferLegacy",
  "shimCallbacksAPI",
  "shimLocalStreamsAPI",
  "shimRemoteStreamsAPI",
  "shimTrackEventTransceiver",
  "shimAudioContext",
  "$f719426f9499296d$var$webRTCAdapter",
  "$f719426f9499296d$export$25be9502477c137d",
  "isWebRTCSupported",
  "isBrowserSupported",
  "getBrowser",
  "getVersion",
  "supportedBrowsers",
  "minChromeVersion",
  "minFirefoxVersion",
  "isIOS",
  "minSafariVersion",
  "isUnifiedPlanSupported",
  "tempPc",
  "supported",
  "close",
  "platform",
  "$fdc87120bf726113$export$f35f128fd59ea256",
  "$eb24a05d5e66c1f6$export$4e61f672936bec77",
  "$0c88dccd73f5641e$var$DEFAULT_CONFIG",
  "credential",
  "$0c88dccd73f5641e$export$7debb50ef11d5e0b",
  "noop",
  "blobToArrayBuffer",
  "fr",
  "FileReader",
  "onload",
  "evt",
  "readAsArrayBuffer",
  "binaryStringToArrayBuffer",
  "binary",
  "byteArray",
  "charCodeAt",
  "isSecure",
  "location",
  "CLOUD_HOST",
  "CLOUD_PORT",
  "chunkedBrowsers",
  "Chrome",
  "chrome",
  "defaultConfig",
  "browserVersion",
  "supports",
  "webRTC",
  "audioVideo",
  "binaryBlob",
  "reliable",
  "ordered",
  "binaryType",
  "validateId",
  "randomToken",
  "$6adb9b697958aa01$export$2e2bcd8739ae039",
  "logLevel",
  "_logLevel",
  "_print",
  "setLogFunction",
  "fn",
  "rest",
  "copy",
  "$6af28e6583ade012$exports",
  "$6af28e6583ade012$var$has",
  "$6af28e6583ade012$var$prefix",
  "$6af28e6583ade012$var$Events",
  "$6af28e6583ade012$var$EE",
  "context",
  "once",
  "$6af28e6583ade012$var$addListener",
  "emitter",
  "listener",
  "_events",
  "_eventsCount",
  "$6af28e6583ade012$var$clearEvent",
  "$6af28e6583ade012$var$EventEmitter",
  "create",
  "__proto__",
  "eventNames",
  "events",
  "getOwnPropertySymbols",
  "listeners",
  "handlers",
  "l",
  "ee",
  "listenerCount",
  "emit",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "len",
  "removeListener",
  "on",
  "removeAllListeners",
  "off",
  "addListener",
  "prefixed",
  "EventEmitter",
  "$ccd644f7486bf635$exports",
  "$9dca0f9415f15a97$export$4798917dbf149b79",
  "token",
  "_id",
  "wsUrl",
  "_baseUrl",
  "_socket",
  "_disconnected",
  "WebSocket",
  "onmessage",
  "Message",
  "onclose",
  "_cleanup",
  "Disconnected",
  "onopen",
  "_sendQueuedMessages",
  "_scheduleHeartbeat",
  "_wsPingTimer",
  "setTimeout",
  "_sendHeartbeat",
  "pingInterval",
  "_wsOpen",
  "Heartbeat",
  "copiedQueue",
  "_messagesQueue",
  "clearTimeout",
  "secure",
  "host",
  "path",
  "wsProtocol",
  "$09f4090c200a4747$export$89e6bb5ad64bf4a",
  "startConnection",
  "peerConnection",
  "_startPeerConnection",
  "connection",
  "Media",
  "_stream",
  "_addTracksToConnection",
  "originator",
  "dataConnection",
  "config",
  "_initializeDataChannel",
  "_makeOffer",
  "handleSDP",
  "provider",
  "_setupListeners",
  "peerId",
  "peer",
  "connectionId",
  "connectionType",
  "onicecandidate",
  "socket",
  "Candidate",
  "payload",
  "dst",
  "oniceconnectionstatechange",
  "emitError",
  "NegotiationFailed",
  "ConnectionClosed",
  "ondatachannel",
  "getConnection",
  "ontrack",
  "_addStreamToMediaConnection",
  "cleanup",
  "peerConnectionNotClosed",
  "dataChannelNotClosed",
  "offer",
  "sdpTransform",
  "metadata",
  "Data",
  "serialization",
  "Offer",
  "WebRTC",
  "err_1",
  "_makeAnswer",
  "answer",
  "Answer",
  "self",
  "handleCandidate",
  "ice",
  "mediaConnection",
  "$a084ca3b0aa8dd08$export$6a678e589c8a4542",
  "$a084ca3b0aa8dd08$export$98871882f492de82",
  "$e7e1c6f19b5349be$export$23a2a68283c24d80",
  "open",
  "_open",
  "$b568d66a5799a705$export$4a84e95a2324ac29",
  "localStream",
  "_localStream",
  "remoteStream",
  "_remoteStream",
  "handleMessage",
  "_negotiator",
  "_payload",
  "_getMessages",
  "_removeConnection",
  "ID_PREFIX",
  "$916c68e858bb49ef$export$2c4e825dc9120f87",
  "_buildRequest",
  "_options",
  "URL",
  "searchParams",
  "now",
  "fetch",
  "href",
  "referrerPolicy",
  "retrieveId",
  "status",
  "text",
  "pathError",
  "listAllPeers",
  "helpfulError",
  "json",
  "$4f9d208d5e349370$export$d365f7ad9d7df9c9",
  "chunked",
  "NotOpenYet",
  "_send",
  "MAX_BUFFERED_AMOUNT",
  "$5a8a3892973da73a$export$ff7c9d4c11d94e8b",
  "bufferSize",
  "_bufferSize",
  "_handleDataMessage",
  "_bufferedSend",
  "msg",
  "_buffering",
  "_trySend",
  "_buffer",
  "bufferedAmount",
  "_tryBuffer",
  "$e27c324aebf32a14$export$f0a5a64d5bb37108",
  "_chunkedData",
  "deserializedData",
  "peerData",
  "_handleChunk",
  "chunkInfo",
  "count",
  "_send_blob",
  "chunker",
  "_sendChunks",
  "blobPromise",
  "blobs",
  "Binary",
  "$f1ddf74f51c0f6f4$export$6f88fe47d32c9c94",
  "_chunked",
  "None",
  "$c051ae28a1212d1c$export$48880ac635f47186",
  "decoder",
  "decode",
  "encodedData",
  "MessageToBig",
  "TextDecoder",
  "$400fc96dabc502a5$export$ecd1fc136c422448",
  "connections",
  "plainConnections",
  "k",
  "_connections",
  "destroyed",
  "_destroyed",
  "disconnected",
  "_createServerConnection",
  "_handleMessage",
  "_abort",
  "SocketError",
  "Network",
  "disconnect",
  "Close",
  "SocketClosed",
  "_initialize",
  "src",
  "Open",
  "_lastServerId",
  "ServerError",
  "IdTaken",
  "UnavailableID",
  "InvalidKey",
  "Leave",
  "_cleanupPeer",
  "Expire",
  "PeerUnavailable",
  "_addConnection",
  "_serializers",
  "_storeMessage",
  "_lostMessages",
  "messages",
  "connect",
  "_delayedAbort",
  "destroy",
  "currentId",
  "reconnect",
  "_",
  "_api",
  "peers",
  "userId",
  "raw",
  "debug",
  "DEFAULT_KEY",
  "serializers",
  "hostname",
  "logFunction",
  "BrowserIncompatible",
  "InvalidID",
  "peerjs",
  "Peer",
  "util"
  ],
  version: 3,
  file: "peerjs.min.js.map"
  }